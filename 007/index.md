# TCP 四次挥手


<!--more-->

## 1. 四次挥手，关闭连接

由于TCP连接是全双工的，即连接双方可以在一条TCP连接上互相传输数据，每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个`FIN`来终止这个方向的连接。收到一个`FIN`只意味着这一方向上没有数据流动，一个 TCP 连接在收到一个`FIN`后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭，因此在断开时存在一个半关闭状态，即有有一方失去发送数据的能力，却还能接收数据。所以，断开连接需要分为四次 ，称为**四次挥手**。

客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行`close()`操作即可产生挥手操作。

以下，我们假设由客户端主动触发close()。



## 2. 四次挥手流程图

![四次挥手流程图](https://i.loli.net/2019/12/09/5pbistqQF7XTxBV.png)

- **第一次挥手(FIN=1，seq=u)**
  假设假客户端主动触发close()，客户端发送一个FIN标志位为 1 的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。因为有可能服务器还要发送数据，所以发送自己的序列号seq=u，等待服务器确认。发送完毕后，客户端进入FIN_WAIT_1状态。

- **第二次挥手(ACK=1，seq=v，ack=u+1)**
  服务器端确认客户端的FIN包，发送一个确认包【ACK=1(确认)、seq=v(自己的序列号)、ack=u+1(确认收到序列号)】，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接(可能有数据发送)。
  发送完毕后，服务器端进入CLOSE_WAIT状态，客户端接收到这个确认包之后，进入FIN_WAIT_2状态，等待服务器端关闭连接。
  在这过程中 TCP 服务器进程会通知高层应用进程。然后从客户端到服务器这个方向的连接就释放了，TCP 连接处于半关闭状态。但是服务器若发送数据，客户端仍要接收。

- **第三次挥手(FIN=1，ACK=1，seq=w，ack=u+1)**
  若服务器已经没有要向客户端发送的数据，其应用进程就通知 TCP 释放连接。
  服务器端准备好关闭连接时，向客户端发送结束连接请求FIN置为 1，ACK=1，seq=w(有数据发送过)，ack=u+1。
  发送完毕后，服务器端进入LAST_ACK状态，等待来自客户端的最后一个ACK。

- **第四次挥手(ACK=1，seq=u+1，ack=w+1)**
  客户端接收到来自服务器端的关闭请求，发送一个确认包(在确认报文段中ACK=1，确认号ack=w+1，自己的序号seq=u+1)，并进入TIME_WAIT状态，等待可能出现的要求重传的ACK包。(这个确认包是内核进行发送的，上面不能发数据的是客户端的send函数)
  服务器端接收到这个确认包之后，关闭连接，进入CLOSED状态。
  客户端等待了某个固定时间（两个最大段生命周期，`2MSL`（2 Maximum Segment Lifetime），即2个最长报文段寿命， `RFC 793`中规定MSL为2分钟，而Linux中设置为30秒 ）之后，没有收到服务器端的ACK，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入CLOSED状态。

  

## 3. 四次挥手抓包分析

![四次挥手抓包分析](https://i.loli.net/2019/12/09/4ZnKhodQpuNfmiE.png)



## 4. 问题

### 为什么会有TIME_WAIT状态？

- 网络可能不可靠，需要确保有足够的时间让对方收到ACK包。被动关闭方处于`LAST_ACK`状态下的`SOCKET`可能会因为超时未收到ACK报文，而重发FIN报文（这一来一去正好是2SML）。 

- 避免新旧连接混淆。有的路由器会缓存IP数据包，如果连接被重用了，那么这些延迟收到的包就有可能会跟新连接混在一起。

  

### TIME_WAIT状态会带来的影响 ?

当某个连接的一端处于TIME_WAIT状态时，该连接将不能再被使用。事实上，对于我们比较有现实意义的是，这个端口将不能再被使用。

某个端口处于TIME_WAIT状态(其实应该是这个连接)时，这意味着这个 TCP 连接并没有断开(完全断开)，那么，如果你bind这个端口，就会失败。对于服务器而言，如果服务器突然坏掉了，那么它将无法再2MSL内重新启动，因为bind会失败。

解决这个问题的一个方法就是设置 socket 的`SO_REUSEADDR`选项。这个选项意味着你可以重用一个地址。



### 服务器出现大量CLOSE_WAIT状态的原因？

对方关闭socket连接，我方忙于读或写，没有及时关闭连接。

- 检查代码，特别是释放资源的代码
- 检查配置，特别是处理请求的线程配置

可以使用以下命令查看服务器是否有大量CLOSE_WAIT

```c
netstat -n | awk '/^tcp/{++S[$NF]}END{for(a in S) print a,S[a]}'
```

![MacOS下的测试](https://i.loli.net/2019/12/09/5XsPjp2oZCmOngW.jpg)



### 为什么需要四次握手才能断开连接？

因为全双工，发送方和接收方都需要FIN报文和ACK报文，当被动方收到主动方的FIN报文通知时，它仅仅表示主动方没有数据再发送给被动方了。但未必被动方所有的数据都完整的发送给了主动方，所以被动方不会马上关闭SOCKET，它可能还需要发送一些数据给主动方后，再发送FIN报文给主动方，告诉主动方同意关闭连接，所以这里的ACK报文和FIN报文多数情况下都是分开发送的。

由于网络服务的不可靠性，必须考虑到在释放连接时，可能由于数据包的失序而使释放连接请求的数据包会比其他数据包先到达目的端。此时，如果目的端由于收到了释放连接请求的数据包而立即释放该连接，则会造成那些先发而后至的数据包丢失。



</br>

<center> ·End </center>
<center> 转载请注明出处: <a href="https://halklein.github.io/">https://halklein.github.io/</a> </center>
