<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on HalKlein`s Blog</title>
    <link>https://halklein.github.io/posts/</link>
    <description>Recent content in Posts on HalKlein`s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <managingEditor>dev.HalKlein@gmail.com (HalKlein)</managingEditor>
    <webMaster>dev.HalKlein@gmail.com (HalKlein)</webMaster>
    <lastBuildDate>Thu, 30 Jan 2020 15:31:41 +0800</lastBuildDate>
    <atom:link href="https://halklein.github.io/posts/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Redis 高性能存储入门</title>
      <link>https://halklein.github.io/2020/031/</link>
      <pubDate>Thu, 30 Jan 2020 15:31:41 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2020/031/</guid>
      <description>

&lt;h2 id=&#34;redis简介&#34;&gt;Redis简介&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://redis.io/images/redis-white.png&#34; alt=&#34;Redis&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Redis是一款基于键值对的&lt;strong&gt;NoSQL&lt;/strong&gt;数据库，它的值支持多种数据结构：
字符串（strings）、哈希（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）等。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Redis将所有的数据都存放在内存中，所以它的读写性能十分惊人。
同时，Redis还可以将内存中的数据以快照 (适合空闲的时候进行) 或日志 (AOF，可以实时存，但恢复速度慢)  的形式保存到硬盘上，以保证数据的安全性。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Redis典型的应用场景包括：&lt;strong&gt;缓存&lt;/strong&gt;、&lt;strong&gt;排行榜&lt;/strong&gt;、&lt;strong&gt;计数器&lt;/strong&gt;、&lt;strong&gt;社交网络&lt;/strong&gt;、&lt;strong&gt;消息队列&lt;/strong&gt; (但Redis不是专业的消息队列工具) 等。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;官网：&lt;a href=&#34;https://redis.io&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://redis.io&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Windows平台：&lt;a href=&#34;https://github.com/microsoftarchive/redis&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/microsoftarchive/redis&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;安装-for-windows&#34;&gt;安装 for Windows&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;下载地址&lt;/strong&gt;：&lt;a href=&#34;https://github.com/microsoftarchive/redis/releases&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/microsoftarchive/redis/releases&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;默认端口&lt;/strong&gt;：&lt;code&gt;6379&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Redis默认内置了16个库 ，可以通过 select 0-15 进行切换，默认进入0&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;$ redis-cli
127.0.0.1:6379&amp;gt; select 1
OK
127.0.0.1:6379[1]&amp;gt; select 0
OK
127.0.0.1:6379&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;刷除库内的数据&lt;/strong&gt;：flushdb&lt;/p&gt;

&lt;p&gt;注意Redis中key的命名提倡使用 &lt;code&gt;:&lt;/code&gt; 连接而不是 &lt;code&gt;_&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;redis常用数据类型的使用&#34;&gt;Redis常用数据类型的使用&lt;/h2&gt;

&lt;h3 id=&#34;字符串-string-类型数据-测试&#34;&gt;&lt;strong&gt;字符串 （String）类型数据 测试&lt;/strong&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;# 存String测试
127.0.0.1:6379&amp;gt; set author HalKlein
OK
# 查询String数据
127.0.0.1:6379&amp;gt; get author
&amp;quot;HalKlein&amp;quot;
127.0.0.1:6379&amp;gt;
127.0.0.1:6379&amp;gt; set count 1
OK
127.0.0.1:6379&amp;gt; get count
&amp;quot;1&amp;quot;
# 加1
127.0.0.1:6379&amp;gt; incr count
(integer) 2
# 减1
127.0.0.1:6379&amp;gt; decr count
(integer) 1
127.0.0.1:6379&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h3 id=&#34;哈希-hashes-类型数据-测试&#34;&gt;哈希（hashes）类型数据 测试**&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;# Hash存数据
127.0.0.1:6379&amp;gt; hset test:user id 1
(integer) 1
# Hash存数据
127.0.0.1:6379&amp;gt; hset test:user username HalKlein
(integer) 1
# Hash取数据
127.0.0.1:6379&amp;gt; hget test:user username
&amp;quot;HalKlein&amp;quot;
# Hash取数据
127.0.0.1:6379&amp;gt; hget test:user id
&amp;quot;1&amp;quot;
127.0.0.1:6379&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h3 id=&#34;列表-lists-类型数据-测试&#34;&gt;列表（lists）类型数据 测试**&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/01/30/hIRMju15YPQnHFg.png&#34; alt=&#34;Redis列表&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Redis的列表可以看作一个横向的容器，&lt;/p&gt;

&lt;p&gt;我们往里面存数据时，支持从左边往里“装”，也支持从右边往里“装”，&lt;/p&gt;

&lt;p&gt;取数据时，支持从左边取数据，也支持从右边取数据，&lt;/p&gt;

&lt;p&gt;根据这样的设计，如果我们的数据从一端进，从另一端出，就可以看作是一个&lt;strong&gt;队列&lt;/strong&gt;；&lt;/p&gt;

&lt;p&gt;如果我们的数据从一端进，也从该端出，就可以看作是一个&lt;strong&gt;栈&lt;/strong&gt;；&lt;/p&gt;

&lt;h4 id=&#34;list左进右出演示&#34;&gt;&lt;strong&gt;List左进右出演示&lt;/strong&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;# List左端进数据
127.0.0.1:6379&amp;gt; lpush test:ids 101 102 103
(integer) 3
# List长度查询
127.0.0.1:6379&amp;gt; llen test:ids
(integer) 3
# 根据List下标查数据
127.0.0.1:6379&amp;gt; lindex test:ids 0
&amp;quot;103&amp;quot;
# 查询List某范围之间的数据
127.0.0.1:6379&amp;gt; lrange test:ids 0 2
1) &amp;quot;103&amp;quot;
2) &amp;quot;102&amp;quot;
3) &amp;quot;101&amp;quot;
# 从右端弹出数据
127.0.0.1:6379&amp;gt; rpop test:ids
&amp;quot;101&amp;quot;
# 从右端弹出数据
127.0.0.1:6379&amp;gt; rpop test:ids
&amp;quot;102&amp;quot;
# List长度查询
127.0.0.1:6379&amp;gt; llen test:ids
(integer) 1
127.0.0.1:6379&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h3 id=&#34;集合-sets-类型数据-测试&#34;&gt;集合（sets）类型数据 测试&lt;/h3&gt;

&lt;p&gt;集合是无序的，且内容是不能重复的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;# 集合中添加数据
127.0.0.1:6379&amp;gt; sadd test:student aaa bbb ccc ddd eee
(integer) 5
# 统计集合中元素个数
127.0.0.1:6379&amp;gt; scard test:student
(integer) 5
# 从集合中随机弹出一个元素
127.0.0.1:6379&amp;gt; spop test:student
&amp;quot;aaa&amp;quot;
# 从集合中随机弹出一个元素
127.0.0.1:6379&amp;gt; spop test:student
&amp;quot;eee&amp;quot;
# 查看集合中的元素
127.0.0.1:6379&amp;gt; smembers test:student
1) &amp;quot;bbb&amp;quot;
2) &amp;quot;ccc&amp;quot;
3) &amp;quot;ddd&amp;quot;
127.0.0.1:6379&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h3 id=&#34;有序集合-sorted-sets-类型数据-测试&#34;&gt;有序集合（sorted sets）类型数据 测试&lt;/h3&gt;

&lt;p&gt;顾名思义，该集合是有序的，它会根据元素的score进行排序（默认由小到大）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;# 有序集合添加数据
127.0.0.1:6379&amp;gt; zadd test:teachers 20 aaa 10 bbb 50 ccc 30 ddd 40 eee
(integer) 5
# 统计有序集合中元素数量
127.0.0.1:6379&amp;gt; zcard test:teachers
(integer) 5
# 查询有序集合中的元素的score
127.0.0.1:6379&amp;gt; zscore test:teachers eee
&amp;quot;40&amp;quot;
# 查询有序集合中元素的位置排名
127.0.0.1:6379&amp;gt; zrank test:teachers eee
(integer) 3
# 查询某个范围间的所有元素
127.0.0.1:6379&amp;gt; zrange test:teachers 0 3
1) &amp;quot;bbb&amp;quot;
2) &amp;quot;aaa&amp;quot;
3) &amp;quot;ddd&amp;quot;
4) &amp;quot;eee&amp;quot;
127.0.0.1:6379&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;其它的一些常用命令&#34;&gt;其它的一些常用命令&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;# 查询所有的key
127.0.0.1:6379&amp;gt; keys *
1) &amp;quot;author&amp;quot;
2) &amp;quot;test:user&amp;quot;
3) &amp;quot;count&amp;quot;
4) &amp;quot;test:ids&amp;quot;
5) &amp;quot;test:student&amp;quot;
6) &amp;quot;test:teachers&amp;quot;
# 查询以 ‘test’开头的key
127.0.0.1:6379&amp;gt; keys test*
1) &amp;quot;test:user&amp;quot;
2) &amp;quot;test:ids&amp;quot;
3) &amp;quot;test:student&amp;quot;
4) &amp;quot;test:teachers&amp;quot;
# 查询某个key对应的value的值的类型
127.0.0.1:6379&amp;gt; type test:user
hash
# 查询某个key是否存在
127.0.0.1:6379&amp;gt; exists test:user
(integer) 1
# 删除某个key，会连带value一起删除
127.0.0.1:6379&amp;gt; del test:user
(integer) 1
# 再次查询某个key是否存在
127.0.0.1:6379&amp;gt; exists test:user
(integer) 0
# 指定某个key的有效时间
127.0.0.1:6379&amp;gt; expire test:student 10
(integer) 1
# 查询所有的key
127.0.0.1:6379&amp;gt; keys *
1) &amp;quot;author&amp;quot;
2) &amp;quot;count&amp;quot;
3) &amp;quot;test:ids&amp;quot;
4) &amp;quot;test:student&amp;quot;
5) &amp;quot;test:teachers&amp;quot;
# 10多秒后，再次查询所有的key
127.0.0.1:6379&amp;gt; keys *
1) &amp;quot;author&amp;quot;
2) &amp;quot;count&amp;quot;
3) &amp;quot;test:ids&amp;quot;
4) &amp;quot;test:teachers&amp;quot;
127.0.0.1:6379&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用Spring AOP统一记录日志</title>
      <link>https://halklein.github.io/2020/030/</link>
      <pubDate>Thu, 30 Jan 2020 12:26:21 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2020/030/</guid>
      <description>

&lt;h2 id=&#34;需求&#34;&gt;需求&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/01/30/vaD453kgpyC9nI1.png&#34; alt=&#34;需求&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果我们每次都在业务组件中记录日志，但是记录日志并不是业务需求，它属于系统需求。&lt;/p&gt;

&lt;h2 id=&#34;aop的概念&#34;&gt;AOP的概念&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Aspect Oriented Programing&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​   即面向方面（切面）编程。
​   AOP是一种编程思想，是对OOP的补充，可以进一步提高编程的效率。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/01/30/hZgODSCvFdHEliQ.png&#34; alt=&#34;AOP的概念&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;aop的术语&#34;&gt;&lt;strong&gt;AOP的术语&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/01/30/FbLUmHqE5BWy7Nx.png&#34; alt=&#34;AOP的术语&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Target&lt;/strong&gt;：目标对象，程序中的每一个要处理的Bean我们称之为Target&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Joinpoint&lt;/strong&gt;：连接点，目标对象有很多地方能够被织入代码，其可以织入代码的地方，我们称之为连接点&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Aspect&lt;/strong&gt;：切面组件，AOP解决统一处理这些系统需求的方式是将代码定义到一个额外的Bean中，Pointcut声明代码到底要织入到哪些对象的哪些位置，Advice通知方法说明这个切面组件要处理怎样的逻辑。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Weaving&lt;/strong&gt;：切面组件在程序运行之前或之后，通过框架织入到某些连接点之上，在编译时织入效率会很高，但是系统未运行时，可能有些条件我们并不能得到，就需要在运行时织入，运行时织入很方便灵活，但是效率不高。&lt;/p&gt;

&lt;h2 id=&#34;aop的实现&#34;&gt;AOP的实现&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;AspectJ&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​   AspectJ是&lt;strong&gt;语言级&lt;/strong&gt;的实现（新的语言），它扩展了Java语言，定义了AOP语法。&lt;/p&gt;

&lt;p&gt;​   AspectJ在&lt;strong&gt;编译期&lt;/strong&gt;织入代码，支持各种类型的连接点，它有一个专门的编译器，用来生成遵守Java字节码规范的class文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Spring AOP&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​   Spring AOP使用纯 &lt;strong&gt;Java实现&lt;/strong&gt;，它&lt;strong&gt;不需要专门的编译过程&lt;/strong&gt;，也&lt;strong&gt;不需要特殊的类装载器&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;​   Spring AOP在 &lt;strong&gt;运行时&lt;/strong&gt; 通过代理的方式织入代码，&lt;strong&gt;只支持方法类型的连接点&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;​   Spring&lt;strong&gt;支持&lt;/strong&gt;对&lt;strong&gt;AspectJ&lt;/strong&gt;的集成。&lt;/p&gt;

&lt;h2 id=&#34;spring-aop-代理&#34;&gt;Spring AOP 代理&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;JDK 动态代理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​   Java提供的动态代理技术，可以在运行时创建&lt;strong&gt;接口&lt;/strong&gt;的代理实例。&lt;/p&gt;

&lt;p&gt;​   Spring AOP&lt;strong&gt;默认&lt;/strong&gt;采用此种方式，在接口的代理实例中织入代码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CGLib 动态代理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​   采用底层的&lt;strong&gt;字节码技术&lt;/strong&gt;，在运行时创建&lt;strong&gt;子类&lt;/strong&gt;代理实例。&lt;/p&gt;

&lt;p&gt;​   当目标对象不存在接口时，Spring AOP会采用此种方式，在子类实例中织入代码。&lt;/p&gt;

&lt;h2 id=&#34;示例-记录用户访问方法的信息&#34;&gt;示例 记录用户访问方法的信息&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
// 切面组件
@Aspect
public class ServiceLogAspect {

    // 记录日志
    private static final Logger logger = LoggerFactory.getLogger(ServiceLogAspect.class);

    /**
     * 定义切点@Pointcut，其中筛选目标，
     * 第1个*表示返回值任意，
     * 第2个*表示所有组件，
     * 第3个*表示所有的方法，
     * (..)表示所有的参数
     */
    @Pointcut(&amp;quot;execution(* me.halklein.community.service.*.*(..))&amp;quot;)
    public void pointcut() {

    }

    // 在连接点开始@Before，pointcut()表示切点是什么
    @Before(&amp;quot;pointcut()&amp;quot;)
    public void before(JoinPoint joinPoint) {
        // 记录格式：用户[IP地址]，在[xxx]，访问了[me.halklein.community.service.xxx()]
        // 获取Request对象
        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        HttpServletRequest request = attributes.getRequest();
        // 获取访问者IP
        String ip = request.getRemoteHost();
        String now = new SimpleDateFormat(&amp;quot;yyyy-MM-dd HH:mm:ss&amp;quot;).format(new Date());
        // 获取类名，方法名
        String target = joinPoint.getSignature().getDeclaringTypeName() + &amp;quot;.&amp;quot; + joinPoint.getSignature().getName();
        logger.info(String.format(&amp;quot;用户[%s]，在[%s]，访问了[%s].&amp;quot;, ip, now, target));
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;查看日志&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/01/30/aCo5ALIVRyr6l9U.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Spring统一处理异常</title>
      <link>https://halklein.github.io/2020/029/</link>
      <pubDate>Thu, 30 Jan 2020 11:57:56 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2020/029/</guid>
      <description>

&lt;p&gt;在系统出现错误时，我们希望系统给用户图形化的反馈，而不是一些状态错误信息。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/01/30/WfvGOd1js3tcQMe.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;各个层次都会出现错误，但其实最终都会抛出异常给表现层。所以我们只用在表现层中捕获异常，处理异常，就能处理系统中所有的异常。&lt;/p&gt;

&lt;h2 id=&#34;springboot自动化处理异常&#34;&gt;&lt;strong&gt;SpringBoot自动化处理异常&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;SpringBoot统一处理异常，我们需要在templates目录下新建&lt;code&gt;error&lt;/code&gt;目录，然后在里面新建错误页面文件，且文件的名字一定要对应错误状态码。就可以简单实现对异常的统一处理。&lt;/p&gt;

&lt;h2 id=&#34;spring处理异常&#34;&gt;&lt;strong&gt;Spring处理异常&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;但是SpringBoot统一处理异常，并不是很详细，有时候并不能满足我们的需要，我们可能需要进行更加详细和复杂的操作，这时可以使用Spring进行更详细的配置。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;@ControllerAdvice&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​   用于修饰类，表示该类是Controller的全局配置类。&lt;/p&gt;

&lt;p&gt;​   在此类中，可以对Controller进行如下三种全局配置：&lt;strong&gt;异常处理方案、绑定数据方案、绑定参数方案&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;@ExceptionHandler&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​   用于修饰方法，该方法会在Controller出现异常&lt;strong&gt;后&lt;/strong&gt;被调用，用于&lt;strong&gt;处理捕获到的异常&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;@ModelAttribute&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​   用于修饰方法，该方法会在Controller方法执行&lt;strong&gt;前&lt;/strong&gt;被调用，用于为Model对象&lt;strong&gt;绑定参数&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;@DataBinder&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​   用于修饰方法，该方法会在Controller方法执行&lt;strong&gt;前&lt;/strong&gt;被调用，用于&lt;strong&gt;绑定参数&lt;/strong&gt;的转换器。&lt;/p&gt;

&lt;p&gt;在controller包下advice包，里面新建ExceptionAdvice类，用于处理全局异常&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Controller异常全局配置类
 * annotations = Controller.class 只扫描Controller组件
 */
@ControllerAdvice(annotations = Controller.class)
public class ExceptionAdvice {

    private static final Logger logger = LoggerFactory.getLogger(ExceptionAdvice.class);

    /**
     * @ExceptionHandler 声明该方法用于处理异常
     * Exception.class 处理所有异常
     */
    @ExceptionHandler({Exception.class})
    public void handleException(Exception e, HttpServletRequest request, HttpServletResponse response) throws IOException {
        logger.error(&amp;quot;服务器发生异常: &amp;quot;, e.getMessage());
        // 遍历详细的异常栈信息
        for (StackTraceElement element : e.getStackTrace()) {
            logger.error(element.toString());
        }

        // 重定向
        // 判断是普通请求还是异步请求
        String xRequestWith = request.getHeader(&amp;quot;x-requested-with&amp;quot;);

        if (&amp;quot;XMLHttpRequest&amp;quot;.equals(xRequestWith)) {
            // XMLHttpRequest 异步请求

            // application/json 返回字符串后，浏览器会自动转换为json对象
            // application/plain 返回一个普通字符串，可以是json格式，浏览器需要认为转换为js对象
            response.setContentType(&amp;quot;application/plain;charset=utf-8&amp;quot;);
            // 输出
            PrintWriter writer = response.getWriter();
            writer.write(CommunityUtil.getJsonString(1, &amp;quot;服务器异常！&amp;quot;));
        } else {
            // 是一个普通请求，发生错误，我们进行重定向
            response.sendRedirect(request.getContextPath() + &amp;quot;/error&amp;quot;);
        }
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Spring事务管理</title>
      <link>https://halklein.github.io/2020/028/</link>
      <pubDate>Tue, 28 Jan 2020 18:59:06 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2020/028/</guid>
      <description>

&lt;h2 id=&#34;什么是事务&#34;&gt;什么是事务&lt;/h2&gt;

&lt;p&gt;事务是由N步数据库操作序列组成的逻辑执行单元，这系列操作要么全执行，要么全放弃执行。&lt;/p&gt;

&lt;h2 id=&#34;事务的特性-acid&#34;&gt;事务的特性（ACID）&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/01/28/NesIWh9K742wjdP.png&#34; alt=&#34;事务的特性&#34; /&gt;&lt;/p&gt;

&lt;p&gt;原子性（Atomicity）：事务是应用中不可再分的最小执行体。&lt;/p&gt;

&lt;p&gt;一致性（Consistency）：事务执行的结果，须使数据从一个一致性状态，变为另一个一致性状态。&lt;/p&gt;

&lt;p&gt;隔离性（Isolation）：各个事务的执行互不干扰，任何事务的内部操作对其他的事务都是隔离的。&lt;/p&gt;

&lt;p&gt;持久性（Durability）：事务一旦提交，对数据所做的任何改变都要记录到永久存储器中。&lt;/p&gt;

&lt;h2 id=&#34;事务的隔离性&#34;&gt;事务的隔离性&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;常见的并发异常&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一类丢失更新、第二类丢失更新。&lt;/p&gt;

&lt;p&gt;脏读、不可重复读、幻读。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;常见的隔离级别&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Read Uncommitted：读取未提交的数据。&lt;/p&gt;

&lt;p&gt;Read Committed：读取已提交的数据。&lt;/p&gt;

&lt;p&gt;Repeatable Read：可重复读。&lt;/p&gt;

&lt;p&gt;Serializable：串行化 （性能低）。&lt;/p&gt;

&lt;h3 id=&#34;常见的并发异常&#34;&gt;常见的并发异常&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;第一类丢失更新&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;某一个事务的回滚，导致另外一个事务已更新的数据丢失了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/01/28/r3B2UXDYupGqRtb.png&#34; alt=&#34;第一类丢失更新&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第二类丢失更新&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;某一个事务的提交，导致另外一个事务已更新的数据丢失了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/01/28/PHW9FnDOIZ6gRid.png&#34; alt=&#34;第二类丢失更新&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;脏读&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;某一个事务，读取了另外一个事务未提交的数据。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/01/28/uDXo7y28nI3ZVBs.png&#34; alt=&#34;脏读&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;不可重复读&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;某一个事务，对同一个数据前后读取的结果不一致。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/01/28/ZdOCKQrPpyBYE36.png&#34; alt=&#34;不可重复读&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;幻读&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;某一个事务，对同一个表前后查询到的行数不一致。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/01/28/CoYSLuRg2tQPWMf.png&#34; alt=&#34;幻读&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;常见的隔离级别&#34;&gt;常见的隔离级别&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/01/28/1lMsQTVYJGynihg.png&#34; alt=&#34;常见的隔离级别&#34; /&gt;&lt;/p&gt;

&lt;p&gt;一般来说，我们选择中间两种。第一中几乎没有改善；第四种由于性能非常低，一般是不选用的，除非是金融类业务，政府部分数据等才考虑。&lt;/p&gt;

&lt;h2 id=&#34;实现机制&#34;&gt;实现机制&lt;/h2&gt;

&lt;h3 id=&#34;悲观锁-数据库&#34;&gt;悲观锁（数据库）&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;共享锁（S锁）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;事务A对某数据加了共享锁后，其他事务只能对该数据加共享锁，但不能加排他锁。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;排他锁（X锁）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;事务A对某数据加了排他锁后，其他事务对该数据既不能加共享锁，也不能加排他锁。&lt;/p&gt;

&lt;h3 id=&#34;乐观锁-自定义&#34;&gt;乐观锁（自定义）&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;版本号、时间戳等&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在更新数据前，检查版本号是否发生变化。若变化则取消本次更新，否则就更新数据（版本号+1）。&lt;/p&gt;

&lt;h2 id=&#34;spring-事务管理-https-docs-spring-io-spring-docs-current-spring-framework-reference-data-access-html-spring-data-tier&#34;&gt;&lt;a href=&#34;https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#spring-data-tier&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Spring 事务管理&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;声明式事务&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过XML配置，声明某方法的事务特征。&lt;/p&gt;

&lt;p&gt;通过注解，声明某方法的事务特征。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;编程式事务&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过 TransactionTemplate 管理事务，并通过它执行数据库的操作。&lt;/p&gt;

&lt;p&gt;声明式事务基于 AOP，将具体业务逻辑与事务处理解耦。声明式事务管理使业务代码逻辑不受污染，因此在实际使用中声明式事务用的比较多。声明式事务有两种方式，一种是在配置文件（xml）中做相关的事务规则声明，另一种是基于@Transactional 注解的方式，注释配置是目前流行的使用方式。&lt;/p&gt;

&lt;h5 id=&#34;transactional-注解的属性信息&#34;&gt;@Transactional 注解的属性信息&lt;/h5&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;属性名&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;name&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;当在配置文件中有多个 TransactionManager , 可以用该属性指定选择哪个事务管理器。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;propagation&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;事务的传播行为，默认值为 REQUIRED。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;isolation&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;事务的隔离度，默认值采用 DEFAULT。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;timeout&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;read-only&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;指定事务是否为只读事务，默认值为 false；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;rollback-for&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;用于指定能够触发事务回滚的异常类型，如果有多个异常类型需要指定，各类型之间可以通过逗号分隔。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;no-rollback- for&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;抛出 no-rollback-for 指定的异常类型，不回滚事务。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;声明式事务示例&#34;&gt;声明式事务示例&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;业务方法&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
/*Spring容器管理的Bean默认是单例的，如果需要每次getBean都新建一个实例，需要加上如下
@Scope(&amp;quot;singleton&amp;quot;)是默认的（单例的）*/
@Scope(&amp;quot;prototype&amp;quot;) // 非单例，（极少使用）
public class AlphaService {

    @Autowired
    private UserMapper userMapper;

    @Autowired
    private DiscussPostMapper discussPostMapper;

    /**
     * Spring 事务管理测试
     * Spring 事务管理，加注解：@Transactional，设置事务级别：isolation = Isolation.READ_COMMITTED
     * propagation 事务的传播机制，解决事务交叉问题。如【 业务方法A 去调用 业务方法B 】他们都加有事务注解，那么B的事务应该以谁为准？的问题
     *      REQUIRED 支持当前事务（外部事务，上例事务A），如果不存在则创建新事务
     *      REQUIRES_NEW 创建一个新的事务，并且暂定当前事务（外部事务）
     *      NESTED 如果存在当前事务（外部事务），则嵌套在该事务中执行（B有独立的提交和回滚），否则就和 REQUIRED 一样
     *
     * @return
     */
    @Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRED)
    public Object save1() {
        // 新增用户
        User user = new User();
        user.setUsername(&amp;quot;alpha&amp;quot;);
        user.setSalt(CommunityUtil.generateUUID().substring(0, 5));
        user.setPassword(CommunityUtil.md5(&amp;quot;123&amp;quot;) + user.getSalt());
        user.setEmail(&amp;quot;alpha@qq.com&amp;quot;);
        user.setHeaderUrl(&amp;quot;http://image.nowcoder.com/99t.png&amp;quot;);
        user.setCreateTime(new Date());
        userMapper.insertUser(user);

        // 新增帖子
        DiscussPost post = new DiscussPost();
        post.setUserId(user.getId());
        post.setTitle(&amp;quot;Hello&amp;quot;);
        post.setContent(&amp;quot;新人报道&amp;quot;);
        post.setCreateTime(new Date());
        discussPostMapper.insertDiscussPost(post);

        // 人工制造错误，用于测试
        Integer.valueOf(&amp;quot;abc&amp;quot;);

        return &amp;quot;OK&amp;quot;;
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;测试类&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootTest
@ContextConfiguration(classes = CommunityApplication.class)
public class TransactionTests {

    @Autowired
    private AlphaService alphaService;

    @Test
    public void testSave1() {
        Object obj = alphaService.save1();
        System.out.println(obj);
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;测试结果&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;没有在数据库中新增用户，也没有新增一条帖子。&lt;/p&gt;

&lt;h3 id=&#34;编程式事务示例&#34;&gt;编程式事务示例&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;业务方法&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
/*Spring容器管理的Bean默认是单例的，如果需要每次getBean都新建一个实例，需要加上如下
@Scope(&amp;quot;singleton&amp;quot;)是默认的（单例的）*/
@Scope(&amp;quot;prototype&amp;quot;) //非单例，（极少使用）
public class AlphaService {

    @Autowired
    private UserMapper userMapper;

    @Autowired
    private DiscussPostMapper discussPostMapper;

    @Autowired
    private TransactionTemplate transactionTemplate;

    
    /**
     * 编程式事务示例
     * 1. 注入 TransactionTemplate ，这个Bean是Spring自动创建并装配到容器中的，所以直接注入即可
     * @return
     */
    public Object save2(){
        // 设置事务级别
        transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_READ_COMMITTED);
        // 设置传播机制
        transactionTemplate.setPropagationBehavior(transactionTemplate.PROPAGATION_REQUIRED);

        return transactionTemplate.execute(new TransactionCallback&amp;lt;Object&amp;gt;() {
            @Override
            public Object doInTransaction(TransactionStatus transactionStatus) {
                // 新增用户
                User user = new User();
                user.setUsername(&amp;quot;beta&amp;quot;);
                user.setSalt(CommunityUtil.generateUUID().substring(0, 5));
                user.setPassword(CommunityUtil.md5(&amp;quot;123&amp;quot;) + user.getSalt());
                user.setEmail(&amp;quot;beta@qq.com&amp;quot;);
                user.setHeaderUrl(&amp;quot;http://image.nowcoder.com/999t.png&amp;quot;);
                user.setCreateTime(new Date());
                userMapper.insertUser(user);

                // 新增帖子
                DiscussPost post = new DiscussPost();
                post.setUserId(user.getId());
                post.setTitle(&amp;quot;你好&amp;quot;);
                post.setContent(&amp;quot;我是新人&amp;quot;);
                post.setCreateTime(new Date());
                discussPostMapper.insertDiscussPost(post);

                // 人工制造错误，用于测试
                Integer.valueOf(&amp;quot;abc&amp;quot;);

                return &amp;quot;OK&amp;quot;;
            }
        });
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;测试类&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootTest
@ContextConfiguration(classes = CommunityApplication.class)
public class TransactionTests {

    @Autowired
    private AlphaService alphaService;


    @Test
    public void testSave2() {
        Object obj = alphaService.save2();
        System.out.println(obj);
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;测试结果&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;同上，没有在数据库中新增用户，也没有新增一条帖子。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PS&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一般情况下我们选用简单的声明式事务，但是如果有些业务方法过于复杂，而我们只希望管理其中一部分事务，则选用编程式事务。&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>IDEA引入fastjson依赖失败的解决办法</title>
      <link>https://halklein.github.io/2020/027/</link>
      <pubDate>Mon, 27 Jan 2020 19:11:39 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2020/027/</guid>
      <description>

&lt;h2 id=&#34;问题&#34;&gt;问题&lt;/h2&gt;

&lt;p&gt;今天学习异步消息，用到 FastJson 对 json 进行解析和生成，但是在 &lt;code&gt;pom.xml&lt;/code&gt; 中引入下面的依赖描述时，等待许久也无法下载完成。之后尝试进行科学上网，并开启全局代理，依然是下载失败或下载不完全。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;fastjson&amp;lt;/artifactId&amp;gt;
   &amp;lt;version&amp;gt;1.2.62&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;解决办法&#34;&gt;解决办法&lt;/h2&gt;

&lt;p&gt;1.在 &lt;a href=&#34;https://mvnrepository.com/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;MVNrepository&lt;/a&gt; 官网直接找到对应的 jar 包链接，&lt;a href=&#34;https://repo1.maven.org/maven2/com/alibaba/fastjson/1.2.62/fastjson-1.2.62.jar&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;点击进行下载&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/01/27/gOTSzU6IrYm1WtA.png&#34; alt=&#34;MVNrepository&#34; /&gt;&lt;/p&gt;

&lt;p&gt;2.找到下载jar包的所在目录，使用maven命令直接进行安装，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;mvn install:install-file -Dfile=E:\Download\Chrome\fastjson-1.2.62.jar -DgroupId=com.alibaba -DartifactId=fastjson -Dversion=1.2.62 -Dpackaging=jar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/01/27/2AB9iKW6RIdGCXT.png&#34; alt=&#34;对应参数&#34; /&gt;&lt;/p&gt;

&lt;p&gt;安装成功后显示存放路径&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/01/27/L4Hk3bv5F1CrwaM.png&#34; alt=&#34;安装成功&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后需要IDEA的设置中设置Maven引用的路径为该路径，重启IDEA，重新加载依赖，就可以成功了！&lt;/p&gt;

&lt;p&gt;PS：同理，其它的依赖应该也可以这样操作。&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>用前缀树过滤敏感词</title>
      <link>https://halklein.github.io/2020/026/</link>
      <pubDate>Mon, 27 Jan 2020 12:09:44 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2020/026/</guid>
      <description>

&lt;h3 id=&#34;前缀树&#34;&gt;&lt;strong&gt;前缀树&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;​   &lt;strong&gt;名称：&lt;/strong&gt;Trie、字典树、查找树&lt;/p&gt;

&lt;p&gt;​   &lt;strong&gt;特点：&lt;/strong&gt;查找效率高，消耗内存大&lt;/p&gt;

&lt;p&gt;​   &lt;strong&gt;应用：&lt;/strong&gt;字符串检索、词频统计、字符串排序等&lt;/p&gt;

&lt;h3 id=&#34;敏感词过滤器&#34;&gt;&lt;strong&gt;敏感词过滤器&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;​   定义前缀树根据敏感词&lt;/p&gt;

&lt;p&gt;​   初始化前缀树&lt;/p&gt;

&lt;p&gt;​   编写过滤敏感词的方法&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;简单的进行查找和replace替换无疑效率是非常低的，我们使用一种叫前缀树（Trie、字典树、查找树）的数据结构来实现高效过滤敏感词，数据结构及过滤图示如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/01/27/W93QTOZsYUSN6IB.png&#34; alt=&#34;过滤敏感词&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step1 定义敏感词文件sensitive-words.txt，放在resources目录下&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;VPN
翻墙
吸毒
开票
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Step2 敏感词过滤器&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 敏感词过滤器
@Component
public class SensitiveFilter {

    // 记录日志
    private static final Logger logger = LoggerFactory.getLogger(SensitiveFilter.class);

    // 替换符（检测到敏感词，替换为某符号，定义为常量）
    private static final String REPLACEMENT = &amp;quot;***&amp;quot;;

    // 初始化前缀树
    private TrieNode rootNode = new TrieNode();


    // @PostConstruct表示这是一个初始化方法，当容器实例化这个Bean以后在调用它的构造器之后这个方法就会被自动调用
    @PostConstruct
    public void init() {
        // 在classes路径下读取敏感词文件（需要先编译），获得字节流
        try (
                InputStream is = this.getClass().getClassLoader().getResourceAsStream(&amp;quot;sensitive-words.txt&amp;quot;);
                // 转为字符流，在转为缓冲流(效率会更高)
                BufferedReader reader = new BufferedReader(new InputStreamReader(is));
        ) {
            String keyword;
            while ((keyword = reader.readLine()) != null) {
                // 添加到前缀树中，这一步比较复杂，封装为一个方法
                this.addKeyword(keyword);
            }
        } catch (IOException e) {
            logger.error(&amp;quot;加载敏感词文件失败 : &amp;quot; + e.getMessage());
        }
    }

    // 将一个敏感词添加到前缀树中
    private void addKeyword(String keyword) {
        // 指针
        TrieNode tempNode = rootNode;
        for (int i = 0; i &amp;lt; keyword.length(); i++) {
            char c = keyword.charAt(i);
            TrieNode subNode = tempNode.getSubNode(c);
            if (subNode == null) {
                // 初始化子节点
                subNode = new TrieNode();
                tempNode.addSubNode(c, subNode);
            }

            // 让指针指向该子节点，进入下一轮循环
            tempNode = subNode;

            // 设置结束标识(到此为一个敏感词)
            if (i == keyword.length() - 1) {
                tempNode.setKeywordEnd(true);
            }
        }
    }


    /**
     * 过滤敏感词
     *
     * @param text 待过滤的文本
     * @return 过滤后的文本
     */
    public String filter(String text) {
        if (StringUtils.isBlank(text)) {
            return null;
        }

        // 指针1，指向前缀树
        TrieNode tempNode = rootNode;
        // 指针2，字符串指针
        int begin = 0;
        // 指针3，字符串指针
        int position = 0;
        // 记录生成的新字符串，使用可变长字符串
        StringBuilder sb = new StringBuilder();

        // 开始过滤
        while (position &amp;lt; text.length()) {
            char c = text.charAt(position);

            // 跳过符号，防止有的用户通过在敏感词中穿插各种符号来规避敏感词检测
            if (isSymbol(c)) {
                // 若指针1处于根节点，将此符号记入结果，让指针2向下走一步
                if (tempNode == rootNode) {
                    sb.append(c);
                    begin++;
                }
                // 无论符号在开头或中间，指针3都向下走一步
                position++;
                continue;
            }

            // 检查下级节点
            tempNode = tempNode.getSubNode(c);
            if (tempNode == null) {
                // 以begin为开头的字符串不是敏感词
                sb.append(text.charAt(begin));
                // 进入下一个位置
                position = ++begin;
                // 重新指向根节点
                tempNode = rootNode;
            } else if (tempNode.isKeywordEnd()) {
                // 发现了敏感词，将begin到position这段的字符串替换掉
                sb.append(REPLACEMENT);
                // 进入下一个位置
                begin = ++position;
                // 重新指向根节点
                tempNode = rootNode;
            } else {
                // 检查下一个字符
                position++;
            }
        }

        // 将最后一批字符计入结果
        sb.append(text.substring(begin));

        // 返回结果
        return sb.toString();
    }

    // 判断是否为符号
    private boolean isSymbol(Character c) {
        // 不是特殊符号，0x2E80到0x9FFF是东亚的文字范围
        return !CharUtils.isAsciiAlphanumeric(c) &amp;amp;&amp;amp; (c &amp;lt; 0x2E80 || c &amp;gt; 0x9FFF);
    }


    // 前缀树
    private class TrieNode {

        // 关键词结束标识
        private boolean isKeywordEnd = false;

        // 子节点(key是下级字符，value是下级节点)
        private Map&amp;lt;Character, TrieNode&amp;gt; subNodes = new HashMap&amp;lt;&amp;gt;();

        public boolean isKeywordEnd() {
            return isKeywordEnd;
        }

        public void setKeywordEnd(boolean keywordEnd) {
            isKeywordEnd = keywordEnd;
        }

        // 添加子节点
        public void addSubNode(Character c, TrieNode node) {
            subNodes.put(c, node);
        }

        //  获取子节点
        public TrieNode getSubNode(Character c) {
            return subNodes.get(c);
        }

    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Step3 过滤测试&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootTest
@ContextConfiguration(classes = CommunityApplication.class)
public class SensitiveTests {

    @Autowired
    private SensitiveFilter sensitiveFilter;

    @Test
    public void testSensitiveFilter(){
        String text = &amp;quot;我是敏感词，你来过滤我啊，测试VPN，测试翻墙，测试吸毒，测试开票，哈哈哈！&amp;quot;;
        System.out.println(sensitiveFilter.filter(text));

        text = &amp;quot;我是敏感词，你来过滤我啊，测试☆V☆P☆☆N☆，测试☆☆翻☆☆☆墙☆☆,☆测试☆吸☆☆毒☆☆☆，测试☆开☆☆票☆，哈哈哈！&amp;quot;;
        System.out.println(sensitiveFilter.filter(text));
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;我是敏感词，你来过滤我啊，测试***，测试***，测试***，测试***，哈哈哈！
我是敏感词，你来过滤我啊，测试☆***☆，测试☆☆***☆☆,☆测试☆***☆☆☆，测试☆***☆，哈哈哈！
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>常用的元注解</title>
      <link>https://halklein.github.io/2020/025/</link>
      <pubDate>Mon, 20 Jan 2020 20:35:11 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2020/025/</guid>
      <description>

&lt;h2 id=&#34;常用的元注解&#34;&gt;常用的元注解&lt;/h2&gt;

&lt;p&gt;当我们需要自定义注解时，要用到元注解定义我们自己的注解（所谓元注解，就是注解其它注解的注解），其中常见的元注解有以下四个：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;@Target&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;由于标识我们自定义注解的使用范围。从源码可以看到可以赋值为ElementType。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package java.lang.annotation;

@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.ANNOTATION_TYPE})
public @interface Target {
    ElementType[] value();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中ElementType定义如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public enum ElementType {
    TYPE,	// 类、接口、枚举类
    FIELD,	// 成员变量（包括：枚举常量）
    METHOD,	// 成员方法
    PARAMETER,	// 方法参数
    CONSTRUCTOR, 	// 构造方法
    LOCAL_VARIABLE,	// 局部变量
    ANNOTATION_TYPE,	// 注解类
    PACKAGE,	// 包
    TYPE_PARAMETER,	// 类型参数，JDK 1.8 新增
    TYPE_USE,	// 使用类型的任何地方，JDK 1.8 新增
    MODULE;	// 允许在模块上使用注解，JDK 1.9新增

    private ElementType() {
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@Retention&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用于说明自定义注解的有效时间或者说保留的时间（如：编译时有效、运行时有效等）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package java.lang.annotation;

@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.ANNOTATION_TYPE})
public @interface Retention {
    RetentionPolicy value();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;package java.lang.annotation;

public enum RetentionPolicy {
    SOURCE,	//源文件
    CLASS,	//编译时（默认）
    RUNTIME;	//运行时

    private RetentionPolicy() {
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@Document&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;声明在生成帮助文档的时候要不要把这个自定义注解信息也带上。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package java.lang.annotation;

@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.ANNOTATION_TYPE})
public @interface Documented {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@Inherited&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使被它修饰的自定义注解具有继承性。子类继承该自定义注解之后也具有该注解。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package java.lang.annotation;

@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.ANNOTATION_TYPE})
public @interface Inherited {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;PS&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一般来说，我们自定义注解，@Target和@Retention是都会用到的，用来指定作用的范围和时机&lt;/p&gt;

&lt;h2 id=&#34;如何读取注解&#34;&gt;如何读取注解&lt;/h2&gt;

&lt;p&gt;通过AnnotatedElement接口实现对自定义注解的解析&lt;/p&gt;

&lt;p&gt;Method.getDeclaredAnnotations（）
Method.getAnnotation（Class&lt;T&gt; annotationClass）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;看个例子：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;@Override
public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
    // 如果拦截到的是一个方法 : instanceof HandlerMethod
    if (handler instanceof HandlerMethod) {
        // 转型，方便获取内容
        HandlerMethod handlerMethod = (HandlerMethod) handler;
        Method method = handlerMethod.getMethod();
        // 取注解，取含有自定义注解：LoginRequired，的方法
        LoginRequired loginRequired = method.getAnnotation(LoginRequired.class);
        // 取注解后发现不为空，说明该方法需要登录才能访问，并且检测不到当前用户
        if (loginRequired != null &amp;amp;&amp;amp; hostHolder.getUser() == null) {
            // 使用response重定向到登录页
            response.sendRedirect(request.getContextPath() + &amp;quot;/login&amp;quot;);
            // 拒绝后续访问
            return false;
        }
    }
    return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>记第一次住院</title>
      <link>https://halklein.github.io/2020/024/</link>
      <pubDate>Fri, 03 Jan 2020 15:18:12 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2020/024/</guid>
      <description>&lt;p&gt;2020年元旦&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·No End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Web项目的一些调试技巧</title>
      <link>https://halklein.github.io/2019/023/</link>
      <pubDate>Sat, 28 Dec 2019 20:14:16 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/023/</guid>
      <description>

&lt;h2 id=&#34;1-响应状态码的含义&#34;&gt;1. 响应状态码的含义&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;200 OK&lt;/code&gt;，表明请求已经成功. 默认情况下状态码为200的响应可以被缓存。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;302 Found&lt;/code&gt;，重定向，服务器发送 &lt;code&gt;302&lt;/code&gt; 状态码和一个新的 &lt;code&gt;url&lt;/code&gt; 让浏览器再发一次新的请求，实现功能的跳转。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;404 Not Found&lt;/code&gt;，往往是路径配置有误。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;500 Internal Server Error&lt;/code&gt;，服务器接受到了请求，但是在处理的过程中发生了问题。&lt;/p&gt;

&lt;p&gt;详细信息请参考：&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-服务端断点调试技巧&#34;&gt;2. 服务端断点调试技巧&lt;/h2&gt;

&lt;p&gt;在IDEA中，打上断点后，需要以 Debug 方式运行程序。&lt;/p&gt;

&lt;p&gt;按 &lt;code&gt;F8&lt;/code&gt; 可以执行下一行&lt;/p&gt;

&lt;p&gt;按 &lt;code&gt;F7&lt;/code&gt; 可以进入到当前行执行的方法内部，查看更详细的调试信息&lt;/p&gt;

&lt;p&gt;按 &lt;code&gt;F9&lt;/code&gt; 可以一直向下执行直到遇到下一个断点处，注意在调试期间也可以在之后的程序代码中继续打断点，用于跳过一些繁杂的循环或者确定正确的程序段。&lt;/p&gt;

&lt;p&gt;有些信息可能是以Hash值显示，这时可以在下方调试框中展开看信息信息：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/28/ZM548VEUdLiYyaW.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果断点太多，你还可以批量管理断点：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/28/jRGKmuvIPdsegJk.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;3-客户端断点调试技巧&#34;&gt;3. 客户端断点调试技巧&lt;/h2&gt;

&lt;p&gt;这里主要是指对 JS 的调试。以Chrome浏览器为例，调出如下页面，&lt;code&gt;F10&lt;/code&gt;进入下一条语句，&lt;code&gt;F11&lt;/code&gt;进入当前语句，&lt;code&gt;F8&lt;/code&gt;到下一个断点或执行到底。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/28/hBezrIyuPVgJNUb.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;4-设置日志级别-并将日志输出到不同的终端&#34;&gt;4. 设置日志级别，并将日志输出到不同的终端&lt;/h2&gt;

&lt;p&gt;Spring boot内置默认的日志工具 &lt;a href=&#34;https://logback.qos.ch&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Logback&lt;/a&gt; ，&lt;a href=&#34;http://logback.qos.ch/manual/index.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;参考手册&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package org.slf4j; 
public interface Logger {
  // 日志级别，从低到高，等于或高于设定级别的日志将会在控制台输出
  public void trace(String message);
  public void debug(String message);
  public void info(String message); 
  public void warn(String message); 
  public void error(String message); 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;logger日志级别被Spring Boot整合后，可直接在 application.properties 文件中配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;# 配置logger日志级别，以便查看sql语句带来的错误等，方便查错
logging.level.me.leihao.community = debug
# 项目上线后是没有控制台的，我们可以将日志打印到文件里
logging.file.name = E:/Test/community.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在实际的项目开发中，日志文件是非常重要的，我们的设置会更复杂一些，会将不同级别的日志分成不同的文件，对单个文件如果太大也会进行拆分。&lt;/p&gt;

&lt;p&gt;首先，先注释掉 application.properties 文件中配置的 logger 日志&lt;/p&gt;

&lt;p&gt;然后，在 resources 目录下引入名为 &lt;code&gt;logback-spring.xml&lt;/code&gt; 的配置文件（注意命名是Spring规定的，不要乱改）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;configuration&amp;gt;
    &amp;lt;!--你的项目名--&amp;gt;
    &amp;lt;contextName&amp;gt;community&amp;lt;/contextName&amp;gt;
    &amp;lt;!--日志存储路径--&amp;gt;
    &amp;lt;property name=&amp;quot;LOG_PATH&amp;quot; value=&amp;quot;E:/Test/log&amp;quot;/&amp;gt;
    &amp;lt;!--子级目录，以区分不同项目--&amp;gt;
    &amp;lt;property name=&amp;quot;APPDIR&amp;quot; value=&amp;quot;community&amp;quot;/&amp;gt;

    &amp;lt;!-- error file --&amp;gt;
    &amp;lt;appender name=&amp;quot;FILE_ERROR&amp;quot; class=&amp;quot;ch.qos.logback.core.rolling.RollingFileAppender&amp;quot;&amp;gt;
        &amp;lt;!--分块规则--&amp;gt;
        &amp;lt;file&amp;gt;${LOG_PATH}/${APPDIR}/log_error.log&amp;lt;/file&amp;gt;
        &amp;lt;rollingPolicy class=&amp;quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&amp;quot;&amp;gt;
            &amp;lt;fileNamePattern&amp;gt;${LOG_PATH}/${APPDIR}/error/log-error-%d{yyyy-MM-dd}.%i.log&amp;lt;/fileNamePattern&amp;gt;
            &amp;lt;timeBasedFileNamingAndTriggeringPolicy class=&amp;quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&amp;quot;&amp;gt;
                &amp;lt;!--单个日志大小--&amp;gt;
                &amp;lt;maxFileSize&amp;gt;5MB&amp;lt;/maxFileSize&amp;gt;
            &amp;lt;/timeBasedFileNamingAndTriggeringPolicy&amp;gt;
            &amp;lt;!--日志最长保留时间--&amp;gt;
            &amp;lt;maxHistory&amp;gt;30&amp;lt;/maxHistory&amp;gt;
        &amp;lt;/rollingPolicy&amp;gt;
        &amp;lt;!--以追加方式存储日志--&amp;gt;
        &amp;lt;append&amp;gt;true&amp;lt;/append&amp;gt;
        &amp;lt;encoder class=&amp;quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&amp;quot;&amp;gt;
            &amp;lt;!--日志输出格式：日期、级别、线程、类、文件和行、提示--&amp;gt;
            &amp;lt;pattern&amp;gt;%d %level [%thread] %logger{10} [%file:%line] %msg%n&amp;lt;/pattern&amp;gt;
            &amp;lt;!--字符集--&amp;gt;
            &amp;lt;charset&amp;gt;utf-8&amp;lt;/charset&amp;gt;
        &amp;lt;/encoder&amp;gt;
        &amp;lt;filter class=&amp;quot;ch.qos.logback.classic.filter.LevelFilter&amp;quot;&amp;gt;
            &amp;lt;!--日志级别--&amp;gt;
            &amp;lt;level&amp;gt;error&amp;lt;/level&amp;gt;
            &amp;lt;onMatch&amp;gt;ACCEPT&amp;lt;/onMatch&amp;gt;
            &amp;lt;onMismatch&amp;gt;DENY&amp;lt;/onMismatch&amp;gt;
        &amp;lt;/filter&amp;gt;
    &amp;lt;/appender&amp;gt;

    &amp;lt;!-- warn file --&amp;gt;
    &amp;lt;appender name=&amp;quot;FILE_WARN&amp;quot; class=&amp;quot;ch.qos.logback.core.rolling.RollingFileAppender&amp;quot;&amp;gt;
        &amp;lt;file&amp;gt;${LOG_PATH}/${APPDIR}/log_warn.log&amp;lt;/file&amp;gt;
        &amp;lt;rollingPolicy class=&amp;quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&amp;quot;&amp;gt;
            &amp;lt;fileNamePattern&amp;gt;${LOG_PATH}/${APPDIR}/warn/log-warn-%d{yyyy-MM-dd}.%i.log&amp;lt;/fileNamePattern&amp;gt;
            &amp;lt;timeBasedFileNamingAndTriggeringPolicy class=&amp;quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&amp;quot;&amp;gt;
                &amp;lt;maxFileSize&amp;gt;5MB&amp;lt;/maxFileSize&amp;gt;
            &amp;lt;/timeBasedFileNamingAndTriggeringPolicy&amp;gt;
            &amp;lt;maxHistory&amp;gt;30&amp;lt;/maxHistory&amp;gt;
        &amp;lt;/rollingPolicy&amp;gt;
        &amp;lt;append&amp;gt;true&amp;lt;/append&amp;gt;
        &amp;lt;encoder class=&amp;quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&amp;quot;&amp;gt;
            &amp;lt;pattern&amp;gt;%d %level [%thread] %logger{10} [%file:%line] %msg%n&amp;lt;/pattern&amp;gt;
            &amp;lt;charset&amp;gt;utf-8&amp;lt;/charset&amp;gt;
        &amp;lt;/encoder&amp;gt;
        &amp;lt;filter class=&amp;quot;ch.qos.logback.classic.filter.LevelFilter&amp;quot;&amp;gt;
            &amp;lt;level&amp;gt;warn&amp;lt;/level&amp;gt;
            &amp;lt;onMatch&amp;gt;ACCEPT&amp;lt;/onMatch&amp;gt;
            &amp;lt;onMismatch&amp;gt;DENY&amp;lt;/onMismatch&amp;gt;
        &amp;lt;/filter&amp;gt;
    &amp;lt;/appender&amp;gt;

    &amp;lt;!-- info file --&amp;gt;
    &amp;lt;appender name=&amp;quot;FILE_INFO&amp;quot; class=&amp;quot;ch.qos.logback.core.rolling.RollingFileAppender&amp;quot;&amp;gt;
        &amp;lt;file&amp;gt;${LOG_PATH}/${APPDIR}/log_info.log&amp;lt;/file&amp;gt;
        &amp;lt;rollingPolicy class=&amp;quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&amp;quot;&amp;gt;
            &amp;lt;fileNamePattern&amp;gt;${LOG_PATH}/${APPDIR}/info/log-info-%d{yyyy-MM-dd}.%i.log&amp;lt;/fileNamePattern&amp;gt;
            &amp;lt;timeBasedFileNamingAndTriggeringPolicy class=&amp;quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&amp;quot;&amp;gt;
                &amp;lt;maxFileSize&amp;gt;5MB&amp;lt;/maxFileSize&amp;gt;
            &amp;lt;/timeBasedFileNamingAndTriggeringPolicy&amp;gt;
            &amp;lt;maxHistory&amp;gt;30&amp;lt;/maxHistory&amp;gt;
        &amp;lt;/rollingPolicy&amp;gt;
        &amp;lt;append&amp;gt;true&amp;lt;/append&amp;gt;
        &amp;lt;encoder class=&amp;quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&amp;quot;&amp;gt;
            &amp;lt;pattern&amp;gt;%d %level [%thread] %logger{10} [%file:%line] %msg%n&amp;lt;/pattern&amp;gt;
            &amp;lt;charset&amp;gt;utf-8&amp;lt;/charset&amp;gt;
        &amp;lt;/encoder&amp;gt;
        &amp;lt;filter class=&amp;quot;ch.qos.logback.classic.filter.LevelFilter&amp;quot;&amp;gt;
            &amp;lt;level&amp;gt;info&amp;lt;/level&amp;gt;
            &amp;lt;onMatch&amp;gt;ACCEPT&amp;lt;/onMatch&amp;gt;
            &amp;lt;onMismatch&amp;gt;DENY&amp;lt;/onMismatch&amp;gt;
        &amp;lt;/filter&amp;gt;
    &amp;lt;/appender&amp;gt;

    &amp;lt;!-- console 打印到控制台 --&amp;gt;
    &amp;lt;appender name=&amp;quot;STDOUT&amp;quot; class=&amp;quot;ch.qos.logback.core.ConsoleAppender&amp;quot;&amp;gt;
        &amp;lt;encoder&amp;gt;
            &amp;lt;pattern&amp;gt;%d %level [%thread] %logger{10} [%file:%line] %msg%n&amp;lt;/pattern&amp;gt;
            &amp;lt;charset&amp;gt;utf-8&amp;lt;/charset&amp;gt;
        &amp;lt;/encoder&amp;gt;
        &amp;lt;filter class=&amp;quot;ch.qos.logback.classic.filter.ThresholdFilter&amp;quot;&amp;gt;
            &amp;lt;!--控制台日志级别--&amp;gt;
            &amp;lt;level&amp;gt;debug&amp;lt;/level&amp;gt;
        &amp;lt;/filter&amp;gt;
    &amp;lt;/appender&amp;gt;

    &amp;lt;!--对某个包日志级别的单独声明--&amp;gt;
    &amp;lt;logger name=&amp;quot;me.leihao.community&amp;quot; level=&amp;quot;debug&amp;quot;/&amp;gt;

    &amp;lt;root level=&amp;quot;info&amp;quot;&amp;gt;
        &amp;lt;appender-ref ref=&amp;quot;FILE_ERROR&amp;quot;/&amp;gt;
        &amp;lt;appender-ref ref=&amp;quot;FILE_WARN&amp;quot;/&amp;gt;
        &amp;lt;appender-ref ref=&amp;quot;FILE_INFO&amp;quot;/&amp;gt;
        &amp;lt;appender-ref ref=&amp;quot;STDOUT&amp;quot;/&amp;gt;
    &amp;lt;/root&amp;gt;

&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>用 iTerm2 美化你的 Mac终端</title>
      <link>https://halklein.github.io/2019/022/</link>
      <pubDate>Wed, 25 Dec 2019 11:38:03 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/022/</guid>
      <description>

&lt;h2 id=&#34;先看看效果图&#34;&gt;先看看效果图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/25/bAyehHXWCwkLPSR.png&#34; alt=&#34;效果图&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;安装-iterm2&#34;&gt;安装 iTerm2&lt;/h2&gt;

&lt;p&gt;下载安装 &lt;a href=&#34;https://www.iterm2.com/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;iterm2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://iterm2.com/downloads/stable/latest&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://iterm2.com/downloads/stable/latest&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;安装 &lt;a href=&#34;https://ohmyz.sh/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;oh-my-zsh&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;sh -c &amp;quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;p&gt;sh -c &amp;ldquo;$(wget &lt;a href=&#34;https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh&lt;/a&gt; -O -)&amp;rdquo;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;若需要Homebrew，执行下面命令安装&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/usr/bin/ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;wget的安装&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;brew install wget
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如需科学上网：&lt;a href=&#34;https://www.noxxxx.com/mac-下终端走-ss-代理.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;参考&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在终端中直接运行命令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;export http_proxy=http://proxyAddress:port
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个办法的好处是简单直接，并且影响面很小（只对当前终端有效，退出就不行了）。&lt;/p&gt;

&lt;p&gt;如果你用的是ss代理，在当前终端运行以下命令，那么&lt;code&gt;wget&lt;/code&gt; &lt;code&gt;curl&lt;/code&gt; 这类网络命令都会经过ss代理&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;export ALL_PROXY=socks5://127.0.0.1:1080
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;下载配色方案&#34;&gt;下载配色方案&lt;/h2&gt;

&lt;p&gt;你可以在 &lt;a href=&#34;https://iterm2colorschemes.com/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;这里&lt;/a&gt; 查看配色方案。（这里我选择 &lt;strong&gt;Tomorrow Night Eighties&lt;/strong&gt;）&lt;/p&gt;

&lt;p&gt;然后到 &lt;a href=&#34;https://github.com/mbadolato/iTerm2-Color-Schemes&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;这里&lt;/a&gt; 下载 iterm2 的配色方案&lt;/p&gt;

&lt;p&gt;下载好之后，在iTerm2首选项中导入配色方案：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/25/b73i1KHnfIRov8N.png&#34; alt=&#34;首选项&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/25/BTOsYSQXWUZhHV3.png&#34; alt=&#34;选择配色文件&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;更换-zsh-默认的主题&#34;&gt;更换 zsh 默认的主题&lt;/h2&gt;

&lt;p&gt;我使用的主题是&lt;a href=&#34;https://github.com/Powerlevel9k/powerlevel9k/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;powerlevel9k&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;git clone https://github.com/bhilburn/powerlevel9k.git ~/.oh-my-zsh/custom/themes/powerlevel9k
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑配置文件 &lt;code&gt;vi ~/.zshrc&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;ZSH_THEME=&amp;quot;powerlevel9k/powerlevel9k&amp;quot;
# 命令左侧显示内容（当前目录 git 版本信息）
POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(context dir vcs)
# 命令右侧显示内容（命令运行状态，剩余内存，时间，cpu负载，剩余电量）
POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(status ram time load battery)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后运行 &lt;code&gt;source ~/.zshrc&lt;/code&gt; 命令，让其生效。&lt;/p&gt;

&lt;h2 id=&#34;更换字体&#34;&gt;更换字体&lt;/h2&gt;

&lt;p&gt;直接使用 &lt;code&gt;powerlevel9k&lt;/code&gt; 主题的话，因为默认字体不支持 icon，会出现一些乱码。&lt;/p&gt;

&lt;p&gt;因为 &lt;code&gt;powerlevel9k&lt;/code&gt; 中用到了大量的 icon，但是只有部分的字体支持 icon。目前对 icon 的支持得比较好的字体是 &lt;a href=&#34;https://www.nerdfonts.com/#home&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Nerd Font&lt;/a&gt;。brew 提供了 nerd 字体的安装。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;$ brew tap homebrew/cask-fonts
$ brew search nerd
==&amp;gt; Formulae
container-diff
==&amp;gt; Casks
font-3270-nerd-font
...
# 选择Nerd Font字体进行安装
$ brew cask install font-sourcecodepro-nerd-font
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装字体成功后，就可以在 iterm2 中设置了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/25/LqtHU8Z95oBdiFD.png&#34; alt=&#34;更改字体&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;插件&#34;&gt;插件&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;oh-my-zsh&lt;/code&gt; 有很多好用的插件，安装好的插件需要在 &lt;code&gt;~/.zshrc&lt;/code&gt; 中的 &lt;code&gt;plugins=(git autojump cp extract sudo z zsh-syntax-highlighting zsh-autosuggestions)&lt;/code&gt; 依次写入配置，用空格分开。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;autojump&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;记忆我们之前去过的目录，不需要多次 &lt;code&gt;cd&lt;/code&gt; ，直接 &lt;code&gt;j 目录名&lt;/code&gt; 就可以直接进入。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#安装
brew install autojump

#在 ~/.zshrc 中加入如下配置
[[ -s $(brew --prefix)/etc/profile.d/autojump.sh ]] &amp;amp;&amp;amp; . $(brew --prefix)/etc/profile.d/autojump.sh
source $ZSH/oh-my-zsh.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;zsh-autosuggestion&#34;&gt;&lt;strong&gt;zsh-autosuggestion&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;输入命令提示自动补全，然后按键盘 &lt;code&gt;→&lt;/code&gt; 即可补全&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#安装
$ git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;zsh-syntax-highlighting&#34;&gt;&lt;strong&gt;zsh-syntax-highlighting&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;命令高亮显示，错误显示红色&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;# 安装
$ git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;colorls&#34;&gt;&lt;strong&gt;colorls&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;显示文件图标&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;# 安装
sudo gem install colorls 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>关于数据库索引的一些问题</title>
      <link>https://halklein.github.io/2019/021/</link>
      <pubDate>Tue, 24 Dec 2019 21:22:50 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/021/</guid>
      <description>

&lt;h2 id=&#34;一-密集索引和稀疏索引&#34;&gt;一、密集索引和稀疏索引&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;密集索引文件中的每个搜索码值都对应一个索引值&lt;/li&gt;
&lt;li&gt;稀疏索引文件只为索引码的某些值建立索引项&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/24/qtGm8r27hMxLDwV.png&#34; alt=&#34;密集索引和稀疏索引&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MySQL常见的数据库引擎：MyISAM只使用稀疏索引，InnoDB有且仅有一个密集索引&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;若一个主键被定义，该主键则作为密集索引&lt;/li&gt;
&lt;li&gt;若没有主键被定义，该表的第一个唯一非空索引则作为密集索引&lt;/li&gt;
&lt;li&gt;若不满足以上条件，innodb内部会生成一个隐藏主键（密集索引）&lt;/li&gt;
&lt;li&gt;非主键索引存储相关键位和其对应的主键值，包含两次查找&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;二-如何定位并优化慢查询sql&#34;&gt;二、如何定位并优化慢查询Sql&lt;/h2&gt;

&lt;p&gt;具体场景要具体分析，大致思路如下：
- 根据慢日志定位慢查询sql
- 使用explain等工具分析sql
- 修改sql或者尽量让sql走索引&lt;/p&gt;

&lt;h3 id=&#34;2-1-根据慢日志定位慢查询sql&#34;&gt;2.1 根据慢日志定位慢查询sql&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;# 查看数据库慢日志配置
mysql&amp;gt; show variables like &amp;quot;%quer%&amp;quot;;

# 查看慢日志数量
mysql&amp;gt; show status like &amp;quot;%slow_queries%&amp;quot;;

# 打开慢日志开关
mysql&amp;gt; set global slow_query_log = on;

# 设置慢日志记录阈值为1s，10s可以说是很慢很慢了，不具有参考价值
# 修改后可能需要重新连接数据库才能看到效果
# 另外，这样的设置在重启MySQL服务之后将会失效！如果要永久生效,需修改my.ini配置文件（Mac OS是my.cnf）
mysql&amp;gt; set global long_query_time = 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/24/NFSpx65OUvuqQhD.png&#34; alt=&#34;查看数据库慢日志配置&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-2-使用explain等工具分析sql&#34;&gt;2.2 使用explain等工具分析sql&lt;/h3&gt;

&lt;p&gt;只需在查询语句前加上 &lt;code&gt;explain&lt;/code&gt; 即可，如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;mysql&amp;gt; explain select ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-3-修改sql或者尽量让sql走索引&#34;&gt;2.3 修改sql或者尽量让sql走索引&lt;/h3&gt;

&lt;h2 id=&#34;三-联合索引的最左匹配原则的成因&#34;&gt;三、联合索引的最左匹配原则的成因&lt;/h2&gt;

&lt;h2 id=&#34;四-索引是建立得越多越好吗&#34;&gt;四、索引是建立得越多越好吗&lt;/h2&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>数据库索引之 B&#43; Tree、Hash、BitMap</title>
      <link>https://halklein.github.io/2019/020/</link>
      <pubDate>Tue, 24 Dec 2019 19:54:38 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/020/</guid>
      <description>

&lt;h2 id=&#34;b-tree&#34;&gt;B+ Tree&lt;/h2&gt;

&lt;p&gt;由于，二叉查看树在插入修改过程中，很可能出现只有左右子树的情况，虽然可以用平衡调整二叉树，但是每次IO依然很费时间，每访问一层就要对磁盘进行IO，总体来说二叉树还不够优。由此找到了更好的替代方法-B树，又由于B+ Tree具有更好的特性，所以B+ Tree就成了常见的索引结构之一。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/24/xkZWtEguQIAoRXK.png&#34; alt=&#34;B+ Tree&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;B+ Tree相对于B树，具有的新特点：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;非叶子节点的子树指针与关键字个数相同&lt;/li&gt;
&lt;li&gt;非叶子节点的子树指针P[]，指向关键字值（[Ki]，K[i+1]）的子树&lt;/li&gt;
&lt;li&gt;非叶子节点仅用来索引，数据都保存在叶子节点中&lt;/li&gt;
&lt;li&gt;所有叶子节点均有一个链指针指向下一个叶子结点&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;hash&#34;&gt;Hash&lt;/h2&gt;

&lt;p&gt;通过Hash索引，能够通过Hash函数快速定位到索引目标，理论上比B+ Tree更快。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/24/hci2ueoaKS4klxf.png&#34; alt=&#34;Hash索引&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;但是Hash索引也有也有严重的缺陷：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;仅仅能满足“=&amp;ldquo;，“IN&amp;rdquo;，不能使用范围查询&lt;/li&gt;
&lt;li&gt;无法被用来避免数据的排序操作&lt;/li&gt;
&lt;li&gt;不能利用部分索引键查询&lt;/li&gt;
&lt;li&gt;不能避免表扫描&lt;/li&gt;
&lt;li&gt;遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，索引没有最优，只有更适合某种情况的索引结构，他们常常组合使用。&lt;/p&gt;

&lt;h2 id=&#34;bitmap&#34;&gt;BitMap&lt;/h2&gt;

&lt;p&gt;位图索引，适用于某个字段的值只有固定的几种为了实现高效的统计的情况，如性别（男、女）。不过支持位图索引的数据库比较少，典型的有Oracle数据库。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/24/4uxK3ZdCTknmj9w.png&#34; alt=&#34;BitMap&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Socket 入门</title>
      <link>https://halklein.github.io/2019/011/</link>
      <pubDate>Tue, 05 Nov 2019 09:31:12 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/011/</guid>
      <description>

&lt;h2 id=&#34;进程间通信&#34;&gt;进程间通信&lt;/h2&gt;

&lt;p&gt;网络中进程进行通信的前提是每个进程都要有唯一的标识，在本地计算机中我们可以用PID来唯一标识一个进程，可以多个计算机处在网络中时，不同计算机的进程PID冲突的可能性就很大。怎么办呢？我们知道IP地址可以唯一标识主机，而TCP协议和端口号可以唯一标识主机的一个进程，这样我们就可以用 IP+协议+端口号 来唯一标识网络中的一个进程了。&lt;/p&gt;

&lt;p&gt;使用TCP/IP协议的应用程序通常采用应用编程接口：UNIX BSD的套接字（socket）和UNIX System V的TLI（已经被淘汰），来实现网络进程之间的通信。就目前而言，几乎所有的应用程序都是采用socket。&lt;/p&gt;

&lt;h2 id=&#34;什么是socket&#34;&gt;什么是Socket？&lt;/h2&gt;

&lt;p&gt;网络套接字（英语：Network socket；又译网络套接字、网络接口、网络插槽）在计算机科学中是电脑网络中行程间数据流的端点。使用以网际协议（Internet Protocol）为通信基础的网络套接字，称为网际套接字（Internet socket）。因为网际协议的流行，现代绝大多数的网络套接字，都是属于网际套接字。&lt;/p&gt;

&lt;p&gt;socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&amp;gt; 读写write/read –&amp;gt; 关闭close”模式来操作。我的理解就是Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/tl96CpP3Qv4fMEV.jpg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Socket与TCP/IP协议并没有必然的联系，Socket编程接口在设计的时候就希望能适应其它的网络协议，所以Socket的出现是为了我们更好地使用TCP/IP协议栈，是对TCP/IP协议的抽象，是操作系统对外开放的接口。&lt;/p&gt;

&lt;h2 id=&#34;socket通信流程&#34;&gt;socket通信流程&lt;/h2&gt;

&lt;p&gt;以使用TCP协议通讯的socket为例，其交互流程大概是这样子的&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/aJRALE8cFmZonkg.png&#34; alt=&#34;Socket通信流程&#34; /&gt;Socket通信流程&lt;/p&gt;

&lt;h2 id=&#34;实列&#34;&gt;实列&lt;/h2&gt;

&lt;h3 id=&#34;编写一个网络应用程序-包含客户端和服务端-客户端向服务端发送一个字符串-服务端收到字符串并打印到命令行同时向客户端返回字符串长度-最后客户端输出收到的字符串长度-分别用tcp和udp实现&#34;&gt;&lt;strong&gt;编写一个网络应用程序，包含客户端和服务端，客户端向服务端发送一个字符串，服务端收到字符串并打印到命令行同时向客户端返回字符串长度，最后客户端输出收到的字符串长度，分别用TCP和UDP实现。&lt;/strong&gt;&lt;/h3&gt;

&lt;h4 id=&#34;tcp方式&#34;&gt;TCP方式：&lt;/h4&gt;

&lt;p&gt;服务端&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TCPServer {
    public static void main(String[] args) throws Exception {
        //创建socket,并将socket绑定到65000端口
        ServerSocket ss = new ServerSocket(65000);
        //死循环，使得socket一直等待并处理客户端发送过来的请求
        while (true) {
            //监听65000端口，直到客户端返回连接信息后才返回
            Socket socket = ss.accept();
            //获取客户端的请求信息后，执行相关业务逻辑
            new LengthCalculator(socket).start();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;服务端业务逻辑&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class LengthCalculator extends Thread {
    //以socket为成员变量
    private Socket socket;
    public LengthCalculator(Socket socket) {
        this.socket = socket;
    }
    @Override
    public void run() {
        try {
            //获取socket的输出流
            OutputStream os = socket.getOutputStream();
            //获取socket的输入流
            InputStream is = socket.getInputStream();
            int ch = 0;
            byte[] buff = new byte[1024];
            //buff主要用来读取输入的内容，存成byte数组，ch主要用来获取读取数组的长度
            ch = is.read(buff);
            //将接收流的byte数组转换成字符串，这里获取的内容是客户端发送过来的字符串参数
            String content = new String(buff, 0, ch);
            System.out.println(content);
            //往输出流里写入获得的字符串的长度，回发给客户端
            os.write(String.valueOf(content.length()).getBytes());
            //不要忘记关闭输入输出流以及socket
            is.close();
            os.close();
            socket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;客户端&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TCPClient {
    public static void main(String[] args) throws Exception {
        //创建socket，并指定连接的是本机的端口号为65000的服务器socket
        Socket socket = new Socket(&amp;quot;127.0.0.1&amp;quot;, 65000);
        //获取输出流
        OutputStream os = socket.getOutputStream();
        //获取输入流
        InputStream is = socket.getInputStream();
        //将要传递给server的字符串参数转换成byte数组，并将数组写入到输出流中
        os.write(new String(&amp;quot;hello world&amp;quot;).getBytes());
        int ch = 0;
        byte[] buff = new byte[1024];
        //buff主要用来读取输入的内容，存成byte数组，ch主要用来获取读取数组的长度
        ch = is.read(buff);
        //将接收流的byte数组转换成字符串，这里是从服务端回发回来的字符串参数的长度
        String content = new String(buff, 0, ch);
        System.out.println(content);
        //不要忘记关闭输入输出流以及socket
        is.close();
        os.close();
        socket.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/Rg5GzaCweFlMtjL.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/iITvbCjR18d2HMY.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;UDP方式：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;服务端&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UDPServer {
    public static void main(String[] args) throws Exception {
        // 服务端接受客户端发送的数据报
        DatagramSocket socket = new DatagramSocket(65001); //监听的端口号
        byte[] buff = new byte[100]; //存储从客户端接受到的内容
        DatagramPacket packet = new DatagramPacket(buff, buff.length);
        //接受客户端发送过来的内容，并将内容封装进DatagramPacket对象中
        socket.receive(packet);
        byte[] data = packet.getData(); //从DatagramPacket对象中获取到真正存储的数据
        //将数据从二进制转换成字符串形式
        String content = new String(data, 0, packet.getLength());
        System.out.println(content);
        //将要发送给客户端的数据转换成二进制
        byte[] sendedContent = String.valueOf(content.length()).getBytes();
        // 服务端给客户端发送数据报
        //从DatagramPacket对象中获取到数据的来源地址与端口号
        DatagramPacket packetToClient = new DatagramPacket(sendedContent,
                sendedContent.length, packet.getAddress(), packet.getPort());
        socket.send(packetToClient); //发送数据给客户端
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;客户端&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UDPClient {
    public static void main(String[] args) throws Exception {
        // 客户端发数据报给服务端
        DatagramSocket socket = new DatagramSocket();
        // 要发送给服务端的数据
        byte[] buf = &amp;quot;Hello World&amp;quot;.getBytes();
        // 将IP地址封装成InetAddress对象
        InetAddress address = InetAddress.getByName(&amp;quot;127.0.0.1&amp;quot;);
        // 将要发送给服务端的数据封装成DatagramPacket对象 需要填写上ip地址与端口号
        DatagramPacket packet = new DatagramPacket(buf, buf.length, address,
                65001);
        // 发送数据给服务端
        socket.send(packet);
        // 客户端接受服务端发送过来的数据报
        byte[] data = new byte[100];
        // 创建DatagramPacket对象用来存储服务端发送过来的数据
        DatagramPacket receivedPacket = new DatagramPacket(data, data.length);
        // 将接受到的数据存储到DatagramPacket对象中
        socket.receive(receivedPacket);
        // 将服务器端发送过来的数据取出来并打印到控制台
        String content = new String(receivedPacket.getData(), 0,
                receivedPacket.getLength());
        System.out.println(content);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/RuBrkvAVp5aFTx3.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>HTTP 与 HTTPS</title>
      <link>https://halklein.github.io/2019/010/</link>
      <pubDate>Sun, 03 Nov 2019 15:52:12 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/010/</guid>
      <description>

&lt;h2 id=&#34;1-http协议&#34;&gt;1. HTTP协议&lt;/h2&gt;

&lt;p&gt;超文本传输协议（英语：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。 通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接 。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HTTP 协议构建于 TCP/IP 协议之上，是一个应用层协议，默认端口号是 80&lt;/li&gt;
&lt;li&gt;HTTP 是&lt;strong&gt;无连接无状态&lt;/strong&gt;的&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-版本&#34;&gt;2. 版本&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;HTTP/0.9&lt;/strong&gt; 已过时。只接受GET一种请求方法，没有在通讯中指定版本号，且不支持请求头。由于该版本不支持POST方法，因此客户端无法向服务器传递太多信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HTTP/1.0&lt;/strong&gt; 这是第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用，特别是在代理服务器中。[来源请求]&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HTTP/1.1&lt;/strong&gt; 持久连接被默认采用，并能很好地配合代理服务器工作。还支持以管道方式在同时发送多个请求，以便降低线路负载，提高传输速度。HTTP/1.1相较于HTTP/1.0协议的区别主要体现在：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;缓存处理&lt;/li&gt;
&lt;li&gt;带宽优化及网络连接的使用&lt;/li&gt;
&lt;li&gt;错误通知的管理&lt;/li&gt;
&lt;li&gt;消息在网络中的发送&lt;/li&gt;
&lt;li&gt;互联网地址的维护&lt;/li&gt;
&lt;li&gt;安全性及完整性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;HTTP/2&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当前版本，于2015年5月作为互联网标准正式发布。&lt;/p&gt;

&lt;p&gt;HTTP目前处于多个版本共存的情况，包括仍被广泛采用的HTTP１.0，主流是1.1（ 1.1 版的最大变化，就是引入 Keep-Alive， 简单说就是保持当前的TCP连接，避免了重新建立连接。 ）， HTTP/2 目前应用较少（主要是因为1.1基本能满足需求，还有升级成本问题）&lt;/p&gt;

&lt;h2 id=&#34;2-超文本传输协议http主要特点&#34;&gt;2. 超文本传输协议HTTP主要特点&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;支持B/S及C/S模式&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;简单快速&lt;/strong&gt; ：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;灵活：&lt;/strong&gt;HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无连接：&lt;/strong&gt;无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无状态：&lt;/strong&gt;HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;3-http请求结构&#34;&gt;3. HTTP请求结构&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/G4fT2BQZSq7U6jn.png&#34; alt=&#34;HTTP请求结构&#34; /&gt;HTTP请求结构&lt;/p&gt;

&lt;p&gt;HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;序号&lt;/th&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;请求指定的页面信息，并返回实体主体。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;HEAD&lt;/td&gt;
&lt;td&gt;类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;POST&lt;/td&gt;
&lt;td&gt;向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;PUT&lt;/td&gt;
&lt;td&gt;从客户端向服务器传送的数据取代指定的文档的内容。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;DELETE&lt;/td&gt;
&lt;td&gt;请求服务器删除指定的页面。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;CONNECT&lt;/td&gt;
&lt;td&gt;HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;OPTIONS&lt;/td&gt;
&lt;td&gt;允许客户端查看服务器的性能。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;TRACE&lt;/td&gt;
&lt;td&gt;回显服务器收到的请求，主要用于测试或诊断。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;PATCH&lt;/td&gt;
&lt;td&gt;是对 PUT 方法的补充，用来对已知资源进行局部更新 。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;请求头部用来设置HTTP请求的一些参数，如Host、User-Agen&lt;/p&gt;

&lt;p&gt;请求数据，表示要上传的数据，其和头部之间是是有空行的，且请求头部后面的空行是必须的（即使请求数据为空）。&lt;/p&gt;

&lt;h2 id=&#34;4-http响应结构&#34;&gt;4. HTTP响应结构&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/RoUCGZ16VKHb4hk.png&#34; alt=&#34;HTTP响应结构&#34; /&gt;HTTP响应结构&lt;/p&gt;

&lt;h3 id=&#34;状态码类别&#34;&gt;状态码类别&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;分类&lt;/th&gt;
&lt;th&gt;分类描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1**&lt;/td&gt;
&lt;td&gt;指示信息，表示服务器收到请求，需要请求者继续执行操作&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2**&lt;/td&gt;
&lt;td&gt;成功，操作被成功接收并处理&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3**&lt;/td&gt;
&lt;td&gt;重定向，需要进一步的操作以完成请求&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4**&lt;/td&gt;
&lt;td&gt;客户端错误，请求包含语法错误或无法完成请求&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5**&lt;/td&gt;
&lt;td&gt;服务器错误，服务器在处理请求的过程中发生了错误&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;常见状态码&#34;&gt;&lt;strong&gt;常见状态码&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;200 OK&lt;/code&gt; 客户端请求成功&lt;/li&gt;
&lt;li&gt;&lt;code&gt;301 Moved Permanently&lt;/code&gt; 请求永久重定向&lt;/li&gt;
&lt;li&gt;&lt;code&gt;302 Moved Temporarily&lt;/code&gt; 请求临时重定向&lt;/li&gt;
&lt;li&gt;&lt;code&gt;304 Not Modified&lt;/code&gt; 文件未修改，可以直接使用缓存的文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;400 Bad Request&lt;/code&gt; 由于客户端请求有语法错误，不能被服务器所理解。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;401 Unauthorized&lt;/code&gt; 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;403 Forbidden&lt;/code&gt; 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;404 Not Found&lt;/code&gt; 请求的资源不存在，例如，输入了错误的URL。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;500 Internal Server Error&lt;/code&gt; 服务器发生不可预期的错误，导致无法完成客户端的请求。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;503 Service Unavailable&lt;/code&gt; 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;详细的状态码，可以 &lt;a href=&#34;https://www.runoob.com/http/http-status-codes.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;在这里查看&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;5-http抓包分析&#34;&gt;5. HTTP抓包分析&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/azHYDUIAb4yJw6Q.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;双击第一条&lt;strong&gt;HTTP请求&lt;/strong&gt;，查看详细请求报文：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/JryvnTqcubGUMDS.png&#34; alt=&#34;HTTP请求&#34; /&gt;HTTP请求&lt;/p&gt;

&lt;p&gt;双击第二条&lt;strong&gt;HTTP响应&lt;/strong&gt;，查看详细响应报文：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/fjxp98r1Nign46K.png&#34; alt=&#34;HTTP响应&#34; /&gt;HTTP响应&lt;/p&gt;

&lt;h2 id=&#34;6-http请求-响应的步骤&#34;&gt;6. HTTP请求/响应的步骤&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;客户端连接到Web服务器，客户端（通常是浏览器）与Web服务器的端口（默认80）建立TCP套接字（ socket ）连接&lt;/li&gt;
&lt;li&gt;客户端发送HTTP请求&lt;/li&gt;
&lt;li&gt;服务器接受请求并返回HTTP响应&lt;/li&gt;
&lt;li&gt;释放连接TCP连接。若连接模式为close则服务器主动关闭TCP连接；若连接模式为Keep-Alive则该连接会保持一段时间，在该时间内可以继续接收请求。&lt;/li&gt;
&lt;li&gt;客户端浏览器解析HTML内容&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;7-一些问题&#34;&gt;7. 一些问题&lt;/h2&gt;

&lt;h3 id=&#34;7-1-在浏览器地址栏键入带有http请求的url-按下回车之后经历的流程&#34;&gt;7.1 在浏览器地址栏键入带有HTTP请求的URL，按下回车之后经历的流程？&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;DNS解析。浏览器会根据URL逐层（浏览器缓存 – 系统缓存 – 路由器缓存 – IPS服务器缓存 – 域名服务器缓存 – 顶级域名服务器缓存，找到即可返回不再需要查询后面的缓存）查询DNS缓存，解析URL中的域名对应的IP地址。&lt;/li&gt;
&lt;li&gt;TCP连接。根据IP地址和端口与服务器建立TCP连接（三次握手）。&lt;/li&gt;
&lt;li&gt;发送HTTP请求。建立连接后浏览器向服务器发出读取文件的HTTP请求。&lt;/li&gt;
&lt;li&gt;服务器处理请求并返回HTTP报文。&lt;/li&gt;
&lt;li&gt;浏览器解析渲染页面。&lt;/li&gt;
&lt;li&gt;连接结束。浏览器释放TCP连接。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;7-2-get请求和post请求的区别&#34;&gt;7.2 GET请求和POST请求的区别？&lt;/h3&gt;

&lt;p&gt;从三个层面来解答&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;1. Http报文层面：&lt;/strong&gt;GET将请求信息放在URL，POST放在报文体中（想获得请求详细必须请求报文，所以安全性较GET方式高一些，事实上要获得报文体中的请求信息也是很容易的‘Wireshark就可以查看’，因此安全性上两者并没有太多的区别，具体解决安全性的问题需要HTTPS）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/DQaeRE6JoPSrfYn.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;2. 数据库层面：&lt;/strong&gt;CET符合幂等性（多次操作获得结果一样）和安全性（不会改变数据库数据，GET做查询操作），POST都不符合。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;3. 其他层面：&lt;/strong&gt;GET可以被缓存、被存储，而POST不行。所以GET现在依然规范使用。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;7-3-cookie和session的区别&#34;&gt;7.3 Cookie和Session的区别？&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Cookie简介&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;是由服务器发给客户端的特殊信息，以文本的形式存放在客户端 客户端再次请求的时候，会把Cookie回发 服务器接收到后，会解析Cookie生成与客户端相对应的内容&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Cookie的设置以及发送过程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/2hP1culNRmJwZej.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;客户端发送一个http请求到服务器端&lt;/li&gt;
&lt;li&gt;服务器端发送一个http响应到客户端，其中包含Set-Cookie头部&lt;/li&gt;
&lt;li&gt;客户端发送一个http请求到服务器端，其中包含Cookie头部&lt;/li&gt;
&lt;li&gt;服务器端发送一个http响应到客户端&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Session简介&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;服务器端的机制，在服务器上保存的信息 解析客户端请求并操作session id，按需保存状态信息&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Session的实现方式&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用Cookie来实现&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/nGwOtgZTQxP8lCU.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用URL回写来实现。服务器在发送给浏览器的所有连接中都携带JSESSIONID的参数，这样客户端点击任何一个路径都会带回JSESSIONID。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;二者的区别：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Cookie数据存放在客户的浏览器上，Session数据放在服务器上&lt;/li&gt;
&lt;li&gt;Session相对于Cookie更安全&lt;/li&gt;
&lt;li&gt;若考虑减轻服务器负担，应当使用Cookie&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;7-4-http和https的区别&#34;&gt;7.4 HTTP和HTTPS的区别？&lt;/h2&gt;

&lt;h3 id=&#34;https简介&#34;&gt;HTTPS简介&lt;/h3&gt;

&lt;p&gt;超文本传输安全协议（英语：HyperText Transfer Protocol Secure，缩写：HTTPS；常称为HTTP over TLS、HTTP over SSL或HTTP Secure）是一种通过计算机网络进行安全通信的传输协议。是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。&lt;/p&gt;

&lt;h3 id=&#34;ssl&#34;&gt;SSL&lt;/h3&gt;

&lt;p&gt;SSL（Security Sockets Layer，安全套接层）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;为网络通信提供安全及数据完整性的一种安全协议&lt;/li&gt;
&lt;li&gt;是操作系统对外的API，SSL3.0后更名为TLS&lt;/li&gt;
&lt;li&gt;采用身份验证和数据加密保证网络通信的安全和数据的完整性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;加密的方式&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;对称加密：也叫私钥加密，指加密和解密使用相同密钥的加密算法。有时又叫传统密码算法，就是加密密钥能够从解密密钥中推算出来，同时解密密钥也可以从加密密钥中推算出来。而在大多数的对称算法中，加密密钥和解密密钥是相同的，所以也称这种加密算法为秘密密钥算法或单密钥算法。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;常见的对称加密有：DES（Data Encryption Standard）、AES（Advanced Encryption Standard）、RC4、IDEA。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;非对称加密：与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）；并且加密密钥和解密密钥是成对出现的。非对称加密算法在加密和解密过程使用了不同的密钥，非对称加密也称为公钥加密，在密钥对中，其中一个密钥是对外公开的，所有人都可以获取到，称为公钥，其中一个密钥是不公开的称为私钥。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;非对称加密算法对加密内容的长度有限制，不能超过公钥长度。比如现在常用的公钥长度是 2048 位，意味着待加密内容不能超过 256 个字节。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;摘要算法：采用单项Hash函数将需要加密的明文“摘要”成一串固定长度的密文，这一串密文又称为数字指纹，它有固定的长度，而且不同的明文摘要成密文，其结果总是不同的，而同样的明文其摘要必定一致。“数字摘要“是https能确保数据完整性和防篡改的根本原因，算法不可逆。&lt;/li&gt;
&lt;li&gt;数字签名：数字签名技术就是对“非对称密钥加解密”和“数字摘要“两项技术的应用，它将摘要信息用发送者的私钥加密，与原文一起传送给接收者。接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与解密的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;数字签名的&lt;strong&gt;过程&lt;/strong&gt;如下：&lt;/p&gt;

&lt;p&gt;明文 –&amp;gt; hash运算 –&amp;gt; 摘要 –&amp;gt; 私钥加密 –&amp;gt; 数字签名&lt;/p&gt;

&lt;p&gt;数字签名有两种&lt;strong&gt;作用&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;一、能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。&lt;/p&gt;

&lt;p&gt;二、数字签名能确定消息的完整性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;https数据传输流程&#34;&gt;HTTPS数据传输流程&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;浏览器将支持的加密算法信息发送给服务器&lt;/li&gt;
&lt;li&gt;服务器选择一套浏览器支持的加密算法，以证书的形式回发浏览器&lt;/li&gt;
&lt;li&gt;浏览器验证证书合法性，并结合证书公钥加密信息发送给服务器&lt;/li&gt;
&lt;li&gt;服务器使用私钥解密信息，验证哈希，加密响应消息回发浏览器&lt;/li&gt;
&lt;li&gt;浏览器解密响应消息，并对消息进行验真，之后进行加密交互数据&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;http和https的区别&#34;&gt;HTTP和HTTPS的区别?&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;HTTPS需要到CA申请证书，HTTP不需要&lt;/li&gt;
&lt;li&gt;HTTPS密文传输，HTTP明文传输&lt;/li&gt;
&lt;li&gt;连接方式不同，HTTPS默认使用443端口，HTTP使用80端口&lt;/li&gt;
&lt;li&gt;HTTPS=HTTP+加密+认证+完整性保护，较HTTP安全&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;https真的很安全吗&#34;&gt;HTTPS真的很安全吗?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;那倒未必&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;浏览器默认填充http://，请求需要进行跳转，有被劫持的风险.&lt;/li&gt;
&lt;li&gt;可以使用HSTS（HTTP Strict Transport Security）优化.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TCP滑动窗口</title>
      <link>https://halklein.github.io/2019/009/</link>
      <pubDate>Sat, 02 Nov 2019 19:45:16 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/009/</guid>
      <description>

&lt;h2 id=&#34;1-rtt-和-rto&#34;&gt;1. RTT 和 RTO&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;RTT（round trip time） 往返时延 ：发送一个数据包到收到对应的ACK，所花费的时间。&lt;/li&gt;
&lt;li&gt;RTO（retransamission timeout） ：重传时间间隔，由RTT计算得出，不是写死的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由TCP的重传机制，我们知道Timeout的设置对重置非常重要，设置长了会影响重发效率，设置短了可能导致还没丢失就又重传了。 而网络状况更是复杂，所以我们没有办法设置一个死的Timeout值 。为了动态地设置，TCP引入了RTT， 这样发送端就大约知道需要多少的时间，从而可以方便地设置Timeout——RTO（ Retransmission TimeOut ） ， 以让重传机制更高效。 &lt;a href=&#34;http://tools.ietf.org/html/rfc793&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;RFC793&lt;/a&gt; 中有对算法详细的定义。&lt;/p&gt;

&lt;h2 id=&#34;2-tcp的滑动窗口&#34;&gt;2. TCP的滑动窗口&lt;/h2&gt;

&lt;p&gt;我们都知道，TCP必需要解决的可靠传输以及包乱序（reordering）的问题，所以，TCP必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。 所以，TCP引入了一些技术和设计来做网络流控，Sliding Window是其中一个技术。TCP头里有一个字段叫Window，又叫Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。&lt;/p&gt;

&lt;h3 id=&#34;下面-模拟tcp缓冲区&#34;&gt;&lt;strong&gt;下面，模拟TCP缓冲区：&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/JUC5zmwxbLkyvFq.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;发送端的LastByteAcked指向了被接收端Ack过的位置（表示成功发送确认），LastByteSent表示发出去了，但还没有收到成功确认的Ack，LastByteWritten指向的是上层应用正在写的地方。&lt;/li&gt;
&lt;li&gt;接收端LastByteRead指向了TCP缓冲区中读到的位置，NextByteExpected指向的地方是收到的连续包的最后一个位置，LastByteRcved指向的是收到的包的最后一个位置，我们可以看到中间有些数据还没有到达，所以有数据空白区。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;窗口数据计算过程&#34;&gt;&lt;strong&gt;窗口数据计算过程：&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;接收端在给发送端回ACK中，会汇报自己的 &lt;strong&gt;AdvertisedWindow&lt;/strong&gt; = MaxRcvBuffer – （LastByteRcvd – Last Byte Read），（LastByteRcvd – LastByteRead）表示接收到的数据已占用缓存的大小;&lt;/li&gt;
&lt;li&gt;发送方根据Advertised Window的值，要保证已发送未确认的数据&amp;lt;= Advertised Window的大小，待发送数据大小**EffectiveWindow **= AdvertisedWindow – (LastByteSent – LastByteAcked)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;滑动窗口的基本原理&#34;&gt;滑动窗口的基本原理&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;TCP会话的发送方，滑动窗口示意图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/cnU7JxGLl1hySEe.png&#34; alt=&#34;发送方滑动窗口示意图&#34; /&gt;发送方滑动窗口示意图&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TCP会话的接收方，滑动窗口示意图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/rFw3h7ES8Ze2VAb.png&#34; alt=&#34;接收方滑动窗口示意图&#34; /&gt;接收方滑动窗口示意图&lt;/p&gt;

&lt;p&gt;需要指出的是，滑动窗口的大小可以依据一定的策略动态调整。应用会根据自身处理能力的变化，通过对本端TCP接收窗口大小的控制来实现对端的发送窗口进行流量限制。&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>