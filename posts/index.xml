<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on HalKlein`s Blog</title>
    <link>https://halklein.github.io/posts/</link>
    <description>Recent content in Posts on HalKlein`s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <managingEditor>dev.HalKlein@gmail.com (HalKlein)</managingEditor>
    <webMaster>dev.HalKlein@gmail.com (HalKlein)</webMaster>
    <lastBuildDate>Tue, 24 Dec 2019 21:22:50 +0800</lastBuildDate>
    <atom:link href="https://halklein.github.io/posts/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>关于数据库索引的一些问题</title>
      <link>https://halklein.github.io/2019/021/</link>
      <pubDate>Tue, 24 Dec 2019 21:22:50 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/021/</guid>
      <description>

&lt;h2 id=&#34;一-密集索引和稀疏索引&#34;&gt;一、密集索引和稀疏索引&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;密集索引文件中的每个搜索码值都对应一个索引值&lt;/li&gt;
&lt;li&gt;稀疏索引文件只为索引码的某些值建立索引项&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/24/qtGm8r27hMxLDwV.png&#34; alt=&#34;密集索引和稀疏索引&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MySQL常见的数据库引擎：MyISAM只使用稀疏索引，InnoDB有且仅有以后密集索引&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;若一个主键被定义，该主键则作为密集索引&lt;/li&gt;
&lt;li&gt;若没有主键被定义，该表的第一个唯一非空索引则作为密集索引&lt;/li&gt;
&lt;li&gt;若不满足以上条件，innodb内部会生成一个隐藏主键（密集索引）&lt;/li&gt;
&lt;li&gt;非主键索引存储相关键位和其对应的主键值，包含两次查找&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;二-如何定位并优化慢查询sql&#34;&gt;二、如何定位并优化慢查询Sql&lt;/h2&gt;

&lt;p&gt;具体场景要具体分析，大致思路如下：
- 根据慢日志定位慢查询sql
- 使用explain等工具分析sql
- 修改sql或者尽量让sql走索引&lt;/p&gt;

&lt;h3 id=&#34;2-1-根据慢日志定位慢查询sql&#34;&gt;2.1 根据慢日志定位慢查询sql&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;# 查看数据库慢日志配置
show variables like &amp;quot;%quer%&amp;quot;;

# 查看慢日志数量
show status like &amp;quot;%slow_queries%&amp;quot;;

# 打开慢日志开关
set global slow_query_log = on;

# 设置慢日志记录阈值为1s，10s可以说是很慢很慢了，不具有参考价值
# 修改后可能需要重新连接数据库才能看到效果
# 另外，这样的设置在重启MySQL服务之后将会失效！如果要永久生效,需修改my.ini配置文件（Mac OS是my.cnf）
set global long_query_time = 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/24/NFSpx65OUvuqQhD.png&#34; alt=&#34;查看数据库慢日志配置&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>数据库索引之 B&#43; Tree、Hash、BitMap</title>
      <link>https://halklein.github.io/2019/020/</link>
      <pubDate>Tue, 24 Dec 2019 19:54:38 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/020/</guid>
      <description>

&lt;h2 id=&#34;b-tree&#34;&gt;B+ Tree&lt;/h2&gt;

&lt;p&gt;由于，二叉查看树在插入修改过程中，很可能出现只有左右子树的情况，虽然可以用平衡调整二叉树，但是每次IO依然很费时间，每访问一层就要对磁盘进行IO，总体来说二叉树还不够优。由此找到了更好的替代方法-B树，又由于B+ Tree具有更好的特性，所以B+ Tree就成了常见的索引结构之一。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/24/xkZWtEguQIAoRXK.png&#34; alt=&#34;B+ Tree&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;B+ Tree相对于B树，具有的新特点：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;非叶子节点的子树指针与关键字个数相同&lt;/li&gt;
&lt;li&gt;非叶子节点的子树指针P[]，指向关键字值（[Ki]，K[i+1]）的子树&lt;/li&gt;
&lt;li&gt;非叶子节点仅用来索引，数据都保存在叶子节点中&lt;/li&gt;
&lt;li&gt;所有叶子节点均有一个链指针指向下一个叶子结点&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;hash&#34;&gt;Hash&lt;/h2&gt;

&lt;p&gt;通过Hash索引，能够通过Hash函数快速定位到索引目标，理论上比B+ Tree更快。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/24/hci2ueoaKS4klxf.png&#34; alt=&#34;Hash索引&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;但是Hash索引也有也有严重的缺陷：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;仅仅能满足“=&amp;ldquo;，“IN&amp;rdquo;，不能使用范围查询&lt;/li&gt;
&lt;li&gt;无法被用来避免数据的排序操作&lt;/li&gt;
&lt;li&gt;不能利用部分索引键查询&lt;/li&gt;
&lt;li&gt;不能避免表扫描&lt;/li&gt;
&lt;li&gt;遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，索引没有最优，只有更适合某种情况的索引结构，他们常常组合使用。&lt;/p&gt;

&lt;h2 id=&#34;bitmap&#34;&gt;BitMap&lt;/h2&gt;

&lt;p&gt;位图索引，适用于某个字段的值只有固定的几种为了实现高效的统计的情况，如性别（男、女）。不过支持位图索引的数据库比较少，典型的有Oracle数据库。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/24/4uxK3ZdCTknmj9w.png&#34; alt=&#34;BitMap&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Socket 入门</title>
      <link>https://halklein.github.io/2019/011/</link>
      <pubDate>Tue, 05 Nov 2019 09:31:12 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/011/</guid>
      <description>

&lt;h2 id=&#34;进程间通信&#34;&gt;进程间通信&lt;/h2&gt;

&lt;p&gt;网络中进程进行通信的前提是每个进程都要有唯一的标识，在本地计算机中我们可以用PID来唯一标识一个进程，可以多个计算机处在网络中时，不同计算机的进程PID冲突的可能性就很大。怎么办呢？我们知道IP地址可以唯一标识主机，而TCP协议和端口号可以唯一标识主机的一个进程，这样我们就可以用 IP+协议+端口号 来唯一标识网络中的一个进程了。&lt;/p&gt;

&lt;p&gt;使用TCP/IP协议的应用程序通常采用应用编程接口：UNIX BSD的套接字（socket）和UNIX System V的TLI（已经被淘汰），来实现网络进程之间的通信。就目前而言，几乎所有的应用程序都是采用socket。&lt;/p&gt;

&lt;h2 id=&#34;什么是socket&#34;&gt;什么是Socket？&lt;/h2&gt;

&lt;p&gt;网络套接字（英语：Network socket；又译网络套接字、网络接口、网络插槽）在计算机科学中是电脑网络中行程间数据流的端点。使用以网际协议（Internet Protocol）为通信基础的网络套接字，称为网际套接字（Internet socket）。因为网际协议的流行，现代绝大多数的网络套接字，都是属于网际套接字。&lt;/p&gt;

&lt;p&gt;socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&amp;gt; 读写write/read –&amp;gt; 关闭close”模式来操作。我的理解就是Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/tl96CpP3Qv4fMEV.jpg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Socket与TCP/IP协议并没有必然的联系，Socket编程接口在设计的时候就希望能适应其它的网络协议，所以Socket的出现是为了我们更好地使用TCP/IP协议栈，是对TCP/IP协议的抽象，是操作系统对外开放的接口。&lt;/p&gt;

&lt;h2 id=&#34;socket通信流程&#34;&gt;socket通信流程&lt;/h2&gt;

&lt;p&gt;以使用TCP协议通讯的socket为例，其交互流程大概是这样子的&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/aJRALE8cFmZonkg.png&#34; alt=&#34;Socket通信流程&#34; /&gt;Socket通信流程&lt;/p&gt;

&lt;h2 id=&#34;实列&#34;&gt;实列&lt;/h2&gt;

&lt;h3 id=&#34;编写一个网络应用程序-包含客户端和服务端-客户端向服务端发送一个字符串-服务端收到字符串并打印到命令行同时向客户端返回字符串长度-最后客户端输出收到的字符串长度-分别用tcp和udp实现&#34;&gt;&lt;strong&gt;编写一个网络应用程序，包含客户端和服务端，客户端向服务端发送一个字符串，服务端收到字符串并打印到命令行同时向客户端返回字符串长度，最后客户端输出收到的字符串长度，分别用TCP和UDP实现。&lt;/strong&gt;&lt;/h3&gt;

&lt;h4 id=&#34;tcp方式&#34;&gt;TCP方式：&lt;/h4&gt;

&lt;p&gt;服务端&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TCPServer {
    public static void main(String[] args) throws Exception {
        //创建socket,并将socket绑定到65000端口
        ServerSocket ss = new ServerSocket(65000);
        //死循环，使得socket一直等待并处理客户端发送过来的请求
        while (true) {
            //监听65000端口，直到客户端返回连接信息后才返回
            Socket socket = ss.accept();
            //获取客户端的请求信息后，执行相关业务逻辑
            new LengthCalculator(socket).start();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;服务端业务逻辑&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class LengthCalculator extends Thread {
    //以socket为成员变量
    private Socket socket;
    public LengthCalculator(Socket socket) {
        this.socket = socket;
    }
    @Override
    public void run() {
        try {
            //获取socket的输出流
            OutputStream os = socket.getOutputStream();
            //获取socket的输入流
            InputStream is = socket.getInputStream();
            int ch = 0;
            byte[] buff = new byte[1024];
            //buff主要用来读取输入的内容，存成byte数组，ch主要用来获取读取数组的长度
            ch = is.read(buff);
            //将接收流的byte数组转换成字符串，这里获取的内容是客户端发送过来的字符串参数
            String content = new String(buff, 0, ch);
            System.out.println(content);
            //往输出流里写入获得的字符串的长度，回发给客户端
            os.write(String.valueOf(content.length()).getBytes());
            //不要忘记关闭输入输出流以及socket
            is.close();
            os.close();
            socket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;客户端&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TCPClient {
    public static void main(String[] args) throws Exception {
        //创建socket，并指定连接的是本机的端口号为65000的服务器socket
        Socket socket = new Socket(&amp;quot;127.0.0.1&amp;quot;, 65000);
        //获取输出流
        OutputStream os = socket.getOutputStream();
        //获取输入流
        InputStream is = socket.getInputStream();
        //将要传递给server的字符串参数转换成byte数组，并将数组写入到输出流中
        os.write(new String(&amp;quot;hello world&amp;quot;).getBytes());
        int ch = 0;
        byte[] buff = new byte[1024];
        //buff主要用来读取输入的内容，存成byte数组，ch主要用来获取读取数组的长度
        ch = is.read(buff);
        //将接收流的byte数组转换成字符串，这里是从服务端回发回来的字符串参数的长度
        String content = new String(buff, 0, ch);
        System.out.println(content);
        //不要忘记关闭输入输出流以及socket
        is.close();
        os.close();
        socket.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/Rg5GzaCweFlMtjL.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/iITvbCjR18d2HMY.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;UDP方式：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;服务端&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UDPServer {
    public static void main(String[] args) throws Exception {
        // 服务端接受客户端发送的数据报
        DatagramSocket socket = new DatagramSocket(65001); //监听的端口号
        byte[] buff = new byte[100]; //存储从客户端接受到的内容
        DatagramPacket packet = new DatagramPacket(buff, buff.length);
        //接受客户端发送过来的内容，并将内容封装进DatagramPacket对象中
        socket.receive(packet);
        byte[] data = packet.getData(); //从DatagramPacket对象中获取到真正存储的数据
        //将数据从二进制转换成字符串形式
        String content = new String(data, 0, packet.getLength());
        System.out.println(content);
        //将要发送给客户端的数据转换成二进制
        byte[] sendedContent = String.valueOf(content.length()).getBytes();
        // 服务端给客户端发送数据报
        //从DatagramPacket对象中获取到数据的来源地址与端口号
        DatagramPacket packetToClient = new DatagramPacket(sendedContent,
                sendedContent.length, packet.getAddress(), packet.getPort());
        socket.send(packetToClient); //发送数据给客户端
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;客户端&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UDPClient {
    public static void main(String[] args) throws Exception {
        // 客户端发数据报给服务端
        DatagramSocket socket = new DatagramSocket();
        // 要发送给服务端的数据
        byte[] buf = &amp;quot;Hello World&amp;quot;.getBytes();
        // 将IP地址封装成InetAddress对象
        InetAddress address = InetAddress.getByName(&amp;quot;127.0.0.1&amp;quot;);
        // 将要发送给服务端的数据封装成DatagramPacket对象 需要填写上ip地址与端口号
        DatagramPacket packet = new DatagramPacket(buf, buf.length, address,
                65001);
        // 发送数据给服务端
        socket.send(packet);
        // 客户端接受服务端发送过来的数据报
        byte[] data = new byte[100];
        // 创建DatagramPacket对象用来存储服务端发送过来的数据
        DatagramPacket receivedPacket = new DatagramPacket(data, data.length);
        // 将接受到的数据存储到DatagramPacket对象中
        socket.receive(receivedPacket);
        // 将服务器端发送过来的数据取出来并打印到控制台
        String content = new String(receivedPacket.getData(), 0,
                receivedPacket.getLength());
        System.out.println(content);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/RuBrkvAVp5aFTx3.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>HTTP 与 HTTPS</title>
      <link>https://halklein.github.io/2019/010/</link>
      <pubDate>Sun, 03 Nov 2019 15:52:12 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/010/</guid>
      <description>

&lt;h2 id=&#34;1-http协议&#34;&gt;1. HTTP协议&lt;/h2&gt;

&lt;p&gt;超文本传输协议（英语：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。 通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接 。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HTTP 协议构建于 TCP/IP 协议之上，是一个应用层协议，默认端口号是 80&lt;/li&gt;
&lt;li&gt;HTTP 是&lt;strong&gt;无连接无状态&lt;/strong&gt;的&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-版本&#34;&gt;2. 版本&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;HTTP/0.9&lt;/strong&gt; 已过时。只接受GET一种请求方法，没有在通讯中指定版本号，且不支持请求头。由于该版本不支持POST方法，因此客户端无法向服务器传递太多信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HTTP/1.0&lt;/strong&gt; 这是第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用，特别是在代理服务器中。[来源请求]&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HTTP/1.1&lt;/strong&gt; 持久连接被默认采用，并能很好地配合代理服务器工作。还支持以管道方式在同时发送多个请求，以便降低线路负载，提高传输速度。HTTP/1.1相较于HTTP/1.0协议的区别主要体现在：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;缓存处理&lt;/li&gt;
&lt;li&gt;带宽优化及网络连接的使用&lt;/li&gt;
&lt;li&gt;错误通知的管理&lt;/li&gt;
&lt;li&gt;消息在网络中的发送&lt;/li&gt;
&lt;li&gt;互联网地址的维护&lt;/li&gt;
&lt;li&gt;安全性及完整性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;HTTP/2&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当前版本，于2015年5月作为互联网标准正式发布。&lt;/p&gt;

&lt;p&gt;HTTP目前处于多个版本共存的情况，包括仍被广泛采用的HTTP１.0，主流是1.1（ 1.1 版的最大变化，就是引入 Keep-Alive， 简单说就是保持当前的TCP连接，避免了重新建立连接。 ）， HTTP/2 目前应用较少（主要是因为1.1基本能满足需求，还有升级成本问题）&lt;/p&gt;

&lt;h2 id=&#34;2-超文本传输协议http主要特点&#34;&gt;2. 超文本传输协议HTTP主要特点&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;支持B/S及C/S模式&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;简单快速&lt;/strong&gt; ：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;灵活：&lt;/strong&gt;HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无连接：&lt;/strong&gt;无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无状态：&lt;/strong&gt;HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;3-http请求结构&#34;&gt;3. HTTP请求结构&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/G4fT2BQZSq7U6jn.png&#34; alt=&#34;HTTP请求结构&#34; /&gt;HTTP请求结构&lt;/p&gt;

&lt;p&gt;HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;序号&lt;/th&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;请求指定的页面信息，并返回实体主体。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;HEAD&lt;/td&gt;
&lt;td&gt;类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;POST&lt;/td&gt;
&lt;td&gt;向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;PUT&lt;/td&gt;
&lt;td&gt;从客户端向服务器传送的数据取代指定的文档的内容。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;DELETE&lt;/td&gt;
&lt;td&gt;请求服务器删除指定的页面。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;CONNECT&lt;/td&gt;
&lt;td&gt;HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;OPTIONS&lt;/td&gt;
&lt;td&gt;允许客户端查看服务器的性能。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;TRACE&lt;/td&gt;
&lt;td&gt;回显服务器收到的请求，主要用于测试或诊断。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;PATCH&lt;/td&gt;
&lt;td&gt;是对 PUT 方法的补充，用来对已知资源进行局部更新 。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;请求头部用来设置HTTP请求的一些参数，如Host、User-Agen&lt;/p&gt;

&lt;p&gt;请求数据，表示要上传的数据，其和头部之间是是有空行的，且请求头部后面的空行是必须的（即使请求数据为空）。&lt;/p&gt;

&lt;h2 id=&#34;4-http响应结构&#34;&gt;4. HTTP响应结构&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/RoUCGZ16VKHb4hk.png&#34; alt=&#34;HTTP响应结构&#34; /&gt;HTTP响应结构&lt;/p&gt;

&lt;h3 id=&#34;状态码类别&#34;&gt;状态码类别&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;分类&lt;/th&gt;
&lt;th&gt;分类描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1**&lt;/td&gt;
&lt;td&gt;指示信息，表示服务器收到请求，需要请求者继续执行操作&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2**&lt;/td&gt;
&lt;td&gt;成功，操作被成功接收并处理&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3**&lt;/td&gt;
&lt;td&gt;重定向，需要进一步的操作以完成请求&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4**&lt;/td&gt;
&lt;td&gt;客户端错误，请求包含语法错误或无法完成请求&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5**&lt;/td&gt;
&lt;td&gt;服务器错误，服务器在处理请求的过程中发生了错误&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;常见状态码&#34;&gt;&lt;strong&gt;常见状态码&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;200 OK&lt;/code&gt; 客户端请求成功&lt;/li&gt;
&lt;li&gt;&lt;code&gt;301 Moved Permanently&lt;/code&gt; 请求永久重定向&lt;/li&gt;
&lt;li&gt;&lt;code&gt;302 Moved Temporarily&lt;/code&gt; 请求临时重定向&lt;/li&gt;
&lt;li&gt;&lt;code&gt;304 Not Modified&lt;/code&gt; 文件未修改，可以直接使用缓存的文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;400 Bad Request&lt;/code&gt; 由于客户端请求有语法错误，不能被服务器所理解。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;401 Unauthorized&lt;/code&gt; 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;403 Forbidden&lt;/code&gt; 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;404 Not Found&lt;/code&gt; 请求的资源不存在，例如，输入了错误的URL。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;500 Internal Server Error&lt;/code&gt; 服务器发生不可预期的错误，导致无法完成客户端的请求。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;503 Service Unavailable&lt;/code&gt; 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;详细的状态码，可以 &lt;a href=&#34;https://www.runoob.com/http/http-status-codes.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;在这里查看&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;5-http抓包分析&#34;&gt;5. HTTP抓包分析&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/azHYDUIAb4yJw6Q.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;双击第一条&lt;strong&gt;HTTP请求&lt;/strong&gt;，查看详细请求报文：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/JryvnTqcubGUMDS.png&#34; alt=&#34;HTTP请求&#34; /&gt;HTTP请求&lt;/p&gt;

&lt;p&gt;双击第二条&lt;strong&gt;HTTP响应&lt;/strong&gt;，查看详细响应报文：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/fjxp98r1Nign46K.png&#34; alt=&#34;HTTP响应&#34; /&gt;HTTP响应&lt;/p&gt;

&lt;h2 id=&#34;6-http请求-响应的步骤&#34;&gt;6. HTTP请求/响应的步骤&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;客户端连接到Web服务器，客户端（通常是浏览器）与Web服务器的端口（默认80）建立TCP套接字（ socket ）连接&lt;/li&gt;
&lt;li&gt;客户端发送HTTP请求&lt;/li&gt;
&lt;li&gt;服务器接受请求并返回HTTP响应&lt;/li&gt;
&lt;li&gt;释放连接TCP连接。若连接模式为close则服务器主动关闭TCP连接；若连接模式为Keep-Alive则该连接会保持一段时间，在该时间内可以继续接收请求。&lt;/li&gt;
&lt;li&gt;客户端浏览器解析HTML内容&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;7-一些问题&#34;&gt;7. 一些问题&lt;/h2&gt;

&lt;h3 id=&#34;7-1-在浏览器地址栏键入带有http请求的url-按下回车之后经历的流程&#34;&gt;7.1 在浏览器地址栏键入带有HTTP请求的URL，按下回车之后经历的流程？&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;DNS解析。浏览器会根据URL逐层（浏览器缓存 – 系统缓存 – 路由器缓存 – IPS服务器缓存 – 域名服务器缓存 – 顶级域名服务器缓存，找到即可返回不再需要查询后面的缓存）查询DNS缓存，解析URL中的域名对应的IP地址。&lt;/li&gt;
&lt;li&gt;TCP连接。根据IP地址和端口与服务器建立TCP连接（三次握手）。&lt;/li&gt;
&lt;li&gt;发送HTTP请求。建立连接后浏览器向服务器发出读取文件的HTTP请求。&lt;/li&gt;
&lt;li&gt;服务器处理请求并返回HTTP报文。&lt;/li&gt;
&lt;li&gt;浏览器解析渲染页面。&lt;/li&gt;
&lt;li&gt;连接结束。浏览器释放TCP连接。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;7-2-get请求和post请求的区别&#34;&gt;7.2 GET请求和POST请求的区别？&lt;/h3&gt;

&lt;p&gt;从三个层面来解答&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;1. Http报文层面：&lt;/strong&gt;GET将请求信息放在URL，POST放在报文体中（想获得请求详细必须请求报文，所以安全性较GET方式高一些，事实上要获得报文体中的请求信息也是很容易的‘Wireshark就可以查看’，因此安全性上两者并没有太多的区别，具体解决安全性的问题需要HTTPS）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/DQaeRE6JoPSrfYn.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;2. 数据库层面：&lt;/strong&gt;CET符合幂等性（多次操作获得结果一样）和安全性（不会改变数据库数据，GET做查询操作），POST都不符合。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;3. 其他层面：&lt;/strong&gt;GET可以被缓存、被存储，而POST不行。所以GET现在依然规范使用。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;7-3-cookie和session的区别&#34;&gt;7.3 Cookie和Session的区别？&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Cookie简介&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;是由服务器发给客户端的特殊信息，以文本的形式存放在客户端 客户端再次请求的时候，会把Cookie回发 服务器接收到后，会解析Cookie生成与客户端相对应的内容&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Cookie的设置以及发送过程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/2hP1culNRmJwZej.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;客户端发送一个http请求到服务器端&lt;/li&gt;
&lt;li&gt;服务器端发送一个http响应到客户端，其中包含Set-Cookie头部&lt;/li&gt;
&lt;li&gt;客户端发送一个http请求到服务器端，其中包含Cookie头部&lt;/li&gt;
&lt;li&gt;服务器端发送一个http响应到客户端&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Session简介&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;服务器端的机制，在服务器上保存的信息 解析客户端请求并操作session id，按需保存状态信息&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Session的实现方式&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用Cookie来实现&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/nGwOtgZTQxP8lCU.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用URL回写来实现。服务器在发送给浏览器的所有连接中都携带JSESSIONID的参数，这样客户端点击任何一个路径都会带回JSESSIONID。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;二者的区别：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Cookie数据存放在客户的浏览器上，Session数据放在服务器上&lt;/li&gt;
&lt;li&gt;Session相对于Cookie更安全&lt;/li&gt;
&lt;li&gt;若考虑减轻服务器负担，应当使用Cookie&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;7-4-http和https的区别&#34;&gt;7.4 HTTP和HTTPS的区别？&lt;/h2&gt;

&lt;h3 id=&#34;https简介&#34;&gt;HTTPS简介&lt;/h3&gt;

&lt;p&gt;超文本传输安全协议（英语：HyperText Transfer Protocol Secure，缩写：HTTPS；常称为HTTP over TLS、HTTP over SSL或HTTP Secure）是一种通过计算机网络进行安全通信的传输协议。是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。&lt;/p&gt;

&lt;h3 id=&#34;ssl&#34;&gt;SSL&lt;/h3&gt;

&lt;p&gt;SSL（Security Sockets Layer，安全套接层）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;为网络通信提供安全及数据完整性的一种安全协议&lt;/li&gt;
&lt;li&gt;是操作系统对外的API，SSL3.0后更名为TLS&lt;/li&gt;
&lt;li&gt;采用身份验证和数据加密保证网络通信的安全和数据的完整性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;加密的方式&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;对称加密：也叫私钥加密，指加密和解密使用相同密钥的加密算法。有时又叫传统密码算法，就是加密密钥能够从解密密钥中推算出来，同时解密密钥也可以从加密密钥中推算出来。而在大多数的对称算法中，加密密钥和解密密钥是相同的，所以也称这种加密算法为秘密密钥算法或单密钥算法。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;常见的对称加密有：DES（Data Encryption Standard）、AES（Advanced Encryption Standard）、RC4、IDEA。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;非对称加密：与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）；并且加密密钥和解密密钥是成对出现的。非对称加密算法在加密和解密过程使用了不同的密钥，非对称加密也称为公钥加密，在密钥对中，其中一个密钥是对外公开的，所有人都可以获取到，称为公钥，其中一个密钥是不公开的称为私钥。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;非对称加密算法对加密内容的长度有限制，不能超过公钥长度。比如现在常用的公钥长度是 2048 位，意味着待加密内容不能超过 256 个字节。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;摘要算法：采用单项Hash函数将需要加密的明文“摘要”成一串固定长度的密文，这一串密文又称为数字指纹，它有固定的长度，而且不同的明文摘要成密文，其结果总是不同的，而同样的明文其摘要必定一致。“数字摘要“是https能确保数据完整性和防篡改的根本原因，算法不可逆。&lt;/li&gt;
&lt;li&gt;数字签名：数字签名技术就是对“非对称密钥加解密”和“数字摘要“两项技术的应用，它将摘要信息用发送者的私钥加密，与原文一起传送给接收者。接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与解密的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;数字签名的&lt;strong&gt;过程&lt;/strong&gt;如下：&lt;/p&gt;

&lt;p&gt;明文 –&amp;gt; hash运算 –&amp;gt; 摘要 –&amp;gt; 私钥加密 –&amp;gt; 数字签名&lt;/p&gt;

&lt;p&gt;数字签名有两种&lt;strong&gt;作用&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;一、能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。&lt;/p&gt;

&lt;p&gt;二、数字签名能确定消息的完整性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;https数据传输流程&#34;&gt;HTTPS数据传输流程&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;浏览器将支持的加密算法信息发送给服务器&lt;/li&gt;
&lt;li&gt;服务器选择一套浏览器支持的加密算法，以证书的形式回发浏览器&lt;/li&gt;
&lt;li&gt;浏览器验证证书合法性，并结合证书公钥加密信息发送给服务器&lt;/li&gt;
&lt;li&gt;服务器使用私钥解密信息，验证哈希，加密响应消息回发浏览器&lt;/li&gt;
&lt;li&gt;浏览器解密响应消息，并对消息进行验真，之后进行加密交互数据&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;http和https的区别&#34;&gt;HTTP和HTTPS的区别?&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;HTTPS需要到CA申请证书，HTTP不需要&lt;/li&gt;
&lt;li&gt;HTTPS密文传输，HTTP明文传输&lt;/li&gt;
&lt;li&gt;连接方式不同，HTTPS默认使用443端口，HTTP使用80端口&lt;/li&gt;
&lt;li&gt;HTTPS=HTTP+加密+认证+完整性保护，较HTTP安全&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;https真的很安全吗&#34;&gt;HTTPS真的很安全吗?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;那倒未必&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;浏览器默认填充http://，请求需要进行跳转，有被劫持的风险.&lt;/li&gt;
&lt;li&gt;可以使用HSTS（HTTP Strict Transport Security）优化.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TCP滑动窗口</title>
      <link>https://halklein.github.io/2019/009/</link>
      <pubDate>Sat, 02 Nov 2019 19:45:16 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/009/</guid>
      <description>

&lt;h2 id=&#34;1-rtt-和-rto&#34;&gt;1. RTT 和 RTO&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;RTT（round trip time） 往返时延 ：发送一个数据包到收到对应的ACK，所花费的时间。&lt;/li&gt;
&lt;li&gt;RTO（retransamission timeout） ：重传时间间隔，由RTT计算得出，不是写死的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由TCP的重传机制，我们知道Timeout的设置对重置非常重要，设置长了会影响重发效率，设置短了可能导致还没丢失就又重传了。 而网络状况更是复杂，所以我们没有办法设置一个死的Timeout值 。为了动态地设置，TCP引入了RTT， 这样发送端就大约知道需要多少的时间，从而可以方便地设置Timeout——RTO（ Retransmission TimeOut ） ， 以让重传机制更高效。 &lt;a href=&#34;http://tools.ietf.org/html/rfc793&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;RFC793&lt;/a&gt; 中有对算法详细的定义。&lt;/p&gt;

&lt;h2 id=&#34;2-tcp的滑动窗口&#34;&gt;2. TCP的滑动窗口&lt;/h2&gt;

&lt;p&gt;我们都知道，TCP必需要解决的可靠传输以及包乱序（reordering）的问题，所以，TCP必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。 所以，TCP引入了一些技术和设计来做网络流控，Sliding Window是其中一个技术。TCP头里有一个字段叫Window，又叫Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。&lt;/p&gt;

&lt;h3 id=&#34;下面-模拟tcp缓冲区&#34;&gt;&lt;strong&gt;下面，模拟TCP缓冲区：&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/JUC5zmwxbLkyvFq.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;发送端的LastByteAcked指向了被接收端Ack过的位置（表示成功发送确认），LastByteSent表示发出去了，但还没有收到成功确认的Ack，LastByteWritten指向的是上层应用正在写的地方。&lt;/li&gt;
&lt;li&gt;接收端LastByteRead指向了TCP缓冲区中读到的位置，NextByteExpected指向的地方是收到的连续包的最后一个位置，LastByteRcved指向的是收到的包的最后一个位置，我们可以看到中间有些数据还没有到达，所以有数据空白区。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;窗口数据计算过程&#34;&gt;&lt;strong&gt;窗口数据计算过程：&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;接收端在给发送端回ACK中，会汇报自己的 &lt;strong&gt;AdvertisedWindow&lt;/strong&gt; = MaxRcvBuffer – （LastByteRcvd – Last Byte Read），（LastByteRcvd – LastByteRead）表示接收到的数据已占用缓存的大小;&lt;/li&gt;
&lt;li&gt;发送方根据Advertised Window的值，要保证已发送未确认的数据&amp;lt;= Advertised Window的大小，待发送数据大小**EffectiveWindow **= AdvertisedWindow – (LastByteSent – LastByteAcked)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;滑动窗口的基本原理&#34;&gt;滑动窗口的基本原理&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;TCP会话的发送方，滑动窗口示意图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/cnU7JxGLl1hySEe.png&#34; alt=&#34;发送方滑动窗口示意图&#34; /&gt;发送方滑动窗口示意图&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TCP会话的接收方，滑动窗口示意图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/rFw3h7ES8Ze2VAb.png&#34; alt=&#34;接收方滑动窗口示意图&#34; /&gt;接收方滑动窗口示意图&lt;/p&gt;

&lt;p&gt;需要指出的是，滑动窗口的大小可以依据一定的策略动态调整。应用会根据自身处理能力的变化，通过对本端TCP接收窗口大小的控制来实现对端的发送窗口进行流量限制。&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TCP和UDP的区别</title>
      <link>https://halklein.github.io/2019/008/</link>
      <pubDate>Fri, 01 Nov 2019 14:26:16 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/008/</guid>
      <description>

&lt;h2 id=&#34;1-udp协议&#34;&gt;1. UDP协议&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;用户数据报协议&lt;/strong&gt;（英语：&lt;strong&gt;U&lt;/strong&gt;ser &lt;strong&gt;D&lt;/strong&gt;atagram &lt;strong&gt;P&lt;/strong&gt;rotocol，缩写：&lt;strong&gt;UDP&lt;/strong&gt;；又称&lt;strong&gt;用户数据包协议&lt;/strong&gt;）是一个简单的面向数据报的通信协议，位于OSI模型的传输层。该协议由 &lt;a href=&#34;https://zh.wikipedia.org/w/index.php?title=David_P._Reed&amp;amp;action=edit&amp;amp;redlink=1&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;David P. Reed&lt;/a&gt; 在1980年设计且在&lt;a href=&#34;https://tools.ietf.org/html/rfc768&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;RFC 768&lt;/a&gt;中被规范。典型网络上的众多使用UDP协议的关键应用在一定程度上是相似的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/tk53hsSwfUxFKAE.png&#34; alt=&#34;UDP头部结构&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;UDP头部包含了以下几个数据：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;两个16位的端口号，分别为源端口（可选）和目标端口&lt;/li&gt;
&lt;li&gt;数据报的长度&lt;/li&gt;
&lt;li&gt;数据报的检验和（IPv4 可选字段），该字段用于发现头部信息和数据中的错误&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;UDP相比于TCP明显要简单很多，因此UDP头部开销小，只有8个字节，在传输数据报文时是很高效的。当然也就不支持错误重传，滑动窗口等精细的控制。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;UDP的特点：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;面向非连接，传输数据之前不需要先建立连接。&lt;/li&gt;
&lt;li&gt;不维护连接状态，支持同时向多个客户端传输相同的消息， 支持一对一、一对多、多对多、多对一的传输方式，也就是说 UDP 提供了单播，多播，广播的功能。&lt;/li&gt;
&lt;li&gt;数据包报头只有8个字节，额外开销较小&lt;/li&gt;
&lt;li&gt;吞吐量只受限于数据生成速率、传输速率以及机器性能&lt;/li&gt;
&lt;li&gt;不可靠：尽最大努力交付，不保证可靠交付，不需要维持复杂的链接状态表&lt;/li&gt;
&lt;li&gt;面向报文，不对应用程序提交的报文信息进行拆分或者合并&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-tcp和udp的区别&#34;&gt;2. TCP和UDP的区别&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;TCP&lt;/th&gt;
&lt;th&gt;UDP&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;是否连接&lt;/td&gt;
&lt;td&gt;面向连接&lt;/td&gt;
&lt;td&gt;无连接&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;可靠性&lt;/td&gt;
&lt;td&gt;可靠传输，使用流量控制和拥塞控制&lt;/td&gt;
&lt;td&gt;不可靠传输，不使用流量控制和拥塞控制&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;有序性&lt;/td&gt;
&lt;td&gt;有序&lt;/td&gt;
&lt;td&gt;无序&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;速率&lt;/td&gt;
&lt;td&gt;慢&lt;/td&gt;
&lt;td&gt;快&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;量级&lt;/td&gt;
&lt;td&gt;重量级&lt;/td&gt;
&lt;td&gt;轻量级&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;连接对象个数&lt;/td&gt;
&lt;td&gt;只支持一对一通信&lt;/td&gt;
&lt;td&gt;支持一对一，一对多，多对一、多对多通信&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;传输方式&lt;/td&gt;
&lt;td&gt;面向字节流&lt;/td&gt;
&lt;td&gt;面向报文&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;首部开销&lt;/td&gt;
&lt;td&gt;首部最小20字节，最大60字节&lt;/td&gt;
&lt;td&gt;首部开销小，仅8字节&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;适用场景&lt;/td&gt;
&lt;td&gt;要求可靠传输的应用，例如文件传输&lt;/td&gt;
&lt;td&gt;实时应用（IP电话、视频会议、直播等）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TCP四次挥手</title>
      <link>https://halklein.github.io/2019/007/</link>
      <pubDate>Thu, 31 Oct 2019 13:56:16 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/007/</guid>
      <description>

&lt;h2 id=&#34;1-四次挥手-关闭连接&#34;&gt;1. 四次挥手，关闭连接&lt;/h2&gt;

&lt;p&gt;由于TCP连接是全双工的，即连接双方可以在一条TCP连接上互相传输数据，每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个&lt;code&gt;FIN&lt;/code&gt;来终止这个方向的连接。收到一个&lt;code&gt;FIN&lt;/code&gt;只意味着这一方向上没有数据流动，一个 TCP 连接在收到一个&lt;code&gt;FIN&lt;/code&gt;后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭，因此在断开时存在一个半关闭状态，即有有一方失去发送数据的能力，却还能接收数据。所以，断开连接需要分为四次 ，称为&lt;strong&gt;四次挥手&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行&lt;code&gt;close()&lt;/code&gt;操作即可产生挥手操作。&lt;/p&gt;

&lt;p&gt;以下，我们假设由客户端主动触发close()。&lt;/p&gt;

&lt;h2 id=&#34;2-四次挥手流程图&#34;&gt;2. 四次挥手流程图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/5pbistqQF7XTxBV.png&#34; alt=&#34;四次挥手流程图&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;第一次挥手(FIN=1，seq=u)&lt;/strong&gt;
假设假客户端主动触发close()，客户端发送一个FIN标志位为 1 的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。因为有可能服务器还要发送数据，所以发送自己的序列号seq=u，等待服务器确认。发送完毕后，客户端进入FIN_WAIT_1状态。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;第二次挥手(ACK=1，seq=v，ack=u+1)&lt;/strong&gt;
服务器端确认客户端的FIN包，发送一个确认包【ACK=1(确认)、seq=v(自己的序列号)、ack=u+1(确认收到序列号)】，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接(可能有数据发送)。
发送完毕后，服务器端进入CLOSE_WAIT状态，客户端接收到这个确认包之后，进入FIN_WAIT_2状态，等待服务器端关闭连接。
在这过程中 TCP 服务器进程会通知高层应用进程。然后从客户端到服务器这个方向的连接就释放了，TCP 连接处于半关闭状态。但是服务器若发送数据，客户端仍要接收。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;第三次挥手(FIN=1，ACK=1，seq=w，ack=u+1)&lt;/strong&gt;
若服务器已经没有要向客户端发送的数据，其应用进程就通知 TCP 释放连接。
服务器端准备好关闭连接时，向客户端发送结束连接请求FIN置为 1，ACK=1，seq=w(有数据发送过)，ack=u+1。
发送完毕后，服务器端进入LAST_ACK状态，等待来自客户端的最后一个ACK。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;第四次挥手(ACK=1，seq=u+1，ack=w+1)&lt;/strong&gt;
客户端接收到来自服务器端的关闭请求，发送一个确认包(在确认报文段中ACK=1，确认号ack=w+1，自己的序号seq=u+1)，并进入TIME_WAIT状态，等待可能出现的要求重传的ACK包。(这个确认包是内核进行发送的，上面不能发数据的是客户端的send函数)
服务器端接收到这个确认包之后，关闭连接，进入CLOSED状态。
客户端等待了某个固定时间（两个最大段生命周期，&lt;code&gt;2MSL&lt;/code&gt;（2 Maximum Segment Lifetime），即2个最长报文段寿命， &lt;code&gt;RFC 793&lt;/code&gt;中规定MSL为2分钟，而Linux中设置为30秒 ）之后，没有收到服务器端的ACK，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入CLOSED状态。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-四次挥手抓包分析&#34;&gt;3. 四次挥手抓包分析&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/4ZnKhodQpuNfmiE.png&#34; alt=&#34;四次挥手抓包分析&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;4-问题&#34;&gt;4. 问题&lt;/h2&gt;

&lt;h3 id=&#34;为什么会有time-wait状态&#34;&gt;为什么会有TIME_WAIT状态？&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;网络可能不可靠，需要确保有足够的时间让对方收到ACK包。被动关闭方处于&lt;code&gt;LAST_ACK&lt;/code&gt;状态下的&lt;code&gt;SOCKET&lt;/code&gt;可能会因为超时未收到ACK报文，而重发FIN报文（这一来一去正好是2SML）。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;避免新旧连接混淆。有的路由器会缓存IP数据包，如果连接被重用了，那么这些延迟收到的包就有可能会跟新连接混在一起。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;time-wait状态会带来的影响&#34;&gt;TIME_WAIT状态会带来的影响 ?&lt;/h3&gt;

&lt;p&gt;当某个连接的一端处于TIME_WAIT状态时，该连接将不能再被使用。事实上，对于我们比较有现实意义的是，这个端口将不能再被使用。&lt;/p&gt;

&lt;p&gt;某个端口处于TIME_WAIT状态(其实应该是这个连接)时，这意味着这个 TCP 连接并没有断开(完全断开)，那么，如果你bind这个端口，就会失败。对于服务器而言，如果服务器突然坏掉了，那么它将无法再2MSL内重新启动，因为bind会失败。&lt;/p&gt;

&lt;p&gt;解决这个问题的一个方法就是设置 socket 的&lt;code&gt;SO_REUSEADDR&lt;/code&gt;选项。这个选项意味着你可以重用一个地址。&lt;/p&gt;

&lt;h3 id=&#34;服务器出现大量close-wait状态的原因&#34;&gt;服务器出现大量CLOSE_WAIT状态的原因？&lt;/h3&gt;

&lt;p&gt;对方关闭socket连接，我方忙于读或写，没有及时关闭连接。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;检查代码，特别是释放资源的代码&lt;/li&gt;
&lt;li&gt;检查配置，特别是处理请求的线程配置&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以使用以下命令查看服务器是否有大量CLOSE_WAIT&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;netstat -n | awk &#39;/^tcp/{++S[$NF]}END{for(a in S) print a,S[a]}&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/5XsPjp2oZCmOngW.jpg&#34; alt=&#34;MacOS下的测试&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;为什么需要四次握手才能断开连接&#34;&gt;为什么需要四次握手才能断开连接？&lt;/h3&gt;

&lt;p&gt;因为全双工，发送方和接收方都需要FIN报文和ACK报文，当被动方收到主动方的FIN报文通知时，它仅仅表示主动方没有数据再发送给被动方了。但未必被动方所有的数据都完整的发送给了主动方，所以被动方不会马上关闭SOCKET，它可能还需要发送一些数据给主动方后，再发送FIN报文给主动方，告诉主动方同意关闭连接，所以这里的ACK报文和FIN报文多数情况下都是分开发送的。&lt;/p&gt;

&lt;p&gt;由于网络服务的不可靠性，必须考虑到在释放连接时，可能由于数据包的失序而使释放连接请求的数据包会比其他数据包先到达目的端。此时，如果目的端由于收到了释放连接请求的数据包而立即释放该连接，则会造成那些先发而后至的数据包丢失。&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TCP三次握手</title>
      <link>https://halklein.github.io/2019/006/</link>
      <pubDate>Thu, 31 Oct 2019 09:14:18 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/006/</guid>
      <description>

&lt;h2 id=&#34;1-tcp-transmission-control-protocol-传输控制协议&#34;&gt;1. TCP(Transmission Control Protocol)　传输控制协议&lt;/h2&gt;

&lt;p&gt;TCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接。&lt;/p&gt;

&lt;p&gt;TCP工作在网络 OSI 的七层模型中的第四层（Transport层），IP在第三层（Network层），ARP在第二层（Data Link层）；在第二层上的数据，我们把它叫Frame，在第三层上的数据叫Packet，第四层的数据叫Segment。 数据从应用层发下来，会在每一层都会加上头部信息，进行封装，然后再发送到数据接收端。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一种&lt;strong&gt;面向连接的、可靠的、基于字节流的&lt;/strong&gt;传输层通信协议&lt;/li&gt;
&lt;li&gt;将应用层的数据流分割成报文段并发送给目标节点的TCP层&lt;/li&gt;
&lt;li&gt;数据包都有序号，对方收到则发送ACK确认，未收到则重传&lt;/li&gt;
&lt;li&gt;使用校验和来检验数据在传输过程中是否有误&lt;/li&gt;
&lt;li&gt;在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP&lt;/li&gt;
&lt;li&gt;TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复&lt;/li&gt;
&lt;li&gt;TCP 使用&lt;strong&gt;滑动窗口机制&lt;/strong&gt;来实现流量控制，通过动态改变窗口的大小进行拥塞控制&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在进行数据传输之前，需要在传输数据的两端（客户端和服务器端）创建一个连接，这个连接由一对插口地址唯一标识，即是在IP报文首部的源IP地址、目的IP地址，以及TCP数据报首部的源端口地址和目的端口地址&lt;/p&gt;

&lt;h2 id=&#34;2-tcp头部结构&#34;&gt;2. TCP头部结构&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/dLhNgTlbYtBA3FW.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Source port&lt;/code&gt;源端口、&lt;code&gt;Destination port&lt;/code&gt;目的端口，他们各占用2个字节。TCP和UDP的数据包都是不包含IP地址信息的，因为那是IP层要处理的，但是TCP和UDP都会有源端口和目的端口。在计算机本地我们可以用PID唯一标识一个进程，但是在网络中不同计算机的进程可能会有相同的PID，可以通过在传输层中使用协议端口号来解决，这样我们就可以用 IP+协议+端口号来唯一标识网络中的一个进程.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Sequence Number&lt;/code&gt;序号：Seq序号，占4个字节，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。是包的序号，用来解决网络包乱序（reordering）问题。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Acknowledgement Number&lt;/code&gt;确认序号：Ack序号，占4个字节，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Data offset&lt;/code&gt;数据偏移：由于头部有可选字段长度不固定，因此它指出TCP报文的数据离TCP报文起始有多远。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Reserved&lt;/code&gt;保留域：保留以后使用的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;TCP Flags&lt;/code&gt; 标志位：常见的有6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;URG&lt;/code&gt; 紧急指针标志：为1时有效，为0则忽略。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ACK&lt;/code&gt; &lt;strong&gt;确认序号标志&lt;/strong&gt;：为1时确认号有效，为0标识报文中不含确认信息。 TCP 规定在连接建立后传送的所有报文段都必须把 ACK 置为一。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;PSH&lt;/code&gt; push标志：为1时，指示接收方接收到报文后应该尽快将这个报文交给应用层程序，而不是在缓冲区排队。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;RST&lt;/code&gt; 重置连接标志：重置连接，重置由于主机崩溃或其它原因而出现的异常连接，或者用于拒绝非法的报文段和拒绝连接请求。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SYN&lt;/code&gt; &lt;strong&gt;同步序号&lt;/strong&gt;：用于建立连接过程。 当SYN=1，ACK=0时，表示当前报文段是一个连接请求报文。当SYN=1，ACK=1时，表示当前报文段是一个同意建立连接的应答报文。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;FIN&lt;/code&gt; &lt;strong&gt;finish标志&lt;/strong&gt;：用于释放连接。为1时， 该字段为一表示此报文段是一个释放连接的请求报文&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Window Size&lt;/code&gt;窗口大小，指滑动窗口的大小，用于告知发送端接受方的缓存大小，以此控制发送端发送数据的速率从而进行流量控制 。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Checksum&lt;/code&gt;校验和，指奇偶校验，对整个TCP报文以16位进行计算所得，由发送端计算和存储并由接收端验证。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Urgent Pointer&lt;/code&gt; 紧急指针，当TCP Flags中的&lt;code&gt;URG&lt;/code&gt;为1时才有效，指出本TCP报文中紧急数据的字节数。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;TCP Options&lt;/code&gt; 可选项，其长度可变，定义一些其它的可选参数。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;3-tcp三次握手&#34;&gt;3. TCP三次握手&lt;/h2&gt;

&lt;p&gt;“握手”是为了&lt;strong&gt;建立连接&lt;/strong&gt;，TCP三次握手的流程图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/tbrGiOqwZ6Jpe3K.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;其中，前两次握手是不允许携带数据的，第三握手可以携带数据，如果第三次握手不携带数据就可以不消耗序号。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第一次握手&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;建立连接时， Client将标志位SYN置为1，随机产生一个值seq=x ， 并将该数据包发送给Server ，Client进入SYN_SEND状态，等待Server 确认；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第二次握手&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Server 收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1  ， ack=x+1 ，同时随机产生一个值seq=y ， 并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第三次握手&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Client收到Server的SYN+ACK包， 检查ack是否为y+1，标志位ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，seq=x+1， 并将该数据包发送给Server ;  Server检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;不要将确认序号ack与标志位中的ACK搞混了。&lt;/li&gt;
&lt;li&gt;确认方ack=发起方seq+1，两端配对。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-三次握手抓包分析&#34;&gt;4. 三次握手抓包分析&lt;/h2&gt;

&lt;p&gt;筛选过滤，将我们访问的地址作为筛选的 目标地址 和 源地址，筛选出 源地址 是因为三次握手中，访问的地址也会作为源地址向我们的计算机发送请求。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;ip.dst==61.128.252.10 or ip.src==61.128.252.10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/pbmqrR3fvd2xls4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;顺便查阅归纳下，&lt;strong&gt;Wireshark的过滤规则&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 过滤IP&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;ip.src eq 192.168.1.108 or ip.dst eq 192.168.1.108
或者ip.addr eq 192.168.1.107
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2. 过滤端口&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;tcp.port eq 80 //不管端口是源端口的还是目标端口都显示
tcp.port eq 80 or udp.port eq 80
tcp.dstport == 80 //只显tcp协议的目标端口80
tcp.srcport == 80 //只显tcp协议的源端口80
tcp.port &amp;gt;= 1 and tcp.port &amp;lt;= 80 //端口范围过滤
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3. 过滤协议&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;直接输入协议名：tcp、udp、arp、icmp、http、smtp、ftp、dns、msnms、ip、ssl、oicq、bootp等
排除协议过滤：如 !arp 或者 not arp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;4. 过滤MAC&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;eth.dst == 48:7d:2e:98:61:d1 或 eth.dst==48-7d-2e-98-61-d1 //过滤目标mac
eth.src eq 48:7d:2e:98:61:d1 //过滤来源mac
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;小于 less than（lt）&lt;/p&gt;

&lt;p&gt;等于 eq&lt;/p&gt;

&lt;p&gt;大于等于 ge&lt;/p&gt;

&lt;p&gt;不等 ne&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5. 包长度过滤&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;udp.length == 26 //这个长度是指udp本身固定长度8加上udp下面那块数据包之和
tcp.len &amp;gt;= 7   //指的是ip数据包(tcp下面那块数据),不包括tcp本身
ip.len == 94 //除了以太网头固定长度14,其它都算是ip.len,即从ip本身到最后
frame.len == 119 //整个数据包长度,从eth开始到最后
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;6. http模式过滤&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;例子:
http.request.method == “GET”
http.request.method == “POST”
http.request.uri == “/img/logo.png”
http contains “GET”
http contains “HTTP/1.”
http.request.method == “GET” &amp;amp;&amp;amp; http contains “Host: “

http.host == xxx.com	// 过滤 host
http.response == 1	// 过滤所有的 http 响应包
http.response.code == 302	// 过滤状态码 202
http.request.method==POST 	// 过滤 POST 请求包
http.cookie contains xxx	// cookie 包含 xxx
http.request.uri==&amp;quot;/robots.txt&amp;quot;	//过滤请求的uri，取值是域名后的部分
http.request.full_uri==&amp;quot;http://1.com&amp;quot;	// 过滤含域名的整个url
http.server contains &amp;quot;nginx&amp;quot;	//过滤http头中server字段含有nginx字符的数据包
http.content_type == &amp;quot;text/html&amp;quot;	//过滤content_type是text/html
http.content_encoding == &amp;quot;gzip&amp;quot;	//过滤content_encoding是gzip的http包
http.transfer_encoding == &amp;quot;chunked&amp;quot;	//根据transfer_encoding过滤
http.content_length == 279
http.content_length_header == &amp;quot;279&amp;quot;	//根据content_length的数值过滤
http.request.version == &amp;quot;HTTP/1.1&amp;quot;	//过滤HTTP/1.1版本的http包，包括请求和响应
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;5-问题&#34;&gt;5. 问题&lt;/h2&gt;

&lt;h3 id=&#34;为什么需要三次握手才能建立起连接&#34;&gt;为什么需要三次握手才能建立起连接&lt;/h3&gt;

&lt;p&gt;为了初始化Sequence Number的初始值，通信双方要互相通知对方自己的Sequence Number，作为以后数据通信的序号，以保证接收到的数据不会因为网络上的问题而乱序，即TCP会用这个序号来拼接数据， 确保数据能够完整传输。&lt;/p&gt;

&lt;h3 id=&#34;首次握手的隐患-syn超时&#34;&gt;首次握手的隐患&amp;ndash;SYN超时&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;原因&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;三次握手过程中，Server收到Client的SYN，回复SYN-ACK后（ Server收到Client的ACK之前的TCP连接称为半连接（&lt;code&gt;half-open connect&lt;/code&gt;），此时Server处于SYN_RCVD状态 ）， Cient就掉线了，Server端没有收到Client的ACK确认。 于是 Server会不断重试直到超时，在Linux系统中会默认进行5次重试（每次重试隔时间从1s开始每次都翻售 ，即1+2+4+6+8+16+32=63秒）TCP才断开连接。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SYN攻击&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，把Server的syn连接的队列耗尽 ，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;检测&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以可以查看&lt;code&gt;SYN_RECV&lt;/code&gt;状态：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;# netstat -nap | grep SYN_RECV
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;针对SYN Flood的防护措施&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Linux下给了一个叫&lt;code&gt;tcp_syncookies&lt;/code&gt;的参数来应对这个事——当SYN队列满了后，TCP会通过源地址端口、目标地址端口和时间戳打造出一个特别的&lt;code&gt;Sequence Number&lt;/code&gt;发回去（又叫SYN Cookie），如果是攻击者则不会有响应，如果是正常连接，则会把这个 &lt;code&gt;SYN Cookie&lt;/code&gt;发回来，然后服务端可以通过cookie建连接（即使你不在SYN队列中）。请注意，慎用&lt;code&gt;tcp_syncookies&lt;/code&gt;来处理正常的大负载的连接的情况。因为，&lt;code&gt;synccookies&lt;/code&gt;是妥协版的TCP协议，并不严谨。 对于正常的请求，可以调整以下三个参数：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;tcp_synack_retries&lt;/code&gt; ，用于减少重试次数；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tcp_max_syn_backlog&lt;/code&gt;，用于增大SYN连接数；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tcp_abort_on_overflow&lt;/code&gt; ，处理不过来，直接拒绝连接了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;保活机制&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果建立连接后，Client出现故障，向对方发送保活探测报文，如果未收到响应则继续发送，尝试次数达到保活探测数仍未收到响应则中断连接&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>OSI模型和TCP/IP模型</title>
      <link>https://halklein.github.io/2019/005/</link>
      <pubDate>Thu, 31 Oct 2019 09:06:36 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/005/</guid>
      <description>

&lt;h2 id=&#34;1-osi-开放式系统互联参考模型&#34;&gt;1. OSI 开放式系统互联参考模型&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;开放式系统互联模型&lt;/strong&gt;（英语：&lt;strong&gt;O&lt;/strong&gt;pen &lt;strong&gt;S&lt;/strong&gt;ystem &lt;strong&gt;I&lt;/strong&gt;nterconnection Model，缩写：OSI；简称为&lt;strong&gt;OSI模型&lt;/strong&gt;）是一种&lt;a href=&#34;https://zh.wikipedia.org/wiki/概念模型&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;概念模型&lt;/a&gt;，由&lt;a href=&#34;https://zh.wikipedia.org/wiki/国际标准化组织&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;国际标准化组织&lt;/a&gt;提出，一个试图使各种计算机在世界范围内互连为网络的标准框架。定义于ISO/IEC 7498-1。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/TLr5NUxWHKmJszP.gif&#34; alt=&#34;OSI 开放式系统互联参考模型&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;物理层-physical-layer&#34;&gt;物理层（Physical Layer）&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/N2o1gwMl95GfFsD.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在局部局域网上传送&lt;a href=&#34;https://zh.wikipedia.org/wiki/数据帧&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;数据帧&lt;/a&gt;（data frame），它负责管理电脑通信设备和网络媒体之间的互通， 定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率 ，主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换），这一层的数据叫做比特，单位是bit比特。包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机接口卡、 调制解调器等。典型的协议有 RS 232C、RS 449/422/423、V.24 和 X.21、X.21bis&lt;/p&gt;

&lt;h3 id=&#34;数据链路层-datalink-layer&#34;&gt;数据链路层&lt;strong&gt;（Datalink Layer）&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/oSpjkPZy9ftYGVa.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;定义了如何让格式化数据以进行传输，以及如何让控制对物理介质的访问，这一层通常还提供错误检测和纠正，以确保数据的可靠传输。交换机(二层)、网桥设备在这一层。数据链路层协议的代表包括： &lt;code&gt;HDLC&lt;/code&gt; 、&lt;code&gt;PPP&lt;/code&gt;、&lt;code&gt;STP&lt;/code&gt;等。&lt;/p&gt;

&lt;h3 id=&#34;网络层-network-layer&#34;&gt;网络层 &lt;strong&gt;（Network Layer）&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/wexCdOuZ2QH54B3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择，Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。网络层负责在源机器和目标机器之间建立它们所使用的路由。路由器在该层。协议有：&lt;code&gt;IP&lt;/code&gt;、&lt;code&gt;ICMP&lt;/code&gt;（互联网控制报文协议）、&lt;code&gt;ARP&lt;/code&gt;（地址转换协议）、&lt;code&gt;RARP&lt;/code&gt;（反向地址转换协议）&lt;/p&gt;

&lt;h3 id=&#34;传输层-transport-layer&#34;&gt;&lt;strong&gt;传输层（Transport Layer）&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/YQgGIThdiAEn23f.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;OSI 模型中最重要的一层。定义了一些传输数据的协议和端口号（WWW端口80等），如：&lt;code&gt;TCP&lt;/code&gt;（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），&lt;code&gt;UDP&lt;/code&gt;（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）， 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组，常常把这一层数据叫做段。&lt;/p&gt;

&lt;h3 id=&#34;会话层-session-layer&#34;&gt;&lt;strong&gt;会话层（Session Layer）&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/4hayBOXImwVbAct.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;负责在网络中的两节点之间建立、维持和终止通信。 会话层的功能包括：建立通信链接，保持会话过程通信链接的畅通，同步两个节点之间的对话，决定通信是否被中断以及通信中断时决定从何处重新发送。&lt;/p&gt;

&lt;p&gt;通过传输层（端口号：传输端口与接收端口）建立数据传输的通路，主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。&lt;/p&gt;

&lt;p&gt;常见的协议有 &lt;code&gt;ADSP&lt;/code&gt;、&lt;code&gt;RPC&lt;/code&gt; 等。&lt;/p&gt;

&lt;h3 id=&#34;表示层-presentation-layer&#34;&gt;&lt;strong&gt;表示层（Presentation Layer）&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/PRd9vurV1UCfqTw.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;应用程序和网络之间的翻译官，在表示层，数据将按照网络能理解的方案进行格式化；这种格式化也因所使用网络的类型不同而不同。表示层管理数据的解密与加密，如系统口令的处理。可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。 常见的协议有&lt;code&gt;ASCII&lt;/code&gt;、&lt;code&gt;SSL/TLS&lt;/code&gt; 等。&lt;/p&gt;

&lt;h3 id=&#34;应用层-application-layer&#34;&gt;&lt;strong&gt;应用层（Application Layer）&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/qTcn6Y3klSOetdN.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;是最靠近用户的OSI层，这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务 。常见的协议有 &lt;code&gt;HTTP&lt;/code&gt;，&lt;code&gt;FTP&lt;/code&gt;，&lt;code&gt;TELNET&lt;/code&gt;、&lt;code&gt;SMTP&lt;/code&gt; 等。&lt;/p&gt;

&lt;h3 id=&#34;osi模型-数据传输流程概览&#34;&gt;OSI模型 数据传输流程概览&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/peH8BVr75dWE34c.png&#34; alt=&#34;&#34; style=&#34;zoom:67%;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-tcp-ip四层网络模型&#34;&gt;2. TCP/IP四层网络模型&lt;/h2&gt;

&lt;h3 id=&#34;提出&#34;&gt;提出&lt;/h3&gt;

&lt;p&gt;OSI模型是一个定义良好的协议规范集，定义了开放系统的层次结构和之间的关系，但并没有提供一个可实现的方法，其并非一个标准，而是一个慨念型框架。TCP/IP是被广泛使用的OSI模型的实现。&lt;/p&gt;

&lt;h3 id=&#34;简介&#34;&gt;简介&lt;/h3&gt;

&lt;p&gt;TCP/IP协议栈是美国国防部高级研究计划局计算机网（Advanced Research Projects Agency Network，ARPANET）和其后继因特网使用的参考模型。ARPANET是由美国国防部（U.S．Department of Defense，DoD）赞助的研究网络。最初，它只连接了美国境内的四所大学。随后的几年中，它通过租用的电话线连接了数百所大学和政府部门。最终ARPANET发展成为全球规模最大的互连网络-因特网。最初的ARPANET于1990年永久性地关闭。&lt;/p&gt;

&lt;p&gt;TCP/IP是一组协议的代名词，它&lt;strong&gt;还包括许多协议，组成了TCP/IP协议簇&lt;/strong&gt;。TCP/IP协议簇分为四层，IP位于协议簇的第二层(对应OSI的第三层)，TCP位于协议簇的第三层(对应OSI的第四层)。&lt;/p&gt;

&lt;h3 id=&#34;层次&#34;&gt;层次&lt;/h3&gt;

&lt;p&gt;TCP/IP协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的网络来完成自己的需求。分别为：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;应用层&lt;/strong&gt;：应用程序间沟通的层，如简单电子邮件传输（SMTP）、文件传输协议（FTP）、网络远程访问协议（Telnet）等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;传输层&lt;/strong&gt;：在此层中，它提供了节点间的数据传送服务，如传输控制协议（TCP）、用户数据报协议（UDP）等，TCP和UDP给数据包加入传输数据并把它传输到下一层中，这一层负责传送数据，并且确定数据已被送达并接收。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;网络层&lt;/strong&gt;：负责提供基本的数据封包传送功能，让每一块数据包都能够到达目的主机（但不检查是否被正确接收），如网际协议（IP）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;网络接口层&lt;/strong&gt;：对实际的网络媒体的管理，定义如何使用实际网络（如Ethernet、Serial Line等）来传送数据。&lt;/p&gt;

&lt;h3 id=&#34;对应关系及协议整理&#34;&gt;对应关系及协议整理&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/Ip71j6NFub3Ugr5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;tcp-ip模型-数据传输流程概览&#34;&gt;TCP/IP模型 数据传输流程概览&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/NWbI9otOVEwkJaL.png&#34; alt=&#34;&#34; style=&#34;zoom:50%;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;3-问题&#34;&gt;3. 问题&lt;/h2&gt;

&lt;h3 id=&#34;交换机工作在osi的哪一层&#34;&gt;交换机工作在OSI的哪一层？&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;二层交换机&lt;/strong&gt; 工作在OSI的第二层数据链路层，，由于它们要对帧解码并使用帧信息将数据发送到正确的接收方，所以它们是工作在数据链路层的。
&lt;strong&gt;三层交换机&lt;/strong&gt; 是工作在OSI的网络层，因为三层交换机有路由功能。&lt;/p&gt;

&lt;h3 id=&#34;路由器工作在osi的哪一层&#34;&gt;路由器工作在OSI的哪一层？&lt;/h3&gt;

&lt;p&gt;路由器工作在OSI七层模型的第3层，网络层。由于网络层处理，并智能指导数据传送，路由器连接网络各段，所以路由器属于网络层。在网络中，“路由”是基于编址方案、使用模式以及可达性来指引数据的发送。 网络层负责在源机器和目标机器之间建立它们所使用的路由。&lt;/p&gt;

&lt;h3 id=&#34;ping命令使用osi哪一层协议&#34;&gt;PING命令使用OSI哪一层协议？&lt;/h3&gt;

&lt;p&gt;ping命令使用的是ICMP协议，位于OSI七层网络模型中的第三层，网络层。&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>采坑小记</title>
      <link>https://halklein.github.io/2019/002/</link>
      <pubDate>Tue, 15 Oct 2019 12:46:35 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/002/</guid>
      <description>

&lt;h2 id=&#34;1-提高-git-clone-的速度&#34;&gt;1. 提高 git clone 的速度&lt;/h2&gt;

&lt;p&gt;之前建博客的时候 git clone 感觉挺快的，现在找了几个项目练习有几十M大，发现git clone的速度就50k/s左右实在是受不了！自己是有小飞机的，开了全局代理，居然还是很慢&lt;/p&gt;

&lt;p&gt;最后找到原因：git 的代理要单独配置，命令如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;git config --global http.https://github.com.proxy socks5://127.0.0.1:1086
git config --global https.https://github.com.proxy socks5://127.0.0.1:1086
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;socks5代理端口在这里查看：&lt;/p&gt;

&lt;p&gt;MacOS 未知来源：sudo spctl &amp;ndash;master-disable&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·No End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>博客迁移 Hugo</title>
      <link>https://halklein.github.io/2019/001/</link>
      <pubDate>Thu, 10 Oct 2019 14:56:35 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/001/</guid>
      <description>&lt;p&gt;​       &lt;strong&gt;你眼中有春与秋，&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​       &lt;strong&gt;胜过我见过爱过的一切山川与河流；&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​       &lt;strong&gt;有一天我会懂你，&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​       &lt;strong&gt;也懂这世界悲欢，&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​       &lt;strong&gt;陪你走千帆，仍方寸不乱。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>算法比赛模板（一）</title>
      <link>https://halklein.github.io/2019/012/</link>
      <pubDate>Sat, 23 Mar 2019 21:47:12 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/012/</guid>
      <description>

&lt;h2 id=&#34;工具类&#34;&gt;工具类&lt;/h2&gt;

&lt;h3 id=&#34;线性筛素数&#34;&gt;线性筛素数&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;
#define SIZE 1000
int main()
{
	int	check[SIZE]	= { 0 };
	int	prime[SIZE]	= { 0 };
	int	pos		= 0;
	for ( int i = 2; i &amp;lt; SIZE; i++ )
	{
		/* 是素数 */
		if ( !check[i] )
			prime[pos++] = i;
		for ( int j = 0; j &amp;lt; pos &amp;amp;&amp;amp; i * prime[j] &amp;lt; SIZE; j++ )
		{
			/* 筛掉 */
			check[i * prime[j]] = 1;
			if ( i % prime[j] == 0 )
				break;
		}
	}
	for ( int i = 0; prime[i] != 0; i++ )
		printf( &amp;quot;%d &amp;quot;, prime[i] );
	return(0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;以文本作为c-的数据输入&#34;&gt;以文本作为C++的数据输入&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;freopen( &amp;quot;DATA.in&amp;quot;, &amp;quot;r&amp;quot;, stdin );
freopen( &amp;quot;DATA.out&amp;quot;, &amp;quot;w&amp;quot;, stdout );
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;星期计算公式&#34;&gt;星期计算公式&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;


/*
 * 基姆拉尔森：w=(d+2*m+3*(m+1)/5+y+y/4-y/100+y/400)%7
 * w：0:星期一...依此类推
 */
int cal1( int y, int m, int d )
{
	if ( m == 1 || m == 2 )
		m += 12, y--;
	int w = (d + 2 * m + 3 * (m + 1) / 5 + y + y / 4 - y / 100 + y / 400) % 7;
	/* 结果加 1，返回 星期一：1 ——到星期日：7 */
	return(++w);
}


int main()
{
	int y, m, d;
	scanf( &amp;quot;%d %d %d&amp;quot;, &amp;amp;y, &amp;amp;m, &amp;amp;d );
	int x = cal1( y, m, d );
	printf( &amp;quot;%dn&amp;quot;, x );
	return(0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;大数阶乘-java&#34;&gt;大数阶乘（Java）&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;import java.io.*;
import java.util.*;
import java.math.BigInteger;
public class Main {
	public static void main( String[] args )
	{
		Scanner		cin	= new Scanner( System.in );
		int		n	= cin.nextint();
		BigInteger	ans	= BigInteger.ONE;
		for ( int i = 1; i &amp;lt;= n; i++ )
			ans = ans.multiply( BigInteger.valueOf( i ) );
		System.out.println( ans );
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;全排列-函数&#34;&gt;全排列 函数&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;

int main()
{
    int num[8] = { 1, 2, 3, 4, 5, 6, 7, 8 };
    do
    {
        cout    &amp;lt;&amp;lt; num[0] &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; num[1] &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; num[2] &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; num[3] &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; num[4] &amp;lt;&amp;lt; &amp;quot; &amp;quot;
            &amp;lt;&amp;lt; num[5] &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; num[6] &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; num[7] &amp;lt;&amp;lt; endl;
    }
    while ( next_permutation( num, num + 8 ) ); /* 全排列函数 */

    return(0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;经典例题&#34;&gt;经典例题&lt;/h2&gt;

&lt;h3 id=&#34;说反话&#34;&gt;说反话&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;stack&amp;gt;
using namespace std;
int main()
{
	stack&amp;lt;string&amp;gt;	v;
	string		s;
	while ( cin &amp;gt;&amp;gt; s )
		v.push( s );
	/* 入站 */
	cout &amp;lt;&amp;lt; v.top();
	/* 站顶 */
	v.pop();
	/* 弹出站顶 */
	while ( !v.empty() )
	{
		cout &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; v.top();
		v.pop();
	}
	return(0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;悄悄关注&#34;&gt;悄悄关注&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * 新浪微博上有个“悄悄关注”，一个用户悄悄关注的人，不出现在这个用户的关注列表上，但系统会推送其悄悄关注的人发表的微博给该用户。现在我们来做一回网络侦探，根据某人的关注列表和其对其他用户的点赞情况，扒出有可能被其悄悄关注的人。
 * 输入格式：
 * 输入首先在第一行给出某用户的关注列表，格式如下：
 * 人数N 用户1 用户2 …… 用户N
 * 其中N是不超过5000的正整数，每个“用户i”（i=1, ..., N）是被其关注的用户的ID，是长度为4位的由数字和英文字母组成的字符串，各项间以空格分隔。
 * 之后给出该用户点赞的信息：首先给出一个不超过10000的正整数M，随后M行，每行给出一个被其点赞的用户ID和对该用户的点赞次数（不超过1000），以空格分隔。注意：用户ID是一个用户的唯一身份标识。题目保证在关注列表中没有重复用户，在点赞信息中也没有重复用户。
 * 输出格式：
 * 我们认为被该用户点赞次数大于其点赞平均数、且不在其关注列表上的人，很可能是其悄悄关注的人。根据这个假设，请你按用户ID字母序的升序输出可能是其悄悄关注的人，每行1个ID。如果其实并没有这样的人，则输出“Bing Mei You”。
 */
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;map&amp;gt;
using namespace std;

/* 结构体数组 */
struct pepole
{
    char    name[20];
    int    num;
}
peoples[10001];

/* 结构体排序 */
bool cmp( pepole x, pepole y )
{
    return(x.name &amp;gt; y.name); /*按姓名排序 */
}


int main()
{
    int            n, num;
    double            sum = 0;
    char            a[20];
    map&amp;lt;string, int&amp;gt;    m;

    cin &amp;gt;&amp;gt; n;
    for ( int i = 0; i &amp;lt; n; i++ )
    {
        cin &amp;gt;&amp;gt; a;
        m[a] = 1; /* map键值对赋值 */
    }

    cin &amp;gt;&amp;gt; num;
    for ( int i = 0; i &amp;lt; num; i++ )
    {
        scanf( &amp;quot;%s %d&amp;quot;, &amp;amp;peoples[i].name, &amp;amp;peoples[i].num );
        sum += peoples[i].num;
    }
    sort( peoples, peoples + num, cmp ); /* 自定义排序 */
    sum /= num;

    int flag = 1;
    for ( int i = 0; i &amp;lt; num; i++ )
    {
        /* 大于平均值 且 不在关注列表中 */
        if ( peoples[i].num &amp;gt; sum &amp;amp;&amp;amp; m[peoples[i].name] == 0 )
            printf( &amp;quot;%sn&amp;quot;, peoples[i].name ), flag = 0;
    }
    if ( flag )
        printf( &amp;quot;Bing Mei Youn&amp;quot; );

    return(0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;括号配对&#34;&gt;括号配对&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;stack&amp;gt;
using namespace std;
int main()
{
	int t, len;
	scanf( &amp;quot;%d&amp;quot;, &amp;amp;t );
	getchar();
	while ( t-- )
	{
		char		s[10010];
		stack&amp;lt;char&amp;gt;	m;
		gets( s );
		len = strlen( s );
		m.push( s[0] );
		for ( int i = 1; i &amp;lt; len; i++ )
		{
			if ( m.size() == 0 )
				m.push( s[i] );
			else{
				if ( m.top() == &#39;(&#39; &amp;amp;&amp;amp; s[i] == &#39;)&#39; )
					m.pop();
				else if ( m.top() == &#39;[&#39; &amp;amp;&amp;amp; s[i] == &#39;]&#39; )
					m.pop();
				else
					m.push( s[i] );
			}
		}
		if ( m.empty() )
			printf( &amp;quot;Yes\n&amp;quot; );
		else
			printf( &amp;quot;No\n&amp;quot; );
	}
	return(0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>为何要探索宇宙？</title>
      <link>https://halklein.github.io/2018/019/</link>
      <pubDate>Mon, 05 Nov 2018 19:22:46 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2018/019/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/12/9d3HBgXPO5yWfDK.jpg&#34; alt=&#34;From NASA&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;星际穿越&#34;&gt;星际穿越&lt;/h2&gt;

&lt;p&gt;看过多遍《星际穿越》，对我个人而言这是这是最喜欢的电影之一。
每次看完都会有无限的遐想，想着人类的博大，仰望星辰却又发现是如此渺小，不过是苍茫宇宙中的微微尘埃。
电影中更深层次表达的‘爱’，更是穿越时间与空间的强大力量，是人类最珍贵的不可丢失的东西。&lt;/p&gt;

&lt;h2 id=&#34;全球还有这么多的孩子遭受饥饿等威胁-人类为何还要探索宇宙&#34;&gt;全球还有这么多的孩子遭受饥饿等威胁，人类为何还要探索宇宙。&lt;/h2&gt;

&lt;p&gt;所以看到了一篇文章NASA对该问题发表的回信。故事背景：1970年，赞比亚修女 Mary Jucunda 给 Ernst Stuhlinger 博士写了一封信（他因在火星之旅工程中的原创性研究，成为 NASA（美国航空航天局）Marshall 太空航行中心的科学副总监）。信中，Mary Jucunda 修女问道：目前地球上还有这么多小孩子吃不上饭，他怎么能舍得为远在火星的项目花费数十亿美元。
&lt;a href=&#34;http://www.lettersofnote.com/2012/08/why-explore-space.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;原文链接&lt;/a&gt;
参考豆瓣&lt;a href=&#34;https://www.douban.com/note/230189968/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;kelejiabing&lt;/a&gt;大佬的翻译&lt;/p&gt;

&lt;h2 id=&#34;以下誊抄备份&#34;&gt;以下誊抄备份：&lt;/h2&gt;

&lt;p&gt;In 1970, a Zambia-based nun named Sister Mary Jucunda wrote to Dr. Ernst Stuhlinger, then-associate director of science at NASA&amp;rsquo;s Marshall Space Flight Center, in response to his ongoing research into a piloted mission toMars. Specifically, she asked how he could suggest spending billions of dollars on such a project at a time when so many children were starving on Earth.&lt;/p&gt;

&lt;p&gt;1970年，赞比亚修女 Mary Jucunda 给 Ernst Stuhlinger 博士写了一封信，他因在火星之旅工程中的原创性研究，成为NASA（美国航空航天局）Marshall 太空航行中心的科学副总监。信中，Mary Jucunda修女问道：目前地球上还有这么多小孩子吃不上饭，他怎么能舍得为远在火星的项目花费数十亿美元。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Stuhlinger soon sent the following letter of explanation to Sister Jucunda, along with a copy of &amp;ldquo;Earthrise,&amp;rdquo; the iconic photograph of Earth taken in 1968 by astronaut William Anders, from the Moon (also embedded in the transcript). His thoughtful reply was later published by NASA, and titled, &amp;ldquo;Why Explore Space?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Stuhlinger 很快给 Jucunda 修女回了信，同时还附带了一张题为“升起的地球”的照片，这张标志性的照片是宇航员William Anders 于1968年 在月球轨道上拍摄的（照片中可以看到月球的地面）。他这封真挚的回信随后由NASA以《为什么要探索宇宙》为标题发表。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;May 6, 1970&lt;br/&gt;
1970年5月6日&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Dear Sister Mary Jucunda:&lt;br/&gt;
亲爱的 Mary Jucunda 修女：&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Your letter was one of many which are reaching me every day, but it has touched me more deeply than all the others because it came so much from the depths of a searching mind and a compassionate heart. I will try to answer your question as best as I possibly can.&lt;/p&gt;

&lt;p&gt;每天，我都会收到很多类似的来信，但这封对我的触动最深，因为它来自一颗慈悲的饱含探求精神的心灵  。我会尽自己所能来回答你这个问题。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;First, however, I would like to express my great admiration for you, and for all your many brave sisters, because you are dedicating your lives to the noblest cause of man: help for his fellowmen who are in need.&lt;/p&gt;

&lt;p&gt;首先，请允许我向你以及你勇敢的姐妹们表达深深的敬意，你们献身于人类最崇高的事业：帮助身处困境的同胞。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;You asked in your letter how I could suggest the expenditures of billions of dollars for a voyage to Mars, at a time when many children on this Earth are starving to death. I know that you do not expect an answer such as &amp;ldquo;Oh, I did not know that there are children dying from hunger, but from now on I will desist from any kind of space research until mankind has solved that problem!&amp;rdquo; In fact, I have known of famined children long before I knew that a voyage to the planet Mars is technically feasible. However, I believe, like many of my friends, that travelling to the Moon and eventually to Mars and to other planets is a venture which we should undertake now, and I even believe that this project, in the long run, will contribute more to the solution of these grave problems we are facing here on Earth than many other potential projects of help which are debated and discussed year after year, and which are so extremely slow in yielding tangible results.&lt;/p&gt;

&lt;p&gt;在来信中，你问我在目前地球上还有儿童由于饥饿面临死亡威胁的情况下，为什么还要花费数十亿美元来进行飞向火星的航行。 我清楚你肯定不希望这样的答案：“哦，我之前不知道还有小孩子快饿死了，好吧，从现在开始，暂停所有的太空项目，直到孩子们都吃上饭再说。”事实上，早在了解火星之旅的技术之前，我已经对儿童的饥荒问题有所了解。而且，同我很多朋友的看法一样，我认为此时此刻，我们就应该开始通往月球、火星乃至其他行星的伟大探险。从长远来看，相对于那些要么只有年复一年的辩论和争吵，要么连妥协之后也迟迟无法落实的各种援助计划来说，我甚至觉得探索太空的工程给更有助于解决人类目前所面临的种种危机。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Before trying to describe in more detail how our space program is contributing to the solution of our Earthly problems, I would like to relate briefly a supposedly true story, which may help support the argument. About 400 years ago, there lived a count in a small town in Germany. He was one of the benign counts, and he gave a large part of his income to the poor in his town. This was much appreciated, because poverty was abundant during medieval times, and there were epidemics of the plague which ravaged the country frequently. One day, the count met a strange man. He had a workbench and little laboratory in his house, and he labored hard during the daytime so that he could afford a few hours every evening to work in his laboratory. He ground small lenses from pieces of glass; he mounted the lenses in tubes, and he used these gadgets to look at very small objects. The count was particularly fascinated by the tiny creatures that could be observed with the strong magnification, and which he had never seen before. He invited the man to move with his laboratory to the castle, to become a member of the count&amp;rsquo;s household, and to devote henceforth all his time to the development and perfection of his optical gadgets as a special employee of the count.&lt;/p&gt;

&lt;p&gt;在详细说明我们的太空项目如何帮助解决地面上的危机之前，我想先简短讲一个真实的故事。那是在400年前，德国某小镇里有一位伯爵。他是个心地善良的人，他将自己收入的一大部分捐给了镇子上的穷人。这十分令人钦佩，因为中世纪时穷人很多，而且那时经常爆发席卷全国的瘟疫。一天，伯爵碰到了一个奇怪的人，他家中有一个工作台和一个小实验室，他白天卖力工作，每天晚上的几小时的时间专心进行研究。他把小玻璃片研磨成镜片，然后把研磨好的镜片装到镜筒里，用此来观察细小的物件。伯爵被这个前所未见的可以把东西放大观察的小发明迷住了。他邀请这个怪人住到了他的城堡里，作为伯爵的门客，此后他可以专心投入所有的时间来研究这些光学器件。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;The townspeople, however, became angry when they realized that the count was wasting his money, as they thought, on a stunt without purpose. &amp;ldquo;We are suffering from this plague,&amp;rdquo; they said, &amp;ldquo;while he is paying that man for a useless hobby!&amp;rdquo; But the count remained firm. &amp;ldquo;I give you as much as I can afford,&amp;rdquo; he said, &amp;ldquo;but I will also support this man and his work, because I know that someday something will come out of it!&amp;rdquo;&lt;/p&gt;

&lt;p&gt;然而，镇子上的人得知伯爵在这么一个怪人和他那些无用的玩意儿上花费金钱之后，都很生气，“我们还在受瘟疫的苦”，他们抱怨道，“而他却为那个闲人和他没用的爱好乱花钱！”伯爵听到后不为所动，“我会尽可能地接济大家”，他表示，“但我会继续资助这个人和他的工作，我确信终有一天会有回报。”&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Indeed, something very good came out of this work, and also out of similar work done by others at other places: the microscope. It is well known that the microscope has contributed more than any other invention to the progress of medicine, and that the elimination of the plague and many other contagious diseases from most parts of the world is largely a result of studies which the microscope made possible.&lt;/p&gt;

&lt;p&gt;果不其然，他的工作赢来了丰厚的回报：显微镜。显微镜的发明给医学带来了前所未有的发展，由此展开的研究及其成果，消除了世界上大部分地区肆虐的瘟疫和其他一些传染性疾病。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;The count, by retaining some of his spending money for research and discovery, contributed far more to the relief of human suffering than he could have contributed by giving all he could possibly spare to his plague-ridden community.&lt;/p&gt;

&lt;p&gt;伯爵为支持这项研究发明所花费的金钱，其最终结果大大减轻了人类所遭受的苦难，这回报远远超过单纯将这些钱用来救济那些遭受瘟疫的人。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;The situation which we are facing today is similar in many respects. The President of the United States is spending about 200 billion dollars in his yearly budget. This money goes to health, education, welfare, urban renewal, highways, transportation, foreign aid, defense, conservation, science, agriculture and many installations inside and outside the country. About 1.6 percent of this national budget was allocated to space exploration this year. The space program includes Project Apollo, and many other smaller projects in space physics, space astronomy, space biology, planetary projects, Earth resources projects, and space engineering. To make this expenditure for the space program possible, the average American taxpayer with 10,000 dollars income per year is paying about 30 tax dollars for space. The rest of his income, 9,970 dollars, remains for his subsistence, his recreation, his savings, his other taxes, and all his other expenditures.&lt;/p&gt;

&lt;p&gt;我们目前面临类似的问题。美国总统的年度预算共有2000亿美元，这些钱将用于医疗、教育、福利、城市建设、高速公路、交通运输、海外援助、国防、环保、科技、农业以及其他多项国内外的工程。今年，预算中的1.6%将用于探索宇宙，这些花销将用于阿波罗以计划、其他一些涵盖了天体物理学、深空天文学、空间生物学、行星探测工程、地球资源工程的小项目以及空间工程技术。为担负这些太空项目的支出，平均每个年收入10,000美元的美国纳税人需要支付约30美元给太空，剩下的9,970美元则可用于一般生活开支、休闲娱乐、储蓄、别的税项等花销。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;You will probably ask now: &amp;ldquo;Why don&amp;rsquo;t you take 5 or 3 or 1 dollar out of the 30 space dollars which the average American taxpayer is paying, and send these dollars to the hungry children?&amp;rdquo; To answer this question, I have to explain briefly how the economy of this country works. The situation is very similar in other countries. The government consists of a number of departments (Interior, Justice, Health, Education and Welfare, Transportation, Defense, and others) and the bureaus (National Science Foundation, National Aeronautics and Space Administration, and others). All of them prepare their yearly budgets according to their assigned missions, and each of them must defend its budget against extremely severe screening by congressional committees, and against heavy pressure for economy from the Bureau of the Budget and the President. When the funds are finally appropriated by Congress, they can be spent only for the line items specified and approved in the budget.&lt;/p&gt;

&lt;p&gt;也许你会问：“为什么不从纳税人为太空支付的30美元里抽出5美元或3美元或是1美元来救济饥饿的儿童呢？”为了回答这个问题，我需要先简单解释一下我们国家的经济是如何运行的，其他国家也是类似的情形。政府由几个部门（如内政部、司法部、卫生部与公众福利部、教育部、运输部、国防部等）和几个机构（国家科学基金会、国家航空航天局等）组成，这些部门和机构根据自己的职能制定相应的年度预算，并严格执行以应对国务委员会的监督，同时还要应付来自预算部门和总统对于其经济效益的压力。当资金最终由国会拨出后，将严格用于经预算批准的计划中的项目。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;The budget of the National Aeronautics and Space Administration, naturally, can contain only items directly related to aeronautics and space. If this budget were not approved by Congress, the funds proposed for it would not be available for something else; they would simply not be levied from the taxpayer, unless one of the other budgets had obtained approval for a specific increase which would then absorb the funds not spent for space. You realize from this brief discourse that support for hungry children, or rather a support in addition to what the United States is already contributing to this very worthy cause in the form of foreign aid, can be obtained only if the appropriate department submits a budget line item for this purpose, and if this line item is then approved by Congress.&lt;/p&gt;

&lt;p&gt;显然，NASA的预算中所包含的项目都是和航空航天有关的。未经国会批准的预算项目，是不会得到资金支持的，自然也不会被课税，除非有其他部门的预算涵盖了该项目，借此花掉没有分配给太空项目的资金。由这段简短的说明可以看出，要想援助饥饿的儿童，或在美国已有的对外援助项目上增加援助金额，需要首先由相关部门提出预算，然后由国会批准才行。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;You may ask now whether I personally would be in favor of such a move by our government. My answer is an emphatic yes. Indeed, I would not mind at all if my annual taxes were increased by a number of dollars for the purpose of feeding hungry children, wherever they may live.&lt;/p&gt;

&lt;p&gt;要问是否同意政府实施类似的政策，我个人的意见是绝对赞成。我完全不介意每年多付出一点点税款来帮助饥饿的儿童，无论他们身在何处。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;I know that all of my friends feel the same way. However, we could not bring such a program to life merely by desisting from making plans for voyages to Mars. On the contrary, I even believe that by working for the space program I can make some contribution to the relief and eventual solution of such grave problems as poverty and hunger on Earth. Basic to the hunger problem are two functions: the production of food and the distribution of food. Food production by agriculture, cattle ranching, ocean fishing and other large-scale operations is efficient in some parts of the world, but drastically deficient in many others. For example, large areas of land could be utilized far better if efficient methods of watershed control, fertilizer use, weather forecasting, fertility assessment, plantation programming, field selection, planting habits, timing of cultivation, crop survey and harvest planning were applied.&lt;/p&gt;

&lt;p&gt;我相信我的朋友们也会持相同的态度。然而，事情并不是仅靠把去往火星航行的计划取消就能轻易实现的。相对的，我甚至认为可以通过太空项目，来为缓解乃至最终解决地球上的贫穷和饥饿问题作出贡献。解决饥饿问题的关键有两部分：食物的生产和食物的发放。食物的生产所涉及的农业、畜牧业、渔业及其他大规模生产活动在世界上的一些地区高效高产，而在有的地区则产量严重不足。通过高科技手段，如灌溉管理，肥料的使用，天气预报，产量评估，程序化种植，农田优选，作物的习性与耕作时间选择，农作物调查及收割计划，可以显著提高土地的生产效率。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;The best tool for the improvement of all these functions, undoubtedly, is the artificial Earth satellite. Circling the globe at a high altitude, it can screen wide areas of land within a short time; it can observe and measure a large variety of factors indicating the status and condition of crops, soil, droughts, rainfall, snow cover, etc., and it can radio this information to ground stations for appropriate use. It has been estimated that even a modest system of Earth satellites equipped with Earth resources, sensors, working within a program for worldwide agricultural improvements, will increase the yearly crops by an equivalent of many billions of dollars.&lt;/p&gt;

&lt;p&gt;人造地球卫星无疑是改进这两个关键问题最有力的工具。在远离地面的运行轨道上，卫星能够在很短的时间里扫描大片的陆地，可以同时观察计算农作物生长所需要的多项指标，土壤、旱情、雨雪天气等等，并且可以将这些信息广播至地面接收站以便做进一步处理。据估算，配备有土地资源传感器及相应的农业程序的人造卫星系统，即便是最简单的型号，也能给农作物的年产量带来数以十亿美元计的提升。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;The distribution of the food to the needy is a completely different problem. The question is not so much one of shipping volume, it is one of international cooperation. The ruler of a small nation may feel very uneasy about the prospect of having large quantities of food shipped into his country by a large nation, simply because he fears that along with the food there may also be an import of influence and foreign power. Efficient relief from hunger, I am afraid, will not come before the boundaries between nations have become less divisive than they are today. I do not believe that space flight will accomplish this miracle over night. However, the space program is certainly among the most promising and powerful agents working in this direction.&lt;/p&gt;

&lt;p&gt;如何将食品发放给需要的人则是另外一个全新的问题，关键不在于轮船的容量，而在于国际间的合作。小国统治者对于来自大国的大量食品的输入很难做出准确的判断，他们害怕伴随着食物一同而来的还有外国势力对其统治地位的影响。恐怕在国与国之间消除隔阂之前，饥饿问题无法得以高效解决了。我不认为太空计划能一夜之间创造奇迹，然而，探索宇宙有助于促使问题向着良好的方向发展。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Let me only remind you of the recent near-tragedy of Apollo 13. When the time of the crucial reentry of the astronauts approached, the Soviet Union discontinued all Russian radio transmissions in the frequency bands used by the Apollo Project in order to avoid any possible interference, and Russian ships stationed themselves in the Pacific and the Atlantic Oceans in case an emergency rescue would become necessary. Had the astronaut capsule touched down near a Russian ship, the Russians would undoubtedly have expended as much care and effort in their rescue as if Russian cosmonauts had returned from a space trip. If Russian space travelers should ever be in a similar emergency situation, Americans would do the same without any doubt.&lt;/p&gt;

&lt;p&gt;以最近发生的阿波罗13号事故为例。当宇航员处于关键的大气层再入期时，为了保证通讯畅通，苏联关闭了境内与阿波罗飞船所用频带相同的所有广播通信。同时派出舰艇到太平洋和大西洋海域以备第一时间进行搜救工作。如果宇航员的救生舱降落到俄方舰船附近，俄方人员会像对待从太空返回的本国宇航员一样对他们进行救助。同样，如果俄方的宇宙飞船遇到了类似的紧急情况，美国也一定会毫不犹豫地提供援助。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Higher food production through survey and assessment from orbit, and better food distribution through improved international relations, are only two examples of how profoundly the space program will impact life on Earth. I would like to quote two other examples: stimulation of technological development, and generation of scientific knowledge.&lt;/p&gt;

&lt;p&gt;通过卫星进行监测与分析来提高食品产量，以及通过改善国际关系提高食品发放的效率，只是通过太空项目提高人类生活质量的两个方面。下面我想介绍另外两个重要作用：促进科学技术的发展和提高一代人的科学素养。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;The requirements for high precision and for extreme reliability which must be imposed upon the components of a moon-travelling spacecraft are entirely unprecedented in the history of engineering. The development of systems which meet these severe requirements has provided us a unique opportunity to find new material and methods, to invent better technical systems, to manufacturing procedures, to lengthen the lifetimes of instruments, and even to discover new laws of nature&lt;/p&gt;

&lt;p&gt;.登月工程需要历史上前所未有的高精度和高可靠性。面对如此严苛的要求，我们要寻找新材料，新方法；开发出更好的工程系统；用更可靠的制作流程；让仪器的工作寿命更长久；甚至需要探索全新的自然规律。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;All this newly acquired technical knowledge is also available for application to Earth-bound technologies. Every year, about a thousand technical innovations generated in the space program find their ways into our Earthly technology where they lead to better kitchen appliances and farm equipment, better sewing machines and radios, better ships and airplanes, better weather forecasting and storm warning, better communications, better medical instruments, better utensils and tools for everyday life. Presumably, you will ask now why we must develop first a life support system for our moon-travelling astronauts, before we can build a remote-reading sensor system for heart patients. The answer is simple: significant progress in the solutions of technical problems is frequently made not by a direct approach, but by first setting a goal of high challenge which offers a strong motivation for innovative work, which fires the imagination and spurs men to expend their best efforts, and which acts as a catalyst by including chains of other reactions.&lt;/p&gt;

&lt;p&gt;这些为登月发明的新技术同样可以用于地面上的工程项目。每年，都有大概一千项从太空项目中发展出来的新技术被用于日常生活中，这些技术打造出更好的厨房用具和农场设备，更好的缝纫机和收音机，更好的轮船和飞机，更精确的天气预报和风暴预警，更好的通讯设施，更好的医疗设备，乃至更好的日常小工具。你可能会问为什么先设计出宇航员登月舱的维生系统，而不是先为听力障碍患者造出有声阅读设备呢。答案很简单：解决工程问题时，重要的技术突破往往并不是按部就班直接得到的，而是来自能够激发出强大创新精神，能够燃起的想象力和坚定的行动力，以及能够整合好所有资源的充满挑战的目标。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Spaceflight without any doubt is playing exactly this role. The voyage to Mars will certainly not be a direct source of food for the hungry. However, it will lead to so many new technologies and capabilities that the spin-offs from this project alone will be worth many times the cost of its implementation.&lt;/p&gt;

&lt;p&gt;太空旅行无可置疑地是一项充满挑战的事业。通往火星的航行并不能直接提供食物解决饥荒问题。然而，它所带来大量的新技术和新方法可以用在火星项目之外，这将产生数倍于原始花费的收益。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Besides the need for new technologies, there is a continuing great need for new basic knowledge in the sciences if we wish to improve the conditions of human life on Earth. We need more knowledge in physics and chemistry, in biology and physiology, and very particularly in medicine to cope with all these problems which threaten man&amp;rsquo;s life: hunger, disease, contamination of food and water, pollution of the environment.&lt;/p&gt;

&lt;p&gt;若希望人类生活得越来越好，除了需要新的技术，我们还需要基础科学不断有新的进展。包括物理学和化学，生物学和生理学，特别是医学，用来照看人类的健康，应对饥饿、疾病、食物和水的污染以及环境污染等问题。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;We need more young men and women who choose science as a career and we need better support for those scientists who have the talent and the determination to engage in fruitful research work. Challenging research objectives must be available, and sufficient support for research projects must be provided. Again, the space program with its wonderful opportunities to engage in truly magnificent research studies of moons and planets, of physics and astronomy, of biology and medicine is an almost ideal catalyst which induces the reaction between the motivation for scientific work, opportunities to observe exciting phenomena of nature, and material support needed to carry out the research effort.&lt;/p&gt;

&lt;p&gt;我们需要更多的年轻人投入到科学事业中来，我们需要给予那些投身科研事业的有天分的科学家更多的帮助。随时要有富于挑战的研究项目，同时要保证对项目给予充分的资源支持。在此我要重申，太空项目是科技进步的催化剂，它为学术研究工作提供了绝佳和实践机会，包括对月球和其他行星的研究、物理学和天文学、生物学和医学科学等学科，有它，科学界源源不断出现令人激动不已研究课题，人类得以窥见宇宙无比瑰丽的景象；为了它，新技术新方法不断涌现。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Among all the activities which are directed, controlled, and funded by the American government, the space program is certainly the most visible and probably the most debated activity, although it consumes only 1.6 percent of the total national budget, and 3 per mille (less than one-third of 1 percent) of the gross national product. As a stimulant and catalyst for the development of new technologies, and for research in the basic sciences, it is unparalleled by any other activity. In this respect, we may even say that the space program is taking over a function which for three or four thousand years has been the sad prerogative of wars.&lt;/p&gt;

&lt;p&gt;由美国政府控制并提供资金支持的所有活动中，太空项目无疑最引人瞩目也最容易引起争议，尽管其仅占全部预算的1.6%，不到全民生产总值的千分之三。作为新技术的驱动者和催化剂，太空项目开展了多项基础科学的研究，它的地位注定不同于其他活动。从某种意义上来说，以太空项目的对社会的影响，其地位相当于3-4千年前的战争活动。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;How much human suffering can be avoided if nations, instead of competing with their bomb-dropping fleets of airplanes and rockets, compete with their moon-travelling space ships! This competition is full of promise for brilliant victories, but it leaves no room for the bitter fate of the vanquished, which breeds nothing but revenge and new wars.&lt;/p&gt;

&lt;p&gt;如果国家之间不再比拼轰炸机和远程导弹，取而代之比拼月球飞船的性能，那将避免多少战乱之苦！聪慧的胜利者将满怀希望，失败者也不用饱尝痛苦，不再埋下仇恨的种子，不再带来复仇的战争。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Although our space program seems to lead us away from our Earth and out toward the moon, the sun, the planets, and the stars, I believe that none of these celestial objects will find as much attention and study by space scientists as our Earth. It will become a better Earth, not only because of all the new technological and scientific knowledge which we will apply to the betterment of life, but also because we are developing a far deeper appreciation of our Earth, of life, and of man.&lt;/p&gt;

&lt;p&gt;尽管我们开展的太空项目研究的东西离地球很遥远，已经将人类的视野延伸至月亮、至太阳、至星球、直至那遥远的星辰，但天文学家对地球的关注，超过以上所有天外之物。太空项目带来的不仅有那些新技术所所提供的生活品质的提升，随着对宇宙研究的深入，我们对地球，对生命，对人类自身的感激之情将越深。太空探索让地球更美好。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;Earthrise&lt;/p&gt;

&lt;p&gt;The photograph which I enclose with this letter shows a view of our Earth as seen from Apollo 8 when it orbited the moon at Christmas, 1968. Of all the many wonderful results of the space program so far, this picture may be the most important one. It opened our eyes to the fact that our Earth is a beautiful and most precious island in an unlimited void, and that there is no other place for us to live but the thin surface layer of our planet, bordered by the bleak nothingness of space. Never before did so many people recognize how limited our Earth really is, and how perilous it would be to tamper with its ecological balance. Ever since this picture was first published, voices have become louder and louder warning of the grave problems that confront man in our times: pollution, hunger, poverty, urban living, food production, water control, overpopulation. It is certainly not by accident that we begin to see the tremendous tasks waiting for us at a time when the young space age has provided us the first good look at our own planet.&lt;/p&gt;

&lt;p&gt;随信一块寄出的这张照片，是1968年圣诞节那天阿波罗8号在环月球轨道上拍摄的地球的景象。太空项目所能带来的各种结果中，这张照片也许是其中最可贵的一项。它开阔了人类的视野，让我们如此直观地感受到到地球是广阔无垠的宇宙中如此美丽而又珍贵的孤岛，同时让我们认识到地球是我们唯一的家园，离开地球就是荒芜阴冷的外太空。无论在此之前人们对地球的了解是多么的有限，对于破坏生态平衡的严重后果的认识是多么的不充分。在这张照片公开发表之后，面对人类目前所面临的种种严峻形势，如环境污染、饥饿、贫穷、过度城市化、粮食问题、水资源问题、人口问题等等，号召大家正视这些严重问题的呼声越来越多。人们突然表示出对自身问题的关注，不能说和目前正在进行的这些初期太空探索项目，以及它所带来的对于人类自身家园的全新视角无关。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Very fortunately though, the space age not only holds out a mirror in which we can see ourselves, it also provides us with the technologies, the challenge, the motivation, and even with the optimism to attack these tasks with confidence. What we learn in our space program, I believe, is fully supporting what Albert Schweitzer had in mind when he said: &amp;ldquo;I am looking at the future with concern, but with good hope.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;太空探索不仅仅给人类提供一面审视自己的镜子，它还能给我们带来全新的技术，全新的挑战和进取精神，以及面对严峻现实问题时依然乐观自信的心态。我相信，人类从宇宙中学到的，充分印证了Albert Schweitzer 那句名言：“我忧心忡忡地看待未来，但仍满怀美好的希望。 ”&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;My very best wishes will always be with you, and with your children.&lt;br/&gt;
向您和您的孩子们致以我最真挚的敬意。&lt;/p&gt;

&lt;p&gt;Very sincerely yours,&lt;br/&gt;
您诚挚的&lt;/p&gt;

&lt;p&gt;Ernst Stuhlinger&lt;br/&gt;
恩斯特 史都林格&lt;/p&gt;

&lt;p&gt;Associate Director for Science&lt;br/&gt;
科学副总监&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;原文链接：&lt;a href=&#34;http://www.lettersofnote.com/2012/08/why-explore-space.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.lettersofnote.com/2012/08/why-explore-space.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;翻译：&lt;a href=&#34;https://www.douban.com/note/230189968/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;kelejiabing&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>纪念姚贝儿诞辰37周年</title>
      <link>https://halklein.github.io/2018/014/</link>
      <pubDate>Wed, 26 Sep 2018 20:00:35 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2018/014/</guid>
      <description>&lt;p&gt;今天是2018年9月26日，一转眼，你离开我们已经三年半了&lt;/p&gt;

&lt;p&gt;我大概不是一个合格的粉丝，因为知道你的时候实在是太晚了。我一向是不爱看选秀娱乐节目的，2018年3月在家闲得无聊就回放了中国好声音；当听到你声音的时候我震惊了，好久没有听过这么纯粹干净而有力的声音了，每个字都清晰可见。当看到那个穿着牛仔裤、体恤衫、平底鞋，面上露出灿烂笑容的你时，感觉特别的自然亲切，一首 也许明天 ，那是我认识你的歌，惊叹于娇小身躯里蕴含的强大爆发力。
&lt;img src=&#34;https://i.loli.net/2019/12/09/rRJTVKZAuxjNlPq.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;2006年青歌赛亚军，2008年青歌赛史上唯一满分冠军的你本就具有常人所不及的实力，不需要选秀来证明自己。一开始我是很不理解的，感觉你在欺负对手，好声音的学员本来大部分就是业余歌手。带着太多的不解，我找了你很多资料，也终于明白了你，你不想待在海政文工团，那不是你梦想的地方；终于得了抑郁症的你在生命的最艰难的时刻，决定从军队中脱离了出来，想唱流行音乐，也想像那些歌手一样，站在舞台上，穿一身休闲装，吼得歇斯底里。而不是穿一身的军装，站的端庄典雅。而选秀节目当然是一个好机会。选秀无论有多少黑幕，那对你来说其实都不重要，你已经成功了，很多人都就此认识了你，如今好声音已经不存在了，而你虽已走，却活在了很多人心里。逐渐认识你之后，我发现自己曾经哼的许多歌，原来是你唱的，曾经惊讶于甄嬛传《红颜劫》的歌声，有时哼唱的《随他吧》、《如果我们没有遇见》还有好听的年欢晚会歌曲《天耀中华》原来都是你演唱的！
&lt;img src=&#34;https://i.loli.net/2019/12/09/G3e5BVgJDEK4hXL.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;有人说喜欢一个明星就是 &lt;strong&gt;始于颜值，陷于才华，忠于人品&lt;/strong&gt;  ；我觉得说得非常对了。我所理解的明星大都是利益的产物，大多演员都具有美丽的容颜，而歌手一般都比较有才华，但是他们大多源于利益又促进利益，很多人也渐渐追逐利益；真正谈得上人品的实在太少了。这也是我一直不追星的原因。&lt;/p&gt;

&lt;p&gt;喜欢你，始于你的音乐天赋。姚贝儿你应该算是人品好的，2015年1月16日下午16时55分，因乳腺癌复发，于北京大学深圳医院病逝，离世前，决定捐献眼角膜，如今这对眼角膜已经帮助三四名病者重现光明，成为深圳市第九百多例角膜捐献者。获得“广东好人”荣誉称号，并成为第五届全国道德模范广东省候选人。之后，家里拍卖了部分遗物，而所有的都捐到了新疆西藏等贫困地区用于修建爱心图书馆。是怎样的家庭才能培养出如此优秀善良的女儿呢？
&lt;img src=&#34;https://i.loli.net/2019/12/09/Z8CrSdtFXeG5Vpq.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;2015年4月9日，据国际天文学联合会（IAU）出版的小行星公告，将第41981号小行星被命名为“ &lt;strong&gt;姚贝娜星&lt;/strong&gt; ”（Yaobeina）。这也刚好对应了你1981出生日期。美国宇航局网站上这样介绍姚贝娜：姚贝娜（1981-2015），一位才华横溢又充满勇气的中国女歌手，曾因在流行音乐方面的造诣屡获奖项。她有一首歌叫做《心火》，讲述她与癌症抗争的故事。不幸离世后，她捐献出了自己的眼角膜。”，姚贝娜的“教父”、诗人、词作家&lt;strong&gt;唐跃生&lt;/strong&gt;为姚贝娜写了一首词，名为《女儿》：“有个女儿好比拥有许多自己，你代替我去穿越阳光风雨；如果有一天回到我身边，请全世界暂时离开你”。姚峰说，有了这颗姚贝娜星，他想把词中的“阳光风雨”改为“苍穹天宇”，要为它好好地谱个曲，再好好地唱出来。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;爸，我不怕死，&lt;/p&gt;

&lt;p&gt;可是我死了之后，爸爸妈妈怎么办！&lt;/p&gt;

&lt;p&gt;我的粉丝，他们对我太好了，&lt;/p&gt;

&lt;p&gt;如果我死了，他们一定会很伤心的，&lt;/p&gt;

&lt;p&gt;我对不起他们啊……&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如今你真的不在了，你可知，你走后，那段时间百度搜索你的名字都是灰色的；你走后，一颗小行星以你的名字命名，北京文艺频道三年为你制作纪念特辑，刘家昌老师发布了你的专辑《永存》所有收入都一样捐赠了，以你名义建立的爱心书屋越来越多，李玉刚老师还为你写了歌；做重要的是贝壳们一直想着你念着你，他们经常来石门峰看你，你的墓前一直鲜花不败，写给你的祝福挂满了长廊。贝壳将带你继续看这个美丽的世界。&lt;/p&gt;

&lt;p&gt;在此，怀着深深的不舍和敬意向你祝福：愿天堂没有病痛，愿你能在天堂继续快乐的歌唱，姚贝儿37岁生日快乐！
&lt;img src=&#34;https://i.loli.net/2019/12/09/6EyqfbwBzjoOeA4.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>给我未来的孩子 -- 文/张梅</title>
      <link>https://halklein.github.io/2018/017/</link>
      <pubDate>Sat, 15 Sep 2018 19:55:11 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2018/017/</guid>
      <description>&lt;p&gt;文/张梅&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/qRMeCtU9QsbB48j.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;孩子，我首先希望你自始至终都是一个理想主义者。你可以是农民，可以是工程师，可以是演员，可以是流浪汉，但你必须是个理想主义者。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;当你童年，我们讲英雄的故事给你听，并不是要你一定成为英雄，而是希望具有纯正的品格；当你少年，我们让你接触诗歌、绘画、音乐，是为了让你的心灵填满高尚的情趣。这些高尚的情趣会支撑你的一生，使你在最严酷的冬天也不会忘记玫瑰的芳香。理想会使人出众。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;孩子，不要为自己的外形担忧。理想纯洁你的气质，而最美貌的女人也会因为庸俗而令人生厌。通向理想的道路往往不尽人意，而你亦会为此受尽磨难。但是，孩子，你尽管去争取，理想主义者的结局悲壮而决不可怜。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;在那貌似坎坷的人生中，你会结识到许多智者和君子，你会见到许多旁人无法遇到的风景和奇迹。选择平庸虽稳妥，但绝无色彩。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;不要为蝇头小利放弃自己的理想，不要为某种潮流而放弃自己的信念。物质世界的外表太过复杂，你要懂得如何去拒绝虚荣的诱惑。理想不是实惠的东西，它往往无法带给你尘世的享受。因此你必须习惯无人欣赏你，学会精神享受，学会与他人不同。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;其次，孩子，我希望你是一个踏实的人。人生太过短促，而虚的东西又太多，你很容易眼花缭乱，最终一事无成。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;如果你是一个美貌的女孩子，年轻的时候会有许多男性宠你，你得到的东西过于容易，这会使你流于浅薄和虚浮；如果你是一个极聪明的男孩，又会以为自己能够成就许多大事而流于轻佻。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;记住，每个人的能力有限，我们活在世上做好一件事足矣。写好一本书，做好一个主妇。不要轻视平凡的人，不要投机取巧，不要攻击自己做不到的事。你长大后会知道，做好一件事太难，但绝不要放弃。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;你要懂得和珍惜感情。不管男人女人，不管墙内墙外，相交一场实在不容易。交友的过程会有误会和摩擦，但你想一想，偌大世界，能有缘结伴而行的又有几人？你要明白朋友终会离去，生活中能有人伴你在身边，听你倾谈，倾谈给你听，你就应该感激。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;要爱自己和爱他人，要懂自己和懂他人。你的心要如溪水般柔软，你的眼波要象春天般妩媚。你要会流泪，会孤身一人坐在黑暗中听伤感的音乐。你要懂得欣赏悲剧，悲剧能丰富你的心灵。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;希望你不要媚俗。你是个独立的人，无人能抹杀你的独立性，除非你向世俗妥协。要学会欣赏真，要在重重面具之下看到真。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;世上圆滑标准的人很多，但出类拔萃的人极少。而往往出类拔萃又隐藏在卑琐狂荡之下。在形式上，我们无法与既定的世俗争斗，而在内心，我们都是自己的国王。如果你的脸上出现谄媚的笑容，我将羞愧的掩脸而去。世俗许多东西虽耀眼却无价值，不要把自己置于大众的天平上，你会因此无所适从，人云亦云。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;在具体的做人上，我希望你不要打断别人的谈话，不要娇气十足。你每天至少拿出两小时来读书，不要想着别人为你做些什么，而要想着怎么去帮助他人。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;借他人的东西要还，不要随便接受别人的恩惠，要记住，别人的东西，再好也是别人的，自己的东西，再差也是自己的。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;还有一件事，虽然做起来很难，但相当重要，这就是要有勇气正视自己的缺点。你会一年年的长大，你渐渐会遇到比你强，比你优秀的人，你会发现自己身上有许多你所厌恶的缺点。这会使你沮丧和自卑。你一定要正视它，不要躲避，要一点一点的加以改正。战胜自己比征服他人还要艰巨和有意义。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;不管世界潮流如何变化，但人的优秀品质却是永恒的：正直，勇敢，独立。我希望你是一个优秀的人。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>