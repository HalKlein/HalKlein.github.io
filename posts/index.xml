<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on HalKlein`s Blog</title>
    <link>https://halklein.github.io/posts/</link>
    <description>Recent content in Posts on HalKlein`s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <managingEditor>dev.HalKlein@gmail.com (HalKlein)</managingEditor>
    <webMaster>dev.HalKlein@gmail.com (HalKlein)</webMaster>
    <lastBuildDate>Mon, 27 Jan 2020 19:11:39 +0800</lastBuildDate>
    <atom:link href="https://halklein.github.io/posts/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>IDEA引入fastjson依赖失败的解决办法</title>
      <link>https://halklein.github.io/2020/027/</link>
      <pubDate>Mon, 27 Jan 2020 19:11:39 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2020/027/</guid>
      <description>

&lt;h2 id=&#34;问题&#34;&gt;问题&lt;/h2&gt;

&lt;p&gt;今天学习异步消息，用到 FastJson 对 json 进行解析和生成，但是在 &lt;code&gt;pom.xml&lt;/code&gt; 中引入下面的依赖描述时，等待许久也无法下载完成。之后尝试进行科学上网，并开启全局代理，依然是下载失败或下载不完全。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;fastjson&amp;lt;/artifactId&amp;gt;
   &amp;lt;version&amp;gt;1.2.62&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;解决办法&#34;&gt;解决办法&lt;/h2&gt;

&lt;p&gt;1.在 &lt;a href=&#34;https://mvnrepository.com/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;MVNrepository&lt;/a&gt; 官网直接找到对应的 jar 包链接，&lt;a href=&#34;https://repo1.maven.org/maven2/com/alibaba/fastjson/1.2.62/fastjson-1.2.62.jar&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;点击进行下载&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/01/27/gOTSzU6IrYm1WtA.png&#34; alt=&#34;MVNrepository&#34; /&gt;&lt;/p&gt;

&lt;p&gt;2.找到下载jar包的所在目录，使用maven命令直接进行安装，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;mvn install:install-file -Dfile=E:\Download\Chrome\fastjson-1.2.62.jar -DgroupId=com.alibaba -DartifactId=fastjson -Dversion=1.2.62 -Dpackaging=jar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/01/27/2AB9iKW6RIdGCXT.png&#34; alt=&#34;对应参数&#34; /&gt;&lt;/p&gt;

&lt;p&gt;安装成功后显示存放路径&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/01/27/L4Hk3bv5F1CrwaM.png&#34; alt=&#34;安装成功&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后需要IDEA的设置中设置Maven引用的路径为该路径，重启IDEA，重新加载依赖，就可以成功了！&lt;/p&gt;

&lt;p&gt;PS：同理，其它的依赖应该也可以这样操作。&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>用前缀树过滤敏感词</title>
      <link>https://halklein.github.io/2020/026/</link>
      <pubDate>Mon, 27 Jan 2020 12:09:44 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2020/026/</guid>
      <description>

&lt;h3 id=&#34;前缀树&#34;&gt;&lt;strong&gt;前缀树&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;​   &lt;strong&gt;名称：&lt;/strong&gt;Trie、字典树、查找树&lt;/p&gt;

&lt;p&gt;​   &lt;strong&gt;特点：&lt;/strong&gt;查找效率高，消耗内存大&lt;/p&gt;

&lt;p&gt;​   &lt;strong&gt;应用：&lt;/strong&gt;字符串检索、词频统计、字符串排序等&lt;/p&gt;

&lt;h3 id=&#34;敏感词过滤器&#34;&gt;&lt;strong&gt;敏感词过滤器&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;​   定义前缀树根据敏感词&lt;/p&gt;

&lt;p&gt;​   初始化前缀树&lt;/p&gt;

&lt;p&gt;​   编写过滤敏感词的方法&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;简单的进行查找和replace替换无疑效率是非常低的，我们使用一种叫前缀树（Trie、字典树、查找树）的数据结构来实现高效过滤敏感词，数据结构及过滤图示如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/01/27/W93QTOZsYUSN6IB.png&#34; alt=&#34;过滤敏感词&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step1 定义敏感词文件sensitive-words.txt，放在resources目录下&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;VPN
翻墙
吸毒
开票
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Step2 敏感词过滤器&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 敏感词过滤器
@Component
public class SensitiveFilter {

    // 记录日志
    private static final Logger logger = LoggerFactory.getLogger(SensitiveFilter.class);

    // 替换符（检测到敏感词，替换为某符号，定义为常量）
    private static final String REPLACEMENT = &amp;quot;***&amp;quot;;

    // 初始化前缀树
    private TrieNode rootNode = new TrieNode();


    // @PostConstruct表示这是一个初始化方法，当容器实例化这个Bean以后在调用它的构造器之后这个方法就会被自动调用
    @PostConstruct
    public void init() {
        // 在classes路径下读取敏感词文件（需要先编译），获得字节流
        try (
                InputStream is = this.getClass().getClassLoader().getResourceAsStream(&amp;quot;sensitive-words.txt&amp;quot;);
                // 转为字符流，在转为缓冲流(效率会更高)
                BufferedReader reader = new BufferedReader(new InputStreamReader(is));
        ) {
            String keyword;
            while ((keyword = reader.readLine()) != null) {
                // 添加到前缀树中，这一步比较复杂，封装为一个方法
                this.addKeyword(keyword);
            }
        } catch (IOException e) {
            logger.error(&amp;quot;加载敏感词文件失败 : &amp;quot; + e.getMessage());
        }
    }

    // 将一个敏感词添加到前缀树中
    private void addKeyword(String keyword) {
        // 指针
        TrieNode tempNode = rootNode;
        for (int i = 0; i &amp;lt; keyword.length(); i++) {
            char c = keyword.charAt(i);
            TrieNode subNode = tempNode.getSubNode(c);
            if (subNode == null) {
                // 初始化子节点
                subNode = new TrieNode();
                tempNode.addSubNode(c, subNode);
            }

            // 让指针指向该子节点，进入下一轮循环
            tempNode = subNode;

            // 设置结束标识(到此为一个敏感词)
            if (i == keyword.length() - 1) {
                tempNode.setKeywordEnd(true);
            }
        }
    }


    /**
     * 过滤敏感词
     *
     * @param text 待过滤的文本
     * @return 过滤后的文本
     */
    public String filter(String text) {
        if (StringUtils.isBlank(text)) {
            return null;
        }

        // 指针1，指向前缀树
        TrieNode tempNode = rootNode;
        // 指针2，字符串指针
        int begin = 0;
        // 指针3，字符串指针
        int position = 0;
        // 记录生成的新字符串，使用可变长字符串
        StringBuilder sb = new StringBuilder();

        // 开始过滤
        while (position &amp;lt; text.length()) {
            char c = text.charAt(position);

            // 跳过符号，防止有的用户通过在敏感词中穿插各种符号来规避敏感词检测
            if (isSymbol(c)) {
                // 若指针1处于根节点，将此符号记入结果，让指针2向下走一步
                if (tempNode == rootNode) {
                    sb.append(c);
                    begin++;
                }
                // 无论符号在开头或中间，指针3都向下走一步
                position++;
                continue;
            }

            // 检查下级节点
            tempNode = tempNode.getSubNode(c);
            if (tempNode == null) {
                // 以begin为开头的字符串不是敏感词
                sb.append(text.charAt(begin));
                // 进入下一个位置
                position = ++begin;
                // 重新指向根节点
                tempNode = rootNode;
            } else if (tempNode.isKeywordEnd()) {
                // 发现了敏感词，将begin到position这段的字符串替换掉
                sb.append(REPLACEMENT);
                // 进入下一个位置
                begin = ++position;
                // 重新指向根节点
                tempNode = rootNode;
            } else {
                // 检查下一个字符
                position++;
            }
        }

        // 将最后一批字符计入结果
        sb.append(text.substring(begin));

        // 返回结果
        return sb.toString();
    }

    // 判断是否为符号
    private boolean isSymbol(Character c) {
        // 不是特殊符号，0x2E80到0x9FFF是东亚的文字范围
        return !CharUtils.isAsciiAlphanumeric(c) &amp;amp;&amp;amp; (c &amp;lt; 0x2E80 || c &amp;gt; 0x9FFF);
    }


    // 前缀树
    private class TrieNode {

        // 关键词结束标识
        private boolean isKeywordEnd = false;

        // 子节点(key是下级字符，value是下级节点)
        private Map&amp;lt;Character, TrieNode&amp;gt; subNodes = new HashMap&amp;lt;&amp;gt;();

        public boolean isKeywordEnd() {
            return isKeywordEnd;
        }

        public void setKeywordEnd(boolean keywordEnd) {
            isKeywordEnd = keywordEnd;
        }

        // 添加子节点
        public void addSubNode(Character c, TrieNode node) {
            subNodes.put(c, node);
        }

        //  获取子节点
        public TrieNode getSubNode(Character c) {
            return subNodes.get(c);
        }

    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Step3 过滤测试&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootTest
@ContextConfiguration(classes = CommunityApplication.class)
public class SensitiveTests {

    @Autowired
    private SensitiveFilter sensitiveFilter;

    @Test
    public void testSensitiveFilter(){
        String text = &amp;quot;我是敏感词，你来过滤我啊，测试VPN，测试翻墙，测试吸毒，测试开票，哈哈哈！&amp;quot;;
        System.out.println(sensitiveFilter.filter(text));

        text = &amp;quot;我是敏感词，你来过滤我啊，测试☆V☆P☆☆N☆，测试☆☆翻☆☆☆墙☆☆,☆测试☆吸☆☆毒☆☆☆，测试☆开☆☆票☆，哈哈哈！&amp;quot;;
        System.out.println(sensitiveFilter.filter(text));
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;我是敏感词，你来过滤我啊，测试***，测试***，测试***，测试***，哈哈哈！
我是敏感词，你来过滤我啊，测试☆***☆，测试☆☆***☆☆,☆测试☆***☆☆☆，测试☆***☆，哈哈哈！
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>常用的元注解</title>
      <link>https://halklein.github.io/2020/025/</link>
      <pubDate>Mon, 20 Jan 2020 20:35:11 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2020/025/</guid>
      <description>

&lt;h2 id=&#34;常用的元注解&#34;&gt;常用的元注解&lt;/h2&gt;

&lt;p&gt;当我们需要自定义注解时，要用到元注解定义我们自己的注解（所谓元注解，就是注解其它注解的注解），其中常见的元注解有以下四个：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;@Target&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;由于标识我们自定义注解的使用范围。从源码可以看到可以赋值为ElementType。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package java.lang.annotation;

@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.ANNOTATION_TYPE})
public @interface Target {
    ElementType[] value();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中ElementType定义如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public enum ElementType {
    TYPE,	// 类、接口、枚举类
    FIELD,	// 成员变量（包括：枚举常量）
    METHOD,	// 成员方法
    PARAMETER,	// 方法参数
    CONSTRUCTOR, 	// 构造方法
    LOCAL_VARIABLE,	// 局部变量
    ANNOTATION_TYPE,	// 注解类
    PACKAGE,	// 包
    TYPE_PARAMETER,	// 类型参数，JDK 1.8 新增
    TYPE_USE,	// 使用类型的任何地方，JDK 1.8 新增
    MODULE;	// 允许在模块上使用注解，JDK 1.9新增

    private ElementType() {
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@Retention&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用于说明自定义注解的有效时间或者说保留的时间（如：编译时有效、运行时有效等）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package java.lang.annotation;

@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.ANNOTATION_TYPE})
public @interface Retention {
    RetentionPolicy value();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;package java.lang.annotation;

public enum RetentionPolicy {
    SOURCE,	//源文件
    CLASS,	//编译时（默认）
    RUNTIME;	//运行时

    private RetentionPolicy() {
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@Document&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;声明在生成帮助文档的时候要不要把这个自定义注解信息也带上。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package java.lang.annotation;

@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.ANNOTATION_TYPE})
public @interface Documented {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@Inherited&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使被它修饰的自定义注解具有继承性。子类继承该自定义注解之后也具有该注解。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package java.lang.annotation;

@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.ANNOTATION_TYPE})
public @interface Inherited {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;PS&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一般来说，我们自定义注解，@Target和@Retention是都会用到的，用来指定作用的范围和时机&lt;/p&gt;

&lt;h2 id=&#34;如何读取注解&#34;&gt;如何读取注解&lt;/h2&gt;

&lt;p&gt;通过AnnotatedElement接口实现对自定义注解的解析&lt;/p&gt;

&lt;p&gt;Method.getDeclaredAnnotations（）
Method.getAnnotation（Class&lt;T&gt; annotationClass）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;看个例子：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;@Override
public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
    // 如果拦截到的是一个方法 : instanceof HandlerMethod
    if (handler instanceof HandlerMethod) {
        // 转型，方便获取内容
        HandlerMethod handlerMethod = (HandlerMethod) handler;
        Method method = handlerMethod.getMethod();
        // 取注解，取含有自定义注解：LoginRequired，的方法
        LoginRequired loginRequired = method.getAnnotation(LoginRequired.class);
        // 取注解后发现不为空，说明该方法需要登录才能访问，并且检测不到当前用户
        if (loginRequired != null &amp;amp;&amp;amp; hostHolder.getUser() == null) {
            // 使用response重定向到登录页
            response.sendRedirect(request.getContextPath() + &amp;quot;/login&amp;quot;);
            // 拒绝后续访问
            return false;
        }
    }
    return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>记第一次住院</title>
      <link>https://halklein.github.io/2020/024/</link>
      <pubDate>Fri, 03 Jan 2020 15:18:12 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2020/024/</guid>
      <description>&lt;p&gt;2020年元旦&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·No End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Web项目的一些调试技巧</title>
      <link>https://halklein.github.io/2019/023/</link>
      <pubDate>Sat, 28 Dec 2019 20:14:16 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/023/</guid>
      <description>

&lt;h2 id=&#34;1-响应状态码的含义&#34;&gt;1. 响应状态码的含义&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;200 OK&lt;/code&gt;，表明请求已经成功. 默认情况下状态码为200的响应可以被缓存。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;302 Found&lt;/code&gt;，重定向，服务器发送 &lt;code&gt;302&lt;/code&gt; 状态码和一个新的 &lt;code&gt;url&lt;/code&gt; 让浏览器再发一次新的请求，实现功能的跳转。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;404 Not Found&lt;/code&gt;，往往是路径配置有误。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;500 Internal Server Error&lt;/code&gt;，服务器接受到了请求，但是在处理的过程中发生了问题。&lt;/p&gt;

&lt;p&gt;详细信息请参考：&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-服务端断点调试技巧&#34;&gt;2. 服务端断点调试技巧&lt;/h2&gt;

&lt;p&gt;在IDEA中，打上断点后，需要以 Debug 方式运行程序。&lt;/p&gt;

&lt;p&gt;按 &lt;code&gt;F8&lt;/code&gt; 可以执行下一行&lt;/p&gt;

&lt;p&gt;按 &lt;code&gt;F7&lt;/code&gt; 可以进入到当前行执行的方法内部，查看更详细的调试信息&lt;/p&gt;

&lt;p&gt;按 &lt;code&gt;F9&lt;/code&gt; 可以一直向下执行直到遇到下一个断点处，注意在调试期间也可以在之后的程序代码中继续打断点，用于跳过一些繁杂的循环或者确定正确的程序段。&lt;/p&gt;

&lt;p&gt;有些信息可能是以Hash值显示，这时可以在下方调试框中展开看信息信息：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/28/ZM548VEUdLiYyaW.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果断点太多，你还可以批量管理断点：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/28/jRGKmuvIPdsegJk.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;3-客户端断点调试技巧&#34;&gt;3. 客户端断点调试技巧&lt;/h2&gt;

&lt;p&gt;这里主要是指对 JS 的调试。以Chrome浏览器为例，调出如下页面，&lt;code&gt;F10&lt;/code&gt;进入下一条语句，&lt;code&gt;F11&lt;/code&gt;进入当前语句，&lt;code&gt;F8&lt;/code&gt;到下一个断点或执行到底。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/28/hBezrIyuPVgJNUb.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;4-设置日志级别-并将日志输出到不同的终端&#34;&gt;4. 设置日志级别，并将日志输出到不同的终端&lt;/h2&gt;

&lt;p&gt;Spring boot内置默认的日志工具 &lt;a href=&#34;https://logback.qos.ch&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Logback&lt;/a&gt; ，&lt;a href=&#34;http://logback.qos.ch/manual/index.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;参考手册&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package org.slf4j; 
public interface Logger {
  // 日志级别，从低到高，等于或高于设定级别的日志将会在控制台输出
  public void trace(String message);
  public void debug(String message);
  public void info(String message); 
  public void warn(String message); 
  public void error(String message); 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;logger日志级别被Spring Boot整合后，可直接在 application.properties 文件中配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;# 配置logger日志级别，以便查看sql语句带来的错误等，方便查错
logging.level.me.leihao.community = debug
# 项目上线后是没有控制台的，我们可以将日志打印到文件里
logging.file.name = E:/Test/community.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在实际的项目开发中，日志文件是非常重要的，我们的设置会更复杂一些，会将不同级别的日志分成不同的文件，对单个文件如果太大也会进行拆分。&lt;/p&gt;

&lt;p&gt;首先，先注释掉 application.properties 文件中配置的 logger 日志&lt;/p&gt;

&lt;p&gt;然后，在 resources 目录下引入名为 &lt;code&gt;logback-spring.xml&lt;/code&gt; 的配置文件（注意命名是Spring规定的，不要乱改）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;configuration&amp;gt;
    &amp;lt;!--你的项目名--&amp;gt;
    &amp;lt;contextName&amp;gt;community&amp;lt;/contextName&amp;gt;
    &amp;lt;!--日志存储路径--&amp;gt;
    &amp;lt;property name=&amp;quot;LOG_PATH&amp;quot; value=&amp;quot;E:/Test/log&amp;quot;/&amp;gt;
    &amp;lt;!--子级目录，以区分不同项目--&amp;gt;
    &amp;lt;property name=&amp;quot;APPDIR&amp;quot; value=&amp;quot;community&amp;quot;/&amp;gt;

    &amp;lt;!-- error file --&amp;gt;
    &amp;lt;appender name=&amp;quot;FILE_ERROR&amp;quot; class=&amp;quot;ch.qos.logback.core.rolling.RollingFileAppender&amp;quot;&amp;gt;
        &amp;lt;!--分块规则--&amp;gt;
        &amp;lt;file&amp;gt;${LOG_PATH}/${APPDIR}/log_error.log&amp;lt;/file&amp;gt;
        &amp;lt;rollingPolicy class=&amp;quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&amp;quot;&amp;gt;
            &amp;lt;fileNamePattern&amp;gt;${LOG_PATH}/${APPDIR}/error/log-error-%d{yyyy-MM-dd}.%i.log&amp;lt;/fileNamePattern&amp;gt;
            &amp;lt;timeBasedFileNamingAndTriggeringPolicy class=&amp;quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&amp;quot;&amp;gt;
                &amp;lt;!--单个日志大小--&amp;gt;
                &amp;lt;maxFileSize&amp;gt;5MB&amp;lt;/maxFileSize&amp;gt;
            &amp;lt;/timeBasedFileNamingAndTriggeringPolicy&amp;gt;
            &amp;lt;!--日志最长保留时间--&amp;gt;
            &amp;lt;maxHistory&amp;gt;30&amp;lt;/maxHistory&amp;gt;
        &amp;lt;/rollingPolicy&amp;gt;
        &amp;lt;!--以追加方式存储日志--&amp;gt;
        &amp;lt;append&amp;gt;true&amp;lt;/append&amp;gt;
        &amp;lt;encoder class=&amp;quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&amp;quot;&amp;gt;
            &amp;lt;!--日志输出格式：日期、级别、线程、类、文件和行、提示--&amp;gt;
            &amp;lt;pattern&amp;gt;%d %level [%thread] %logger{10} [%file:%line] %msg%n&amp;lt;/pattern&amp;gt;
            &amp;lt;!--字符集--&amp;gt;
            &amp;lt;charset&amp;gt;utf-8&amp;lt;/charset&amp;gt;
        &amp;lt;/encoder&amp;gt;
        &amp;lt;filter class=&amp;quot;ch.qos.logback.classic.filter.LevelFilter&amp;quot;&amp;gt;
            &amp;lt;!--日志级别--&amp;gt;
            &amp;lt;level&amp;gt;error&amp;lt;/level&amp;gt;
            &amp;lt;onMatch&amp;gt;ACCEPT&amp;lt;/onMatch&amp;gt;
            &amp;lt;onMismatch&amp;gt;DENY&amp;lt;/onMismatch&amp;gt;
        &amp;lt;/filter&amp;gt;
    &amp;lt;/appender&amp;gt;

    &amp;lt;!-- warn file --&amp;gt;
    &amp;lt;appender name=&amp;quot;FILE_WARN&amp;quot; class=&amp;quot;ch.qos.logback.core.rolling.RollingFileAppender&amp;quot;&amp;gt;
        &amp;lt;file&amp;gt;${LOG_PATH}/${APPDIR}/log_warn.log&amp;lt;/file&amp;gt;
        &amp;lt;rollingPolicy class=&amp;quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&amp;quot;&amp;gt;
            &amp;lt;fileNamePattern&amp;gt;${LOG_PATH}/${APPDIR}/warn/log-warn-%d{yyyy-MM-dd}.%i.log&amp;lt;/fileNamePattern&amp;gt;
            &amp;lt;timeBasedFileNamingAndTriggeringPolicy class=&amp;quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&amp;quot;&amp;gt;
                &amp;lt;maxFileSize&amp;gt;5MB&amp;lt;/maxFileSize&amp;gt;
            &amp;lt;/timeBasedFileNamingAndTriggeringPolicy&amp;gt;
            &amp;lt;maxHistory&amp;gt;30&amp;lt;/maxHistory&amp;gt;
        &amp;lt;/rollingPolicy&amp;gt;
        &amp;lt;append&amp;gt;true&amp;lt;/append&amp;gt;
        &amp;lt;encoder class=&amp;quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&amp;quot;&amp;gt;
            &amp;lt;pattern&amp;gt;%d %level [%thread] %logger{10} [%file:%line] %msg%n&amp;lt;/pattern&amp;gt;
            &amp;lt;charset&amp;gt;utf-8&amp;lt;/charset&amp;gt;
        &amp;lt;/encoder&amp;gt;
        &amp;lt;filter class=&amp;quot;ch.qos.logback.classic.filter.LevelFilter&amp;quot;&amp;gt;
            &amp;lt;level&amp;gt;warn&amp;lt;/level&amp;gt;
            &amp;lt;onMatch&amp;gt;ACCEPT&amp;lt;/onMatch&amp;gt;
            &amp;lt;onMismatch&amp;gt;DENY&amp;lt;/onMismatch&amp;gt;
        &amp;lt;/filter&amp;gt;
    &amp;lt;/appender&amp;gt;

    &amp;lt;!-- info file --&amp;gt;
    &amp;lt;appender name=&amp;quot;FILE_INFO&amp;quot; class=&amp;quot;ch.qos.logback.core.rolling.RollingFileAppender&amp;quot;&amp;gt;
        &amp;lt;file&amp;gt;${LOG_PATH}/${APPDIR}/log_info.log&amp;lt;/file&amp;gt;
        &amp;lt;rollingPolicy class=&amp;quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&amp;quot;&amp;gt;
            &amp;lt;fileNamePattern&amp;gt;${LOG_PATH}/${APPDIR}/info/log-info-%d{yyyy-MM-dd}.%i.log&amp;lt;/fileNamePattern&amp;gt;
            &amp;lt;timeBasedFileNamingAndTriggeringPolicy class=&amp;quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&amp;quot;&amp;gt;
                &amp;lt;maxFileSize&amp;gt;5MB&amp;lt;/maxFileSize&amp;gt;
            &amp;lt;/timeBasedFileNamingAndTriggeringPolicy&amp;gt;
            &amp;lt;maxHistory&amp;gt;30&amp;lt;/maxHistory&amp;gt;
        &amp;lt;/rollingPolicy&amp;gt;
        &amp;lt;append&amp;gt;true&amp;lt;/append&amp;gt;
        &amp;lt;encoder class=&amp;quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&amp;quot;&amp;gt;
            &amp;lt;pattern&amp;gt;%d %level [%thread] %logger{10} [%file:%line] %msg%n&amp;lt;/pattern&amp;gt;
            &amp;lt;charset&amp;gt;utf-8&amp;lt;/charset&amp;gt;
        &amp;lt;/encoder&amp;gt;
        &amp;lt;filter class=&amp;quot;ch.qos.logback.classic.filter.LevelFilter&amp;quot;&amp;gt;
            &amp;lt;level&amp;gt;info&amp;lt;/level&amp;gt;
            &amp;lt;onMatch&amp;gt;ACCEPT&amp;lt;/onMatch&amp;gt;
            &amp;lt;onMismatch&amp;gt;DENY&amp;lt;/onMismatch&amp;gt;
        &amp;lt;/filter&amp;gt;
    &amp;lt;/appender&amp;gt;

    &amp;lt;!-- console 打印到控制台 --&amp;gt;
    &amp;lt;appender name=&amp;quot;STDOUT&amp;quot; class=&amp;quot;ch.qos.logback.core.ConsoleAppender&amp;quot;&amp;gt;
        &amp;lt;encoder&amp;gt;
            &amp;lt;pattern&amp;gt;%d %level [%thread] %logger{10} [%file:%line] %msg%n&amp;lt;/pattern&amp;gt;
            &amp;lt;charset&amp;gt;utf-8&amp;lt;/charset&amp;gt;
        &amp;lt;/encoder&amp;gt;
        &amp;lt;filter class=&amp;quot;ch.qos.logback.classic.filter.ThresholdFilter&amp;quot;&amp;gt;
            &amp;lt;!--控制台日志级别--&amp;gt;
            &amp;lt;level&amp;gt;debug&amp;lt;/level&amp;gt;
        &amp;lt;/filter&amp;gt;
    &amp;lt;/appender&amp;gt;

    &amp;lt;!--对某个包日志级别的单独声明--&amp;gt;
    &amp;lt;logger name=&amp;quot;me.leihao.community&amp;quot; level=&amp;quot;debug&amp;quot;/&amp;gt;

    &amp;lt;root level=&amp;quot;info&amp;quot;&amp;gt;
        &amp;lt;appender-ref ref=&amp;quot;FILE_ERROR&amp;quot;/&amp;gt;
        &amp;lt;appender-ref ref=&amp;quot;FILE_WARN&amp;quot;/&amp;gt;
        &amp;lt;appender-ref ref=&amp;quot;FILE_INFO&amp;quot;/&amp;gt;
        &amp;lt;appender-ref ref=&amp;quot;STDOUT&amp;quot;/&amp;gt;
    &amp;lt;/root&amp;gt;

&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>用 iTerm2 美化你的 Mac终端</title>
      <link>https://halklein.github.io/2019/022/</link>
      <pubDate>Wed, 25 Dec 2019 11:38:03 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/022/</guid>
      <description>

&lt;h2 id=&#34;先看看效果图&#34;&gt;先看看效果图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/25/bAyehHXWCwkLPSR.png&#34; alt=&#34;效果图&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;安装-iterm2&#34;&gt;安装 iTerm2&lt;/h2&gt;

&lt;p&gt;下载安装 &lt;a href=&#34;https://www.iterm2.com/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;iterm2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://iterm2.com/downloads/stable/latest&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://iterm2.com/downloads/stable/latest&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;安装 &lt;a href=&#34;https://ohmyz.sh/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;oh-my-zsh&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;sh -c &amp;quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;p&gt;sh -c &amp;ldquo;$(wget &lt;a href=&#34;https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh&lt;/a&gt; -O -)&amp;rdquo;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;若需要Homebrew，执行下面命令安装&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/usr/bin/ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;wget的安装&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;brew install wget
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如需科学上网：&lt;a href=&#34;https://www.noxxxx.com/mac-下终端走-ss-代理.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;参考&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在终端中直接运行命令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;export http_proxy=http://proxyAddress:port
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个办法的好处是简单直接，并且影响面很小（只对当前终端有效，退出就不行了）。&lt;/p&gt;

&lt;p&gt;如果你用的是ss代理，在当前终端运行以下命令，那么&lt;code&gt;wget&lt;/code&gt; &lt;code&gt;curl&lt;/code&gt; 这类网络命令都会经过ss代理&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;export ALL_PROXY=socks5://127.0.0.1:1080
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;下载配色方案&#34;&gt;下载配色方案&lt;/h2&gt;

&lt;p&gt;你可以在 &lt;a href=&#34;https://iterm2colorschemes.com/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;这里&lt;/a&gt; 查看配色方案。（这里我选择 &lt;strong&gt;Tomorrow Night Eighties&lt;/strong&gt;）&lt;/p&gt;

&lt;p&gt;然后到 &lt;a href=&#34;https://github.com/mbadolato/iTerm2-Color-Schemes&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;这里&lt;/a&gt; 下载 iterm2 的配色方案&lt;/p&gt;

&lt;p&gt;下载好之后，在iTerm2首选项中导入配色方案：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/25/b73i1KHnfIRov8N.png&#34; alt=&#34;首选项&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/25/BTOsYSQXWUZhHV3.png&#34; alt=&#34;选择配色文件&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;更换-zsh-默认的主题&#34;&gt;更换 zsh 默认的主题&lt;/h2&gt;

&lt;p&gt;我使用的主题是&lt;a href=&#34;https://github.com/Powerlevel9k/powerlevel9k/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;powerlevel9k&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;git clone https://github.com/bhilburn/powerlevel9k.git ~/.oh-my-zsh/custom/themes/powerlevel9k
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑配置文件 &lt;code&gt;vi ~/.zshrc&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;ZSH_THEME=&amp;quot;powerlevel9k/powerlevel9k&amp;quot;
# 命令左侧显示内容（当前目录 git 版本信息）
POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(context dir vcs)
# 命令右侧显示内容（命令运行状态，剩余内存，时间，cpu负载，剩余电量）
POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(status ram time load battery)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后运行 &lt;code&gt;source ~/.zshrc&lt;/code&gt; 命令，让其生效。&lt;/p&gt;

&lt;h2 id=&#34;更换字体&#34;&gt;更换字体&lt;/h2&gt;

&lt;p&gt;直接使用 &lt;code&gt;powerlevel9k&lt;/code&gt; 主题的话，因为默认字体不支持 icon，会出现一些乱码。&lt;/p&gt;

&lt;p&gt;因为 &lt;code&gt;powerlevel9k&lt;/code&gt; 中用到了大量的 icon，但是只有部分的字体支持 icon。目前对 icon 的支持得比较好的字体是 &lt;a href=&#34;https://www.nerdfonts.com/#home&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Nerd Font&lt;/a&gt;。brew 提供了 nerd 字体的安装。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;$ brew tap homebrew/cask-fonts
$ brew search nerd
==&amp;gt; Formulae
container-diff
==&amp;gt; Casks
font-3270-nerd-font
...
# 选择Nerd Font字体进行安装
$ brew cask install font-sourcecodepro-nerd-font
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装字体成功后，就可以在 iterm2 中设置了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/25/LqtHU8Z95oBdiFD.png&#34; alt=&#34;更改字体&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;插件&#34;&gt;插件&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;oh-my-zsh&lt;/code&gt; 有很多好用的插件，安装好的插件需要在 &lt;code&gt;~/.zshrc&lt;/code&gt; 中的 &lt;code&gt;plugins=(git autojump cp extract sudo z zsh-syntax-highlighting zsh-autosuggestions)&lt;/code&gt; 依次写入配置，用空格分开。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;autojump&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;记忆我们之前去过的目录，不需要多次 &lt;code&gt;cd&lt;/code&gt; ，直接 &lt;code&gt;j 目录名&lt;/code&gt; 就可以直接进入。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#安装
brew install autojump

#在 ~/.zshrc 中加入如下配置
[[ -s $(brew --prefix)/etc/profile.d/autojump.sh ]] &amp;amp;&amp;amp; . $(brew --prefix)/etc/profile.d/autojump.sh
source $ZSH/oh-my-zsh.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;zsh-autosuggestion&#34;&gt;&lt;strong&gt;zsh-autosuggestion&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;输入命令提示自动补全，然后按键盘 &lt;code&gt;→&lt;/code&gt; 即可补全&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#安装
$ git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;zsh-syntax-highlighting&#34;&gt;&lt;strong&gt;zsh-syntax-highlighting&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;命令高亮显示，错误显示红色&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;# 安装
$ git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;colorls&#34;&gt;&lt;strong&gt;colorls&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;显示文件图标&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;# 安装
sudo gem install colorls 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>关于数据库索引的一些问题</title>
      <link>https://halklein.github.io/2019/021/</link>
      <pubDate>Tue, 24 Dec 2019 21:22:50 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/021/</guid>
      <description>

&lt;h2 id=&#34;一-密集索引和稀疏索引&#34;&gt;一、密集索引和稀疏索引&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;密集索引文件中的每个搜索码值都对应一个索引值&lt;/li&gt;
&lt;li&gt;稀疏索引文件只为索引码的某些值建立索引项&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/24/qtGm8r27hMxLDwV.png&#34; alt=&#34;密集索引和稀疏索引&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MySQL常见的数据库引擎：MyISAM只使用稀疏索引，InnoDB有且仅有一个密集索引&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;若一个主键被定义，该主键则作为密集索引&lt;/li&gt;
&lt;li&gt;若没有主键被定义，该表的第一个唯一非空索引则作为密集索引&lt;/li&gt;
&lt;li&gt;若不满足以上条件，innodb内部会生成一个隐藏主键（密集索引）&lt;/li&gt;
&lt;li&gt;非主键索引存储相关键位和其对应的主键值，包含两次查找&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;二-如何定位并优化慢查询sql&#34;&gt;二、如何定位并优化慢查询Sql&lt;/h2&gt;

&lt;p&gt;具体场景要具体分析，大致思路如下：
- 根据慢日志定位慢查询sql
- 使用explain等工具分析sql
- 修改sql或者尽量让sql走索引&lt;/p&gt;

&lt;h3 id=&#34;2-1-根据慢日志定位慢查询sql&#34;&gt;2.1 根据慢日志定位慢查询sql&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;# 查看数据库慢日志配置
mysql&amp;gt; show variables like &amp;quot;%quer%&amp;quot;;

# 查看慢日志数量
mysql&amp;gt; show status like &amp;quot;%slow_queries%&amp;quot;;

# 打开慢日志开关
mysql&amp;gt; set global slow_query_log = on;

# 设置慢日志记录阈值为1s，10s可以说是很慢很慢了，不具有参考价值
# 修改后可能需要重新连接数据库才能看到效果
# 另外，这样的设置在重启MySQL服务之后将会失效！如果要永久生效,需修改my.ini配置文件（Mac OS是my.cnf）
mysql&amp;gt; set global long_query_time = 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/24/NFSpx65OUvuqQhD.png&#34; alt=&#34;查看数据库慢日志配置&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-2-使用explain等工具分析sql&#34;&gt;2.2 使用explain等工具分析sql&lt;/h3&gt;

&lt;p&gt;只需在查询语句前加上 &lt;code&gt;explain&lt;/code&gt; 即可，如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;mysql&amp;gt; explain select ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-3-修改sql或者尽量让sql走索引&#34;&gt;2.3 修改sql或者尽量让sql走索引&lt;/h3&gt;

&lt;h2 id=&#34;三-联合索引的最左匹配原则的成因&#34;&gt;三、联合索引的最左匹配原则的成因&lt;/h2&gt;

&lt;h2 id=&#34;四-索引是建立得越多越好吗&#34;&gt;四、索引是建立得越多越好吗&lt;/h2&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>数据库索引之 B&#43; Tree、Hash、BitMap</title>
      <link>https://halklein.github.io/2019/020/</link>
      <pubDate>Tue, 24 Dec 2019 19:54:38 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/020/</guid>
      <description>

&lt;h2 id=&#34;b-tree&#34;&gt;B+ Tree&lt;/h2&gt;

&lt;p&gt;由于，二叉查看树在插入修改过程中，很可能出现只有左右子树的情况，虽然可以用平衡调整二叉树，但是每次IO依然很费时间，每访问一层就要对磁盘进行IO，总体来说二叉树还不够优。由此找到了更好的替代方法-B树，又由于B+ Tree具有更好的特性，所以B+ Tree就成了常见的索引结构之一。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/24/xkZWtEguQIAoRXK.png&#34; alt=&#34;B+ Tree&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;B+ Tree相对于B树，具有的新特点：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;非叶子节点的子树指针与关键字个数相同&lt;/li&gt;
&lt;li&gt;非叶子节点的子树指针P[]，指向关键字值（[Ki]，K[i+1]）的子树&lt;/li&gt;
&lt;li&gt;非叶子节点仅用来索引，数据都保存在叶子节点中&lt;/li&gt;
&lt;li&gt;所有叶子节点均有一个链指针指向下一个叶子结点&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;hash&#34;&gt;Hash&lt;/h2&gt;

&lt;p&gt;通过Hash索引，能够通过Hash函数快速定位到索引目标，理论上比B+ Tree更快。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/24/hci2ueoaKS4klxf.png&#34; alt=&#34;Hash索引&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;但是Hash索引也有也有严重的缺陷：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;仅仅能满足“=&amp;ldquo;，“IN&amp;rdquo;，不能使用范围查询&lt;/li&gt;
&lt;li&gt;无法被用来避免数据的排序操作&lt;/li&gt;
&lt;li&gt;不能利用部分索引键查询&lt;/li&gt;
&lt;li&gt;不能避免表扫描&lt;/li&gt;
&lt;li&gt;遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，索引没有最优，只有更适合某种情况的索引结构，他们常常组合使用。&lt;/p&gt;

&lt;h2 id=&#34;bitmap&#34;&gt;BitMap&lt;/h2&gt;

&lt;p&gt;位图索引，适用于某个字段的值只有固定的几种为了实现高效的统计的情况，如性别（男、女）。不过支持位图索引的数据库比较少，典型的有Oracle数据库。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/24/4uxK3ZdCTknmj9w.png&#34; alt=&#34;BitMap&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Socket 入门</title>
      <link>https://halklein.github.io/2019/011/</link>
      <pubDate>Tue, 05 Nov 2019 09:31:12 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/011/</guid>
      <description>

&lt;h2 id=&#34;进程间通信&#34;&gt;进程间通信&lt;/h2&gt;

&lt;p&gt;网络中进程进行通信的前提是每个进程都要有唯一的标识，在本地计算机中我们可以用PID来唯一标识一个进程，可以多个计算机处在网络中时，不同计算机的进程PID冲突的可能性就很大。怎么办呢？我们知道IP地址可以唯一标识主机，而TCP协议和端口号可以唯一标识主机的一个进程，这样我们就可以用 IP+协议+端口号 来唯一标识网络中的一个进程了。&lt;/p&gt;

&lt;p&gt;使用TCP/IP协议的应用程序通常采用应用编程接口：UNIX BSD的套接字（socket）和UNIX System V的TLI（已经被淘汰），来实现网络进程之间的通信。就目前而言，几乎所有的应用程序都是采用socket。&lt;/p&gt;

&lt;h2 id=&#34;什么是socket&#34;&gt;什么是Socket？&lt;/h2&gt;

&lt;p&gt;网络套接字（英语：Network socket；又译网络套接字、网络接口、网络插槽）在计算机科学中是电脑网络中行程间数据流的端点。使用以网际协议（Internet Protocol）为通信基础的网络套接字，称为网际套接字（Internet socket）。因为网际协议的流行，现代绝大多数的网络套接字，都是属于网际套接字。&lt;/p&gt;

&lt;p&gt;socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&amp;gt; 读写write/read –&amp;gt; 关闭close”模式来操作。我的理解就是Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/tl96CpP3Qv4fMEV.jpg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Socket与TCP/IP协议并没有必然的联系，Socket编程接口在设计的时候就希望能适应其它的网络协议，所以Socket的出现是为了我们更好地使用TCP/IP协议栈，是对TCP/IP协议的抽象，是操作系统对外开放的接口。&lt;/p&gt;

&lt;h2 id=&#34;socket通信流程&#34;&gt;socket通信流程&lt;/h2&gt;

&lt;p&gt;以使用TCP协议通讯的socket为例，其交互流程大概是这样子的&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/aJRALE8cFmZonkg.png&#34; alt=&#34;Socket通信流程&#34; /&gt;Socket通信流程&lt;/p&gt;

&lt;h2 id=&#34;实列&#34;&gt;实列&lt;/h2&gt;

&lt;h3 id=&#34;编写一个网络应用程序-包含客户端和服务端-客户端向服务端发送一个字符串-服务端收到字符串并打印到命令行同时向客户端返回字符串长度-最后客户端输出收到的字符串长度-分别用tcp和udp实现&#34;&gt;&lt;strong&gt;编写一个网络应用程序，包含客户端和服务端，客户端向服务端发送一个字符串，服务端收到字符串并打印到命令行同时向客户端返回字符串长度，最后客户端输出收到的字符串长度，分别用TCP和UDP实现。&lt;/strong&gt;&lt;/h3&gt;

&lt;h4 id=&#34;tcp方式&#34;&gt;TCP方式：&lt;/h4&gt;

&lt;p&gt;服务端&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TCPServer {
    public static void main(String[] args) throws Exception {
        //创建socket,并将socket绑定到65000端口
        ServerSocket ss = new ServerSocket(65000);
        //死循环，使得socket一直等待并处理客户端发送过来的请求
        while (true) {
            //监听65000端口，直到客户端返回连接信息后才返回
            Socket socket = ss.accept();
            //获取客户端的请求信息后，执行相关业务逻辑
            new LengthCalculator(socket).start();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;服务端业务逻辑&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class LengthCalculator extends Thread {
    //以socket为成员变量
    private Socket socket;
    public LengthCalculator(Socket socket) {
        this.socket = socket;
    }
    @Override
    public void run() {
        try {
            //获取socket的输出流
            OutputStream os = socket.getOutputStream();
            //获取socket的输入流
            InputStream is = socket.getInputStream();
            int ch = 0;
            byte[] buff = new byte[1024];
            //buff主要用来读取输入的内容，存成byte数组，ch主要用来获取读取数组的长度
            ch = is.read(buff);
            //将接收流的byte数组转换成字符串，这里获取的内容是客户端发送过来的字符串参数
            String content = new String(buff, 0, ch);
            System.out.println(content);
            //往输出流里写入获得的字符串的长度，回发给客户端
            os.write(String.valueOf(content.length()).getBytes());
            //不要忘记关闭输入输出流以及socket
            is.close();
            os.close();
            socket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;客户端&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TCPClient {
    public static void main(String[] args) throws Exception {
        //创建socket，并指定连接的是本机的端口号为65000的服务器socket
        Socket socket = new Socket(&amp;quot;127.0.0.1&amp;quot;, 65000);
        //获取输出流
        OutputStream os = socket.getOutputStream();
        //获取输入流
        InputStream is = socket.getInputStream();
        //将要传递给server的字符串参数转换成byte数组，并将数组写入到输出流中
        os.write(new String(&amp;quot;hello world&amp;quot;).getBytes());
        int ch = 0;
        byte[] buff = new byte[1024];
        //buff主要用来读取输入的内容，存成byte数组，ch主要用来获取读取数组的长度
        ch = is.read(buff);
        //将接收流的byte数组转换成字符串，这里是从服务端回发回来的字符串参数的长度
        String content = new String(buff, 0, ch);
        System.out.println(content);
        //不要忘记关闭输入输出流以及socket
        is.close();
        os.close();
        socket.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/Rg5GzaCweFlMtjL.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/iITvbCjR18d2HMY.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;UDP方式：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;服务端&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UDPServer {
    public static void main(String[] args) throws Exception {
        // 服务端接受客户端发送的数据报
        DatagramSocket socket = new DatagramSocket(65001); //监听的端口号
        byte[] buff = new byte[100]; //存储从客户端接受到的内容
        DatagramPacket packet = new DatagramPacket(buff, buff.length);
        //接受客户端发送过来的内容，并将内容封装进DatagramPacket对象中
        socket.receive(packet);
        byte[] data = packet.getData(); //从DatagramPacket对象中获取到真正存储的数据
        //将数据从二进制转换成字符串形式
        String content = new String(data, 0, packet.getLength());
        System.out.println(content);
        //将要发送给客户端的数据转换成二进制
        byte[] sendedContent = String.valueOf(content.length()).getBytes();
        // 服务端给客户端发送数据报
        //从DatagramPacket对象中获取到数据的来源地址与端口号
        DatagramPacket packetToClient = new DatagramPacket(sendedContent,
                sendedContent.length, packet.getAddress(), packet.getPort());
        socket.send(packetToClient); //发送数据给客户端
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;客户端&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UDPClient {
    public static void main(String[] args) throws Exception {
        // 客户端发数据报给服务端
        DatagramSocket socket = new DatagramSocket();
        // 要发送给服务端的数据
        byte[] buf = &amp;quot;Hello World&amp;quot;.getBytes();
        // 将IP地址封装成InetAddress对象
        InetAddress address = InetAddress.getByName(&amp;quot;127.0.0.1&amp;quot;);
        // 将要发送给服务端的数据封装成DatagramPacket对象 需要填写上ip地址与端口号
        DatagramPacket packet = new DatagramPacket(buf, buf.length, address,
                65001);
        // 发送数据给服务端
        socket.send(packet);
        // 客户端接受服务端发送过来的数据报
        byte[] data = new byte[100];
        // 创建DatagramPacket对象用来存储服务端发送过来的数据
        DatagramPacket receivedPacket = new DatagramPacket(data, data.length);
        // 将接受到的数据存储到DatagramPacket对象中
        socket.receive(receivedPacket);
        // 将服务器端发送过来的数据取出来并打印到控制台
        String content = new String(receivedPacket.getData(), 0,
                receivedPacket.getLength());
        System.out.println(content);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/RuBrkvAVp5aFTx3.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>HTTP 与 HTTPS</title>
      <link>https://halklein.github.io/2019/010/</link>
      <pubDate>Sun, 03 Nov 2019 15:52:12 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/010/</guid>
      <description>

&lt;h2 id=&#34;1-http协议&#34;&gt;1. HTTP协议&lt;/h2&gt;

&lt;p&gt;超文本传输协议（英语：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。 通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接 。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HTTP 协议构建于 TCP/IP 协议之上，是一个应用层协议，默认端口号是 80&lt;/li&gt;
&lt;li&gt;HTTP 是&lt;strong&gt;无连接无状态&lt;/strong&gt;的&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-版本&#34;&gt;2. 版本&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;HTTP/0.9&lt;/strong&gt; 已过时。只接受GET一种请求方法，没有在通讯中指定版本号，且不支持请求头。由于该版本不支持POST方法，因此客户端无法向服务器传递太多信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HTTP/1.0&lt;/strong&gt; 这是第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用，特别是在代理服务器中。[来源请求]&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HTTP/1.1&lt;/strong&gt; 持久连接被默认采用，并能很好地配合代理服务器工作。还支持以管道方式在同时发送多个请求，以便降低线路负载，提高传输速度。HTTP/1.1相较于HTTP/1.0协议的区别主要体现在：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;缓存处理&lt;/li&gt;
&lt;li&gt;带宽优化及网络连接的使用&lt;/li&gt;
&lt;li&gt;错误通知的管理&lt;/li&gt;
&lt;li&gt;消息在网络中的发送&lt;/li&gt;
&lt;li&gt;互联网地址的维护&lt;/li&gt;
&lt;li&gt;安全性及完整性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;HTTP/2&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当前版本，于2015年5月作为互联网标准正式发布。&lt;/p&gt;

&lt;p&gt;HTTP目前处于多个版本共存的情况，包括仍被广泛采用的HTTP１.0，主流是1.1（ 1.1 版的最大变化，就是引入 Keep-Alive， 简单说就是保持当前的TCP连接，避免了重新建立连接。 ）， HTTP/2 目前应用较少（主要是因为1.1基本能满足需求，还有升级成本问题）&lt;/p&gt;

&lt;h2 id=&#34;2-超文本传输协议http主要特点&#34;&gt;2. 超文本传输协议HTTP主要特点&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;支持B/S及C/S模式&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;简单快速&lt;/strong&gt; ：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;灵活：&lt;/strong&gt;HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无连接：&lt;/strong&gt;无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无状态：&lt;/strong&gt;HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;3-http请求结构&#34;&gt;3. HTTP请求结构&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/G4fT2BQZSq7U6jn.png&#34; alt=&#34;HTTP请求结构&#34; /&gt;HTTP请求结构&lt;/p&gt;

&lt;p&gt;HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;序号&lt;/th&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;请求指定的页面信息，并返回实体主体。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;HEAD&lt;/td&gt;
&lt;td&gt;类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;POST&lt;/td&gt;
&lt;td&gt;向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;PUT&lt;/td&gt;
&lt;td&gt;从客户端向服务器传送的数据取代指定的文档的内容。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;DELETE&lt;/td&gt;
&lt;td&gt;请求服务器删除指定的页面。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;CONNECT&lt;/td&gt;
&lt;td&gt;HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;OPTIONS&lt;/td&gt;
&lt;td&gt;允许客户端查看服务器的性能。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;TRACE&lt;/td&gt;
&lt;td&gt;回显服务器收到的请求，主要用于测试或诊断。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;PATCH&lt;/td&gt;
&lt;td&gt;是对 PUT 方法的补充，用来对已知资源进行局部更新 。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;请求头部用来设置HTTP请求的一些参数，如Host、User-Agen&lt;/p&gt;

&lt;p&gt;请求数据，表示要上传的数据，其和头部之间是是有空行的，且请求头部后面的空行是必须的（即使请求数据为空）。&lt;/p&gt;

&lt;h2 id=&#34;4-http响应结构&#34;&gt;4. HTTP响应结构&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/RoUCGZ16VKHb4hk.png&#34; alt=&#34;HTTP响应结构&#34; /&gt;HTTP响应结构&lt;/p&gt;

&lt;h3 id=&#34;状态码类别&#34;&gt;状态码类别&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;分类&lt;/th&gt;
&lt;th&gt;分类描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1**&lt;/td&gt;
&lt;td&gt;指示信息，表示服务器收到请求，需要请求者继续执行操作&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2**&lt;/td&gt;
&lt;td&gt;成功，操作被成功接收并处理&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3**&lt;/td&gt;
&lt;td&gt;重定向，需要进一步的操作以完成请求&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4**&lt;/td&gt;
&lt;td&gt;客户端错误，请求包含语法错误或无法完成请求&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5**&lt;/td&gt;
&lt;td&gt;服务器错误，服务器在处理请求的过程中发生了错误&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;常见状态码&#34;&gt;&lt;strong&gt;常见状态码&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;200 OK&lt;/code&gt; 客户端请求成功&lt;/li&gt;
&lt;li&gt;&lt;code&gt;301 Moved Permanently&lt;/code&gt; 请求永久重定向&lt;/li&gt;
&lt;li&gt;&lt;code&gt;302 Moved Temporarily&lt;/code&gt; 请求临时重定向&lt;/li&gt;
&lt;li&gt;&lt;code&gt;304 Not Modified&lt;/code&gt; 文件未修改，可以直接使用缓存的文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;400 Bad Request&lt;/code&gt; 由于客户端请求有语法错误，不能被服务器所理解。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;401 Unauthorized&lt;/code&gt; 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;403 Forbidden&lt;/code&gt; 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;404 Not Found&lt;/code&gt; 请求的资源不存在，例如，输入了错误的URL。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;500 Internal Server Error&lt;/code&gt; 服务器发生不可预期的错误，导致无法完成客户端的请求。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;503 Service Unavailable&lt;/code&gt; 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;详细的状态码，可以 &lt;a href=&#34;https://www.runoob.com/http/http-status-codes.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;在这里查看&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;5-http抓包分析&#34;&gt;5. HTTP抓包分析&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/azHYDUIAb4yJw6Q.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;双击第一条&lt;strong&gt;HTTP请求&lt;/strong&gt;，查看详细请求报文：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/JryvnTqcubGUMDS.png&#34; alt=&#34;HTTP请求&#34; /&gt;HTTP请求&lt;/p&gt;

&lt;p&gt;双击第二条&lt;strong&gt;HTTP响应&lt;/strong&gt;，查看详细响应报文：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/fjxp98r1Nign46K.png&#34; alt=&#34;HTTP响应&#34; /&gt;HTTP响应&lt;/p&gt;

&lt;h2 id=&#34;6-http请求-响应的步骤&#34;&gt;6. HTTP请求/响应的步骤&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;客户端连接到Web服务器，客户端（通常是浏览器）与Web服务器的端口（默认80）建立TCP套接字（ socket ）连接&lt;/li&gt;
&lt;li&gt;客户端发送HTTP请求&lt;/li&gt;
&lt;li&gt;服务器接受请求并返回HTTP响应&lt;/li&gt;
&lt;li&gt;释放连接TCP连接。若连接模式为close则服务器主动关闭TCP连接；若连接模式为Keep-Alive则该连接会保持一段时间，在该时间内可以继续接收请求。&lt;/li&gt;
&lt;li&gt;客户端浏览器解析HTML内容&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;7-一些问题&#34;&gt;7. 一些问题&lt;/h2&gt;

&lt;h3 id=&#34;7-1-在浏览器地址栏键入带有http请求的url-按下回车之后经历的流程&#34;&gt;7.1 在浏览器地址栏键入带有HTTP请求的URL，按下回车之后经历的流程？&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;DNS解析。浏览器会根据URL逐层（浏览器缓存 – 系统缓存 – 路由器缓存 – IPS服务器缓存 – 域名服务器缓存 – 顶级域名服务器缓存，找到即可返回不再需要查询后面的缓存）查询DNS缓存，解析URL中的域名对应的IP地址。&lt;/li&gt;
&lt;li&gt;TCP连接。根据IP地址和端口与服务器建立TCP连接（三次握手）。&lt;/li&gt;
&lt;li&gt;发送HTTP请求。建立连接后浏览器向服务器发出读取文件的HTTP请求。&lt;/li&gt;
&lt;li&gt;服务器处理请求并返回HTTP报文。&lt;/li&gt;
&lt;li&gt;浏览器解析渲染页面。&lt;/li&gt;
&lt;li&gt;连接结束。浏览器释放TCP连接。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;7-2-get请求和post请求的区别&#34;&gt;7.2 GET请求和POST请求的区别？&lt;/h3&gt;

&lt;p&gt;从三个层面来解答&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;1. Http报文层面：&lt;/strong&gt;GET将请求信息放在URL，POST放在报文体中（想获得请求详细必须请求报文，所以安全性较GET方式高一些，事实上要获得报文体中的请求信息也是很容易的‘Wireshark就可以查看’，因此安全性上两者并没有太多的区别，具体解决安全性的问题需要HTTPS）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/DQaeRE6JoPSrfYn.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;2. 数据库层面：&lt;/strong&gt;CET符合幂等性（多次操作获得结果一样）和安全性（不会改变数据库数据，GET做查询操作），POST都不符合。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;3. 其他层面：&lt;/strong&gt;GET可以被缓存、被存储，而POST不行。所以GET现在依然规范使用。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;7-3-cookie和session的区别&#34;&gt;7.3 Cookie和Session的区别？&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Cookie简介&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;是由服务器发给客户端的特殊信息，以文本的形式存放在客户端 客户端再次请求的时候，会把Cookie回发 服务器接收到后，会解析Cookie生成与客户端相对应的内容&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Cookie的设置以及发送过程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/2hP1culNRmJwZej.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;客户端发送一个http请求到服务器端&lt;/li&gt;
&lt;li&gt;服务器端发送一个http响应到客户端，其中包含Set-Cookie头部&lt;/li&gt;
&lt;li&gt;客户端发送一个http请求到服务器端，其中包含Cookie头部&lt;/li&gt;
&lt;li&gt;服务器端发送一个http响应到客户端&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Session简介&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;服务器端的机制，在服务器上保存的信息 解析客户端请求并操作session id，按需保存状态信息&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Session的实现方式&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用Cookie来实现&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/nGwOtgZTQxP8lCU.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用URL回写来实现。服务器在发送给浏览器的所有连接中都携带JSESSIONID的参数，这样客户端点击任何一个路径都会带回JSESSIONID。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;二者的区别：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Cookie数据存放在客户的浏览器上，Session数据放在服务器上&lt;/li&gt;
&lt;li&gt;Session相对于Cookie更安全&lt;/li&gt;
&lt;li&gt;若考虑减轻服务器负担，应当使用Cookie&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;7-4-http和https的区别&#34;&gt;7.4 HTTP和HTTPS的区别？&lt;/h2&gt;

&lt;h3 id=&#34;https简介&#34;&gt;HTTPS简介&lt;/h3&gt;

&lt;p&gt;超文本传输安全协议（英语：HyperText Transfer Protocol Secure，缩写：HTTPS；常称为HTTP over TLS、HTTP over SSL或HTTP Secure）是一种通过计算机网络进行安全通信的传输协议。是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。&lt;/p&gt;

&lt;h3 id=&#34;ssl&#34;&gt;SSL&lt;/h3&gt;

&lt;p&gt;SSL（Security Sockets Layer，安全套接层）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;为网络通信提供安全及数据完整性的一种安全协议&lt;/li&gt;
&lt;li&gt;是操作系统对外的API，SSL3.0后更名为TLS&lt;/li&gt;
&lt;li&gt;采用身份验证和数据加密保证网络通信的安全和数据的完整性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;加密的方式&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;对称加密：也叫私钥加密，指加密和解密使用相同密钥的加密算法。有时又叫传统密码算法，就是加密密钥能够从解密密钥中推算出来，同时解密密钥也可以从加密密钥中推算出来。而在大多数的对称算法中，加密密钥和解密密钥是相同的，所以也称这种加密算法为秘密密钥算法或单密钥算法。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;常见的对称加密有：DES（Data Encryption Standard）、AES（Advanced Encryption Standard）、RC4、IDEA。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;非对称加密：与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）；并且加密密钥和解密密钥是成对出现的。非对称加密算法在加密和解密过程使用了不同的密钥，非对称加密也称为公钥加密，在密钥对中，其中一个密钥是对外公开的，所有人都可以获取到，称为公钥，其中一个密钥是不公开的称为私钥。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;非对称加密算法对加密内容的长度有限制，不能超过公钥长度。比如现在常用的公钥长度是 2048 位，意味着待加密内容不能超过 256 个字节。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;摘要算法：采用单项Hash函数将需要加密的明文“摘要”成一串固定长度的密文，这一串密文又称为数字指纹，它有固定的长度，而且不同的明文摘要成密文，其结果总是不同的，而同样的明文其摘要必定一致。“数字摘要“是https能确保数据完整性和防篡改的根本原因，算法不可逆。&lt;/li&gt;
&lt;li&gt;数字签名：数字签名技术就是对“非对称密钥加解密”和“数字摘要“两项技术的应用，它将摘要信息用发送者的私钥加密，与原文一起传送给接收者。接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与解密的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;数字签名的&lt;strong&gt;过程&lt;/strong&gt;如下：&lt;/p&gt;

&lt;p&gt;明文 –&amp;gt; hash运算 –&amp;gt; 摘要 –&amp;gt; 私钥加密 –&amp;gt; 数字签名&lt;/p&gt;

&lt;p&gt;数字签名有两种&lt;strong&gt;作用&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;一、能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。&lt;/p&gt;

&lt;p&gt;二、数字签名能确定消息的完整性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;https数据传输流程&#34;&gt;HTTPS数据传输流程&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;浏览器将支持的加密算法信息发送给服务器&lt;/li&gt;
&lt;li&gt;服务器选择一套浏览器支持的加密算法，以证书的形式回发浏览器&lt;/li&gt;
&lt;li&gt;浏览器验证证书合法性，并结合证书公钥加密信息发送给服务器&lt;/li&gt;
&lt;li&gt;服务器使用私钥解密信息，验证哈希，加密响应消息回发浏览器&lt;/li&gt;
&lt;li&gt;浏览器解密响应消息，并对消息进行验真，之后进行加密交互数据&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;http和https的区别&#34;&gt;HTTP和HTTPS的区别?&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;HTTPS需要到CA申请证书，HTTP不需要&lt;/li&gt;
&lt;li&gt;HTTPS密文传输，HTTP明文传输&lt;/li&gt;
&lt;li&gt;连接方式不同，HTTPS默认使用443端口，HTTP使用80端口&lt;/li&gt;
&lt;li&gt;HTTPS=HTTP+加密+认证+完整性保护，较HTTP安全&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;https真的很安全吗&#34;&gt;HTTPS真的很安全吗?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;那倒未必&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;浏览器默认填充http://，请求需要进行跳转，有被劫持的风险.&lt;/li&gt;
&lt;li&gt;可以使用HSTS（HTTP Strict Transport Security）优化.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TCP滑动窗口</title>
      <link>https://halklein.github.io/2019/009/</link>
      <pubDate>Sat, 02 Nov 2019 19:45:16 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/009/</guid>
      <description>

&lt;h2 id=&#34;1-rtt-和-rto&#34;&gt;1. RTT 和 RTO&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;RTT（round trip time） 往返时延 ：发送一个数据包到收到对应的ACK，所花费的时间。&lt;/li&gt;
&lt;li&gt;RTO（retransamission timeout） ：重传时间间隔，由RTT计算得出，不是写死的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由TCP的重传机制，我们知道Timeout的设置对重置非常重要，设置长了会影响重发效率，设置短了可能导致还没丢失就又重传了。 而网络状况更是复杂，所以我们没有办法设置一个死的Timeout值 。为了动态地设置，TCP引入了RTT， 这样发送端就大约知道需要多少的时间，从而可以方便地设置Timeout——RTO（ Retransmission TimeOut ） ， 以让重传机制更高效。 &lt;a href=&#34;http://tools.ietf.org/html/rfc793&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;RFC793&lt;/a&gt; 中有对算法详细的定义。&lt;/p&gt;

&lt;h2 id=&#34;2-tcp的滑动窗口&#34;&gt;2. TCP的滑动窗口&lt;/h2&gt;

&lt;p&gt;我们都知道，TCP必需要解决的可靠传输以及包乱序（reordering）的问题，所以，TCP必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。 所以，TCP引入了一些技术和设计来做网络流控，Sliding Window是其中一个技术。TCP头里有一个字段叫Window，又叫Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。&lt;/p&gt;

&lt;h3 id=&#34;下面-模拟tcp缓冲区&#34;&gt;&lt;strong&gt;下面，模拟TCP缓冲区：&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/JUC5zmwxbLkyvFq.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;发送端的LastByteAcked指向了被接收端Ack过的位置（表示成功发送确认），LastByteSent表示发出去了，但还没有收到成功确认的Ack，LastByteWritten指向的是上层应用正在写的地方。&lt;/li&gt;
&lt;li&gt;接收端LastByteRead指向了TCP缓冲区中读到的位置，NextByteExpected指向的地方是收到的连续包的最后一个位置，LastByteRcved指向的是收到的包的最后一个位置，我们可以看到中间有些数据还没有到达，所以有数据空白区。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;窗口数据计算过程&#34;&gt;&lt;strong&gt;窗口数据计算过程：&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;接收端在给发送端回ACK中，会汇报自己的 &lt;strong&gt;AdvertisedWindow&lt;/strong&gt; = MaxRcvBuffer – （LastByteRcvd – Last Byte Read），（LastByteRcvd – LastByteRead）表示接收到的数据已占用缓存的大小;&lt;/li&gt;
&lt;li&gt;发送方根据Advertised Window的值，要保证已发送未确认的数据&amp;lt;= Advertised Window的大小，待发送数据大小**EffectiveWindow **= AdvertisedWindow – (LastByteSent – LastByteAcked)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;滑动窗口的基本原理&#34;&gt;滑动窗口的基本原理&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;TCP会话的发送方，滑动窗口示意图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/cnU7JxGLl1hySEe.png&#34; alt=&#34;发送方滑动窗口示意图&#34; /&gt;发送方滑动窗口示意图&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TCP会话的接收方，滑动窗口示意图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/rFw3h7ES8Ze2VAb.png&#34; alt=&#34;接收方滑动窗口示意图&#34; /&gt;接收方滑动窗口示意图&lt;/p&gt;

&lt;p&gt;需要指出的是，滑动窗口的大小可以依据一定的策略动态调整。应用会根据自身处理能力的变化，通过对本端TCP接收窗口大小的控制来实现对端的发送窗口进行流量限制。&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TCP和UDP的区别</title>
      <link>https://halklein.github.io/2019/008/</link>
      <pubDate>Fri, 01 Nov 2019 14:26:16 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/008/</guid>
      <description>

&lt;h2 id=&#34;1-udp协议&#34;&gt;1. UDP协议&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;用户数据报协议&lt;/strong&gt;（英语：&lt;strong&gt;U&lt;/strong&gt;ser &lt;strong&gt;D&lt;/strong&gt;atagram &lt;strong&gt;P&lt;/strong&gt;rotocol，缩写：&lt;strong&gt;UDP&lt;/strong&gt;；又称&lt;strong&gt;用户数据包协议&lt;/strong&gt;）是一个简单的面向数据报的通信协议，位于OSI模型的传输层。该协议由 &lt;a href=&#34;https://zh.wikipedia.org/w/index.php?title=David_P._Reed&amp;amp;action=edit&amp;amp;redlink=1&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;David P. Reed&lt;/a&gt; 在1980年设计且在&lt;a href=&#34;https://tools.ietf.org/html/rfc768&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;RFC 768&lt;/a&gt;中被规范。典型网络上的众多使用UDP协议的关键应用在一定程度上是相似的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/tk53hsSwfUxFKAE.png&#34; alt=&#34;UDP头部结构&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;UDP头部包含了以下几个数据：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;两个16位的端口号，分别为源端口（可选）和目标端口&lt;/li&gt;
&lt;li&gt;数据报的长度&lt;/li&gt;
&lt;li&gt;数据报的检验和（IPv4 可选字段），该字段用于发现头部信息和数据中的错误&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;UDP相比于TCP明显要简单很多，因此UDP头部开销小，只有8个字节，在传输数据报文时是很高效的。当然也就不支持错误重传，滑动窗口等精细的控制。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;UDP的特点：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;面向非连接，传输数据之前不需要先建立连接。&lt;/li&gt;
&lt;li&gt;不维护连接状态，支持同时向多个客户端传输相同的消息， 支持一对一、一对多、多对多、多对一的传输方式，也就是说 UDP 提供了单播，多播，广播的功能。&lt;/li&gt;
&lt;li&gt;数据包报头只有8个字节，额外开销较小&lt;/li&gt;
&lt;li&gt;吞吐量只受限于数据生成速率、传输速率以及机器性能&lt;/li&gt;
&lt;li&gt;不可靠：尽最大努力交付，不保证可靠交付，不需要维持复杂的链接状态表&lt;/li&gt;
&lt;li&gt;面向报文，不对应用程序提交的报文信息进行拆分或者合并&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-tcp和udp的区别&#34;&gt;2. TCP和UDP的区别&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;TCP&lt;/th&gt;
&lt;th&gt;UDP&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;是否连接&lt;/td&gt;
&lt;td&gt;面向连接&lt;/td&gt;
&lt;td&gt;无连接&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;可靠性&lt;/td&gt;
&lt;td&gt;可靠传输，使用流量控制和拥塞控制&lt;/td&gt;
&lt;td&gt;不可靠传输，不使用流量控制和拥塞控制&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;有序性&lt;/td&gt;
&lt;td&gt;有序&lt;/td&gt;
&lt;td&gt;无序&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;速率&lt;/td&gt;
&lt;td&gt;慢&lt;/td&gt;
&lt;td&gt;快&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;量级&lt;/td&gt;
&lt;td&gt;重量级&lt;/td&gt;
&lt;td&gt;轻量级&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;连接对象个数&lt;/td&gt;
&lt;td&gt;只支持一对一通信&lt;/td&gt;
&lt;td&gt;支持一对一，一对多，多对一、多对多通信&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;传输方式&lt;/td&gt;
&lt;td&gt;面向字节流&lt;/td&gt;
&lt;td&gt;面向报文&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;首部开销&lt;/td&gt;
&lt;td&gt;首部最小20字节，最大60字节&lt;/td&gt;
&lt;td&gt;首部开销小，仅8字节&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;适用场景&lt;/td&gt;
&lt;td&gt;要求可靠传输的应用，例如文件传输&lt;/td&gt;
&lt;td&gt;实时应用（IP电话、视频会议、直播等）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TCP四次挥手</title>
      <link>https://halklein.github.io/2019/007/</link>
      <pubDate>Thu, 31 Oct 2019 13:56:16 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/007/</guid>
      <description>

&lt;h2 id=&#34;1-四次挥手-关闭连接&#34;&gt;1. 四次挥手，关闭连接&lt;/h2&gt;

&lt;p&gt;由于TCP连接是全双工的，即连接双方可以在一条TCP连接上互相传输数据，每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个&lt;code&gt;FIN&lt;/code&gt;来终止这个方向的连接。收到一个&lt;code&gt;FIN&lt;/code&gt;只意味着这一方向上没有数据流动，一个 TCP 连接在收到一个&lt;code&gt;FIN&lt;/code&gt;后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭，因此在断开时存在一个半关闭状态，即有有一方失去发送数据的能力，却还能接收数据。所以，断开连接需要分为四次 ，称为&lt;strong&gt;四次挥手&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行&lt;code&gt;close()&lt;/code&gt;操作即可产生挥手操作。&lt;/p&gt;

&lt;p&gt;以下，我们假设由客户端主动触发close()。&lt;/p&gt;

&lt;h2 id=&#34;2-四次挥手流程图&#34;&gt;2. 四次挥手流程图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/5pbistqQF7XTxBV.png&#34; alt=&#34;四次挥手流程图&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;第一次挥手(FIN=1，seq=u)&lt;/strong&gt;
假设假客户端主动触发close()，客户端发送一个FIN标志位为 1 的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。因为有可能服务器还要发送数据，所以发送自己的序列号seq=u，等待服务器确认。发送完毕后，客户端进入FIN_WAIT_1状态。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;第二次挥手(ACK=1，seq=v，ack=u+1)&lt;/strong&gt;
服务器端确认客户端的FIN包，发送一个确认包【ACK=1(确认)、seq=v(自己的序列号)、ack=u+1(确认收到序列号)】，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接(可能有数据发送)。
发送完毕后，服务器端进入CLOSE_WAIT状态，客户端接收到这个确认包之后，进入FIN_WAIT_2状态，等待服务器端关闭连接。
在这过程中 TCP 服务器进程会通知高层应用进程。然后从客户端到服务器这个方向的连接就释放了，TCP 连接处于半关闭状态。但是服务器若发送数据，客户端仍要接收。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;第三次挥手(FIN=1，ACK=1，seq=w，ack=u+1)&lt;/strong&gt;
若服务器已经没有要向客户端发送的数据，其应用进程就通知 TCP 释放连接。
服务器端准备好关闭连接时，向客户端发送结束连接请求FIN置为 1，ACK=1，seq=w(有数据发送过)，ack=u+1。
发送完毕后，服务器端进入LAST_ACK状态，等待来自客户端的最后一个ACK。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;第四次挥手(ACK=1，seq=u+1，ack=w+1)&lt;/strong&gt;
客户端接收到来自服务器端的关闭请求，发送一个确认包(在确认报文段中ACK=1，确认号ack=w+1，自己的序号seq=u+1)，并进入TIME_WAIT状态，等待可能出现的要求重传的ACK包。(这个确认包是内核进行发送的，上面不能发数据的是客户端的send函数)
服务器端接收到这个确认包之后，关闭连接，进入CLOSED状态。
客户端等待了某个固定时间（两个最大段生命周期，&lt;code&gt;2MSL&lt;/code&gt;（2 Maximum Segment Lifetime），即2个最长报文段寿命， &lt;code&gt;RFC 793&lt;/code&gt;中规定MSL为2分钟，而Linux中设置为30秒 ）之后，没有收到服务器端的ACK，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入CLOSED状态。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-四次挥手抓包分析&#34;&gt;3. 四次挥手抓包分析&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/4ZnKhodQpuNfmiE.png&#34; alt=&#34;四次挥手抓包分析&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;4-问题&#34;&gt;4. 问题&lt;/h2&gt;

&lt;h3 id=&#34;为什么会有time-wait状态&#34;&gt;为什么会有TIME_WAIT状态？&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;网络可能不可靠，需要确保有足够的时间让对方收到ACK包。被动关闭方处于&lt;code&gt;LAST_ACK&lt;/code&gt;状态下的&lt;code&gt;SOCKET&lt;/code&gt;可能会因为超时未收到ACK报文，而重发FIN报文（这一来一去正好是2SML）。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;避免新旧连接混淆。有的路由器会缓存IP数据包，如果连接被重用了，那么这些延迟收到的包就有可能会跟新连接混在一起。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;time-wait状态会带来的影响&#34;&gt;TIME_WAIT状态会带来的影响 ?&lt;/h3&gt;

&lt;p&gt;当某个连接的一端处于TIME_WAIT状态时，该连接将不能再被使用。事实上，对于我们比较有现实意义的是，这个端口将不能再被使用。&lt;/p&gt;

&lt;p&gt;某个端口处于TIME_WAIT状态(其实应该是这个连接)时，这意味着这个 TCP 连接并没有断开(完全断开)，那么，如果你bind这个端口，就会失败。对于服务器而言，如果服务器突然坏掉了，那么它将无法再2MSL内重新启动，因为bind会失败。&lt;/p&gt;

&lt;p&gt;解决这个问题的一个方法就是设置 socket 的&lt;code&gt;SO_REUSEADDR&lt;/code&gt;选项。这个选项意味着你可以重用一个地址。&lt;/p&gt;

&lt;h3 id=&#34;服务器出现大量close-wait状态的原因&#34;&gt;服务器出现大量CLOSE_WAIT状态的原因？&lt;/h3&gt;

&lt;p&gt;对方关闭socket连接，我方忙于读或写，没有及时关闭连接。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;检查代码，特别是释放资源的代码&lt;/li&gt;
&lt;li&gt;检查配置，特别是处理请求的线程配置&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以使用以下命令查看服务器是否有大量CLOSE_WAIT&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;netstat -n | awk &#39;/^tcp/{++S[$NF]}END{for(a in S) print a,S[a]}&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/5XsPjp2oZCmOngW.jpg&#34; alt=&#34;MacOS下的测试&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;为什么需要四次握手才能断开连接&#34;&gt;为什么需要四次握手才能断开连接？&lt;/h3&gt;

&lt;p&gt;因为全双工，发送方和接收方都需要FIN报文和ACK报文，当被动方收到主动方的FIN报文通知时，它仅仅表示主动方没有数据再发送给被动方了。但未必被动方所有的数据都完整的发送给了主动方，所以被动方不会马上关闭SOCKET，它可能还需要发送一些数据给主动方后，再发送FIN报文给主动方，告诉主动方同意关闭连接，所以这里的ACK报文和FIN报文多数情况下都是分开发送的。&lt;/p&gt;

&lt;p&gt;由于网络服务的不可靠性，必须考虑到在释放连接时，可能由于数据包的失序而使释放连接请求的数据包会比其他数据包先到达目的端。此时，如果目的端由于收到了释放连接请求的数据包而立即释放该连接，则会造成那些先发而后至的数据包丢失。&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TCP三次握手</title>
      <link>https://halklein.github.io/2019/006/</link>
      <pubDate>Thu, 31 Oct 2019 09:14:18 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/006/</guid>
      <description>

&lt;h2 id=&#34;1-tcp-transmission-control-protocol-传输控制协议&#34;&gt;1. TCP(Transmission Control Protocol)　传输控制协议&lt;/h2&gt;

&lt;p&gt;TCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接。&lt;/p&gt;

&lt;p&gt;TCP工作在网络 OSI 的七层模型中的第四层（Transport层），IP在第三层（Network层），ARP在第二层（Data Link层）；在第二层上的数据，我们把它叫Frame，在第三层上的数据叫Packet，第四层的数据叫Segment。 数据从应用层发下来，会在每一层都会加上头部信息，进行封装，然后再发送到数据接收端。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一种&lt;strong&gt;面向连接的、可靠的、基于字节流的&lt;/strong&gt;传输层通信协议&lt;/li&gt;
&lt;li&gt;将应用层的数据流分割成报文段并发送给目标节点的TCP层&lt;/li&gt;
&lt;li&gt;数据包都有序号，对方收到则发送ACK确认，未收到则重传&lt;/li&gt;
&lt;li&gt;使用校验和来检验数据在传输过程中是否有误&lt;/li&gt;
&lt;li&gt;在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP&lt;/li&gt;
&lt;li&gt;TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复&lt;/li&gt;
&lt;li&gt;TCP 使用&lt;strong&gt;滑动窗口机制&lt;/strong&gt;来实现流量控制，通过动态改变窗口的大小进行拥塞控制&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在进行数据传输之前，需要在传输数据的两端（客户端和服务器端）创建一个连接，这个连接由一对插口地址唯一标识，即是在IP报文首部的源IP地址、目的IP地址，以及TCP数据报首部的源端口地址和目的端口地址&lt;/p&gt;

&lt;h2 id=&#34;2-tcp头部结构&#34;&gt;2. TCP头部结构&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/dLhNgTlbYtBA3FW.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Source port&lt;/code&gt;源端口、&lt;code&gt;Destination port&lt;/code&gt;目的端口，他们各占用2个字节。TCP和UDP的数据包都是不包含IP地址信息的，因为那是IP层要处理的，但是TCP和UDP都会有源端口和目的端口。在计算机本地我们可以用PID唯一标识一个进程，但是在网络中不同计算机的进程可能会有相同的PID，可以通过在传输层中使用协议端口号来解决，这样我们就可以用 IP+协议+端口号来唯一标识网络中的一个进程.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Sequence Number&lt;/code&gt;序号：Seq序号，占4个字节，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。是包的序号，用来解决网络包乱序（reordering）问题。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Acknowledgement Number&lt;/code&gt;确认序号：Ack序号，占4个字节，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Data offset&lt;/code&gt;数据偏移：由于头部有可选字段长度不固定，因此它指出TCP报文的数据离TCP报文起始有多远。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Reserved&lt;/code&gt;保留域：保留以后使用的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;TCP Flags&lt;/code&gt; 标志位：常见的有6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;URG&lt;/code&gt; 紧急指针标志：为1时有效，为0则忽略。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ACK&lt;/code&gt; &lt;strong&gt;确认序号标志&lt;/strong&gt;：为1时确认号有效，为0标识报文中不含确认信息。 TCP 规定在连接建立后传送的所有报文段都必须把 ACK 置为一。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;PSH&lt;/code&gt; push标志：为1时，指示接收方接收到报文后应该尽快将这个报文交给应用层程序，而不是在缓冲区排队。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;RST&lt;/code&gt; 重置连接标志：重置连接，重置由于主机崩溃或其它原因而出现的异常连接，或者用于拒绝非法的报文段和拒绝连接请求。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SYN&lt;/code&gt; &lt;strong&gt;同步序号&lt;/strong&gt;：用于建立连接过程。 当SYN=1，ACK=0时，表示当前报文段是一个连接请求报文。当SYN=1，ACK=1时，表示当前报文段是一个同意建立连接的应答报文。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;FIN&lt;/code&gt; &lt;strong&gt;finish标志&lt;/strong&gt;：用于释放连接。为1时， 该字段为一表示此报文段是一个释放连接的请求报文&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Window Size&lt;/code&gt;窗口大小，指滑动窗口的大小，用于告知发送端接受方的缓存大小，以此控制发送端发送数据的速率从而进行流量控制 。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Checksum&lt;/code&gt;校验和，指奇偶校验，对整个TCP报文以16位进行计算所得，由发送端计算和存储并由接收端验证。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Urgent Pointer&lt;/code&gt; 紧急指针，当TCP Flags中的&lt;code&gt;URG&lt;/code&gt;为1时才有效，指出本TCP报文中紧急数据的字节数。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;TCP Options&lt;/code&gt; 可选项，其长度可变，定义一些其它的可选参数。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;3-tcp三次握手&#34;&gt;3. TCP三次握手&lt;/h2&gt;

&lt;p&gt;“握手”是为了&lt;strong&gt;建立连接&lt;/strong&gt;，TCP三次握手的流程图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/tbrGiOqwZ6Jpe3K.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;其中，前两次握手是不允许携带数据的，第三握手可以携带数据，如果第三次握手不携带数据就可以不消耗序号。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第一次握手&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;建立连接时， Client将标志位SYN置为1，随机产生一个值seq=x ， 并将该数据包发送给Server ，Client进入SYN_SEND状态，等待Server 确认；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第二次握手&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Server 收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1  ， ack=x+1 ，同时随机产生一个值seq=y ， 并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第三次握手&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Client收到Server的SYN+ACK包， 检查ack是否为y+1，标志位ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，seq=x+1， 并将该数据包发送给Server ;  Server检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;不要将确认序号ack与标志位中的ACK搞混了。&lt;/li&gt;
&lt;li&gt;确认方ack=发起方seq+1，两端配对。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-三次握手抓包分析&#34;&gt;4. 三次握手抓包分析&lt;/h2&gt;

&lt;p&gt;筛选过滤，将我们访问的地址作为筛选的 目标地址 和 源地址，筛选出 源地址 是因为三次握手中，访问的地址也会作为源地址向我们的计算机发送请求。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;ip.dst==61.128.252.10 or ip.src==61.128.252.10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/pbmqrR3fvd2xls4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;顺便查阅归纳下，&lt;strong&gt;Wireshark的过滤规则&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 过滤IP&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;ip.src eq 192.168.1.108 or ip.dst eq 192.168.1.108
或者ip.addr eq 192.168.1.107
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2. 过滤端口&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;tcp.port eq 80 //不管端口是源端口的还是目标端口都显示
tcp.port eq 80 or udp.port eq 80
tcp.dstport == 80 //只显tcp协议的目标端口80
tcp.srcport == 80 //只显tcp协议的源端口80
tcp.port &amp;gt;= 1 and tcp.port &amp;lt;= 80 //端口范围过滤
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3. 过滤协议&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;直接输入协议名：tcp、udp、arp、icmp、http、smtp、ftp、dns、msnms、ip、ssl、oicq、bootp等
排除协议过滤：如 !arp 或者 not arp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;4. 过滤MAC&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;eth.dst == 48:7d:2e:98:61:d1 或 eth.dst==48-7d-2e-98-61-d1 //过滤目标mac
eth.src eq 48:7d:2e:98:61:d1 //过滤来源mac
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;小于 less than（lt）&lt;/p&gt;

&lt;p&gt;等于 eq&lt;/p&gt;

&lt;p&gt;大于等于 ge&lt;/p&gt;

&lt;p&gt;不等 ne&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5. 包长度过滤&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;udp.length == 26 //这个长度是指udp本身固定长度8加上udp下面那块数据包之和
tcp.len &amp;gt;= 7   //指的是ip数据包(tcp下面那块数据),不包括tcp本身
ip.len == 94 //除了以太网头固定长度14,其它都算是ip.len,即从ip本身到最后
frame.len == 119 //整个数据包长度,从eth开始到最后
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;6. http模式过滤&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;例子:
http.request.method == “GET”
http.request.method == “POST”
http.request.uri == “/img/logo.png”
http contains “GET”
http contains “HTTP/1.”
http.request.method == “GET” &amp;amp;&amp;amp; http contains “Host: “

http.host == xxx.com	// 过滤 host
http.response == 1	// 过滤所有的 http 响应包
http.response.code == 302	// 过滤状态码 202
http.request.method==POST 	// 过滤 POST 请求包
http.cookie contains xxx	// cookie 包含 xxx
http.request.uri==&amp;quot;/robots.txt&amp;quot;	//过滤请求的uri，取值是域名后的部分
http.request.full_uri==&amp;quot;http://1.com&amp;quot;	// 过滤含域名的整个url
http.server contains &amp;quot;nginx&amp;quot;	//过滤http头中server字段含有nginx字符的数据包
http.content_type == &amp;quot;text/html&amp;quot;	//过滤content_type是text/html
http.content_encoding == &amp;quot;gzip&amp;quot;	//过滤content_encoding是gzip的http包
http.transfer_encoding == &amp;quot;chunked&amp;quot;	//根据transfer_encoding过滤
http.content_length == 279
http.content_length_header == &amp;quot;279&amp;quot;	//根据content_length的数值过滤
http.request.version == &amp;quot;HTTP/1.1&amp;quot;	//过滤HTTP/1.1版本的http包，包括请求和响应
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;5-问题&#34;&gt;5. 问题&lt;/h2&gt;

&lt;h3 id=&#34;为什么需要三次握手才能建立起连接&#34;&gt;为什么需要三次握手才能建立起连接&lt;/h3&gt;

&lt;p&gt;为了初始化Sequence Number的初始值，通信双方要互相通知对方自己的Sequence Number，作为以后数据通信的序号，以保证接收到的数据不会因为网络上的问题而乱序，即TCP会用这个序号来拼接数据， 确保数据能够完整传输。&lt;/p&gt;

&lt;h3 id=&#34;首次握手的隐患-syn超时&#34;&gt;首次握手的隐患&amp;ndash;SYN超时&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;原因&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;三次握手过程中，Server收到Client的SYN，回复SYN-ACK后（ Server收到Client的ACK之前的TCP连接称为半连接（&lt;code&gt;half-open connect&lt;/code&gt;），此时Server处于SYN_RCVD状态 ）， Cient就掉线了，Server端没有收到Client的ACK确认。 于是 Server会不断重试直到超时，在Linux系统中会默认进行5次重试（每次重试隔时间从1s开始每次都翻售 ，即1+2+4+6+8+16+32=63秒）TCP才断开连接。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SYN攻击&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，把Server的syn连接的队列耗尽 ，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;检测&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以可以查看&lt;code&gt;SYN_RECV&lt;/code&gt;状态：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;# netstat -nap | grep SYN_RECV
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;针对SYN Flood的防护措施&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Linux下给了一个叫&lt;code&gt;tcp_syncookies&lt;/code&gt;的参数来应对这个事——当SYN队列满了后，TCP会通过源地址端口、目标地址端口和时间戳打造出一个特别的&lt;code&gt;Sequence Number&lt;/code&gt;发回去（又叫SYN Cookie），如果是攻击者则不会有响应，如果是正常连接，则会把这个 &lt;code&gt;SYN Cookie&lt;/code&gt;发回来，然后服务端可以通过cookie建连接（即使你不在SYN队列中）。请注意，慎用&lt;code&gt;tcp_syncookies&lt;/code&gt;来处理正常的大负载的连接的情况。因为，&lt;code&gt;synccookies&lt;/code&gt;是妥协版的TCP协议，并不严谨。 对于正常的请求，可以调整以下三个参数：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;tcp_synack_retries&lt;/code&gt; ，用于减少重试次数；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tcp_max_syn_backlog&lt;/code&gt;，用于增大SYN连接数；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tcp_abort_on_overflow&lt;/code&gt; ，处理不过来，直接拒绝连接了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;保活机制&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果建立连接后，Client出现故障，向对方发送保活探测报文，如果未收到响应则继续发送，尝试次数达到保活探测数仍未收到响应则中断连接&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>OSI模型和TCP/IP模型</title>
      <link>https://halklein.github.io/2019/005/</link>
      <pubDate>Thu, 31 Oct 2019 09:06:36 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/005/</guid>
      <description>

&lt;h2 id=&#34;1-osi-开放式系统互联参考模型&#34;&gt;1. OSI 开放式系统互联参考模型&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;开放式系统互联模型&lt;/strong&gt;（英语：&lt;strong&gt;O&lt;/strong&gt;pen &lt;strong&gt;S&lt;/strong&gt;ystem &lt;strong&gt;I&lt;/strong&gt;nterconnection Model，缩写：OSI；简称为&lt;strong&gt;OSI模型&lt;/strong&gt;）是一种&lt;a href=&#34;https://zh.wikipedia.org/wiki/概念模型&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;概念模型&lt;/a&gt;，由&lt;a href=&#34;https://zh.wikipedia.org/wiki/国际标准化组织&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;国际标准化组织&lt;/a&gt;提出，一个试图使各种计算机在世界范围内互连为网络的标准框架。定义于ISO/IEC 7498-1。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/TLr5NUxWHKmJszP.gif&#34; alt=&#34;OSI 开放式系统互联参考模型&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;物理层-physical-layer&#34;&gt;物理层（Physical Layer）&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/N2o1gwMl95GfFsD.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在局部局域网上传送&lt;a href=&#34;https://zh.wikipedia.org/wiki/数据帧&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;数据帧&lt;/a&gt;（data frame），它负责管理电脑通信设备和网络媒体之间的互通， 定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率 ，主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换），这一层的数据叫做比特，单位是bit比特。包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机接口卡、 调制解调器等。典型的协议有 RS 232C、RS 449/422/423、V.24 和 X.21、X.21bis&lt;/p&gt;

&lt;h3 id=&#34;数据链路层-datalink-layer&#34;&gt;数据链路层&lt;strong&gt;（Datalink Layer）&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/oSpjkPZy9ftYGVa.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;定义了如何让格式化数据以进行传输，以及如何让控制对物理介质的访问，这一层通常还提供错误检测和纠正，以确保数据的可靠传输。交换机(二层)、网桥设备在这一层。数据链路层协议的代表包括： &lt;code&gt;HDLC&lt;/code&gt; 、&lt;code&gt;PPP&lt;/code&gt;、&lt;code&gt;STP&lt;/code&gt;等。&lt;/p&gt;

&lt;h3 id=&#34;网络层-network-layer&#34;&gt;网络层 &lt;strong&gt;（Network Layer）&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/wexCdOuZ2QH54B3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择，Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。网络层负责在源机器和目标机器之间建立它们所使用的路由。路由器在该层。协议有：&lt;code&gt;IP&lt;/code&gt;、&lt;code&gt;ICMP&lt;/code&gt;（互联网控制报文协议）、&lt;code&gt;ARP&lt;/code&gt;（地址转换协议）、&lt;code&gt;RARP&lt;/code&gt;（反向地址转换协议）&lt;/p&gt;

&lt;h3 id=&#34;传输层-transport-layer&#34;&gt;&lt;strong&gt;传输层（Transport Layer）&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/YQgGIThdiAEn23f.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;OSI 模型中最重要的一层。定义了一些传输数据的协议和端口号（WWW端口80等），如：&lt;code&gt;TCP&lt;/code&gt;（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），&lt;code&gt;UDP&lt;/code&gt;（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）， 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组，常常把这一层数据叫做段。&lt;/p&gt;

&lt;h3 id=&#34;会话层-session-layer&#34;&gt;&lt;strong&gt;会话层（Session Layer）&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/4hayBOXImwVbAct.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;负责在网络中的两节点之间建立、维持和终止通信。 会话层的功能包括：建立通信链接，保持会话过程通信链接的畅通，同步两个节点之间的对话，决定通信是否被中断以及通信中断时决定从何处重新发送。&lt;/p&gt;

&lt;p&gt;通过传输层（端口号：传输端口与接收端口）建立数据传输的通路，主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。&lt;/p&gt;

&lt;p&gt;常见的协议有 &lt;code&gt;ADSP&lt;/code&gt;、&lt;code&gt;RPC&lt;/code&gt; 等。&lt;/p&gt;

&lt;h3 id=&#34;表示层-presentation-layer&#34;&gt;&lt;strong&gt;表示层（Presentation Layer）&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/PRd9vurV1UCfqTw.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;应用程序和网络之间的翻译官，在表示层，数据将按照网络能理解的方案进行格式化；这种格式化也因所使用网络的类型不同而不同。表示层管理数据的解密与加密，如系统口令的处理。可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。 常见的协议有&lt;code&gt;ASCII&lt;/code&gt;、&lt;code&gt;SSL/TLS&lt;/code&gt; 等。&lt;/p&gt;

&lt;h3 id=&#34;应用层-application-layer&#34;&gt;&lt;strong&gt;应用层（Application Layer）&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/qTcn6Y3klSOetdN.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;是最靠近用户的OSI层，这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务 。常见的协议有 &lt;code&gt;HTTP&lt;/code&gt;，&lt;code&gt;FTP&lt;/code&gt;，&lt;code&gt;TELNET&lt;/code&gt;、&lt;code&gt;SMTP&lt;/code&gt; 等。&lt;/p&gt;

&lt;h3 id=&#34;osi模型-数据传输流程概览&#34;&gt;OSI模型 数据传输流程概览&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/peH8BVr75dWE34c.png&#34; alt=&#34;&#34; style=&#34;zoom:67%;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-tcp-ip四层网络模型&#34;&gt;2. TCP/IP四层网络模型&lt;/h2&gt;

&lt;h3 id=&#34;提出&#34;&gt;提出&lt;/h3&gt;

&lt;p&gt;OSI模型是一个定义良好的协议规范集，定义了开放系统的层次结构和之间的关系，但并没有提供一个可实现的方法，其并非一个标准，而是一个慨念型框架。TCP/IP是被广泛使用的OSI模型的实现。&lt;/p&gt;

&lt;h3 id=&#34;简介&#34;&gt;简介&lt;/h3&gt;

&lt;p&gt;TCP/IP协议栈是美国国防部高级研究计划局计算机网（Advanced Research Projects Agency Network，ARPANET）和其后继因特网使用的参考模型。ARPANET是由美国国防部（U.S．Department of Defense，DoD）赞助的研究网络。最初，它只连接了美国境内的四所大学。随后的几年中，它通过租用的电话线连接了数百所大学和政府部门。最终ARPANET发展成为全球规模最大的互连网络-因特网。最初的ARPANET于1990年永久性地关闭。&lt;/p&gt;

&lt;p&gt;TCP/IP是一组协议的代名词，它&lt;strong&gt;还包括许多协议，组成了TCP/IP协议簇&lt;/strong&gt;。TCP/IP协议簇分为四层，IP位于协议簇的第二层(对应OSI的第三层)，TCP位于协议簇的第三层(对应OSI的第四层)。&lt;/p&gt;

&lt;h3 id=&#34;层次&#34;&gt;层次&lt;/h3&gt;

&lt;p&gt;TCP/IP协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的网络来完成自己的需求。分别为：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;应用层&lt;/strong&gt;：应用程序间沟通的层，如简单电子邮件传输（SMTP）、文件传输协议（FTP）、网络远程访问协议（Telnet）等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;传输层&lt;/strong&gt;：在此层中，它提供了节点间的数据传送服务，如传输控制协议（TCP）、用户数据报协议（UDP）等，TCP和UDP给数据包加入传输数据并把它传输到下一层中，这一层负责传送数据，并且确定数据已被送达并接收。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;网络层&lt;/strong&gt;：负责提供基本的数据封包传送功能，让每一块数据包都能够到达目的主机（但不检查是否被正确接收），如网际协议（IP）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;网络接口层&lt;/strong&gt;：对实际的网络媒体的管理，定义如何使用实际网络（如Ethernet、Serial Line等）来传送数据。&lt;/p&gt;

&lt;h3 id=&#34;对应关系及协议整理&#34;&gt;对应关系及协议整理&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/Ip71j6NFub3Ugr5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;tcp-ip模型-数据传输流程概览&#34;&gt;TCP/IP模型 数据传输流程概览&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/NWbI9otOVEwkJaL.png&#34; alt=&#34;&#34; style=&#34;zoom:50%;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;3-问题&#34;&gt;3. 问题&lt;/h2&gt;

&lt;h3 id=&#34;交换机工作在osi的哪一层&#34;&gt;交换机工作在OSI的哪一层？&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;二层交换机&lt;/strong&gt; 工作在OSI的第二层数据链路层，，由于它们要对帧解码并使用帧信息将数据发送到正确的接收方，所以它们是工作在数据链路层的。
&lt;strong&gt;三层交换机&lt;/strong&gt; 是工作在OSI的网络层，因为三层交换机有路由功能。&lt;/p&gt;

&lt;h3 id=&#34;路由器工作在osi的哪一层&#34;&gt;路由器工作在OSI的哪一层？&lt;/h3&gt;

&lt;p&gt;路由器工作在OSI七层模型的第3层，网络层。由于网络层处理，并智能指导数据传送，路由器连接网络各段，所以路由器属于网络层。在网络中，“路由”是基于编址方案、使用模式以及可达性来指引数据的发送。 网络层负责在源机器和目标机器之间建立它们所使用的路由。&lt;/p&gt;

&lt;h3 id=&#34;ping命令使用osi哪一层协议&#34;&gt;PING命令使用OSI哪一层协议？&lt;/h3&gt;

&lt;p&gt;ping命令使用的是ICMP协议，位于OSI七层网络模型中的第三层，网络层。&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>