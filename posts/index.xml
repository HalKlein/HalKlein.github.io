<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on HalKlein`s Blog</title>
    <link>https://halklein.github.io/posts/</link>
    <description>Recent content in Posts on HalKlein`s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <managingEditor>dev.HalKlein@gmail.com (HalKlein)</managingEditor>
    <webMaster>dev.HalKlein@gmail.com (HalKlein)</webMaster>
    <lastBuildDate>Tue, 05 Nov 2019 09:31:12 +0800</lastBuildDate>
    <atom:link href="https://halklein.github.io/posts/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Socket 入门</title>
      <link>https://halklein.github.io/2019/11/</link>
      <pubDate>Tue, 05 Nov 2019 09:31:12 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/11/</guid>
      <description>

&lt;h2 id=&#34;进程间通信&#34;&gt;进程间通信&lt;/h2&gt;

&lt;p&gt;网络中进程进行通信的前提是每个进程都要有唯一的标识，在本地计算机中我们可以用PID来唯一标识一个进程，可以多个计算机处在网络中时，不同计算机的进程PID冲突的可能性就很大。怎么办呢？我们知道IP地址可以唯一标识主机，而TCP协议和端口号可以唯一标识主机的一个进程，这样我们就可以用 IP+协议+端口号 来唯一标识网络中的一个进程了。&lt;/p&gt;

&lt;p&gt;使用TCP/IP协议的应用程序通常采用应用编程接口：UNIX BSD的套接字（socket）和UNIX System V的TLI（已经被淘汰），来实现网络进程之间的通信。就目前而言，几乎所有的应用程序都是采用socket。&lt;/p&gt;

&lt;h2 id=&#34;什么是socket&#34;&gt;什么是Socket？&lt;/h2&gt;

&lt;p&gt;网络套接字（英语：Network socket；又译网络套接字、网络接口、网络插槽）在计算机科学中是电脑网络中行程间数据流的端点。使用以网际协议（Internet Protocol）为通信基础的网络套接字，称为网际套接字（Internet socket）。因为网际协议的流行，现代绝大多数的网络套接字，都是属于网际套接字。&lt;/p&gt;

&lt;p&gt;socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&amp;gt; 读写write/read –&amp;gt; 关闭close”模式来操作。我的理解就是Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/tl96CpP3Qv4fMEV.jpg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Socket与TCP/IP协议并没有必然的联系，Socket编程接口在设计的时候就希望能适应其它的网络协议，所以Socket的出现是为了我们更好地使用TCP/IP协议栈，是对TCP/IP协议的抽象，是操作系统对外开放的接口。&lt;/p&gt;

&lt;h2 id=&#34;socket通信流程&#34;&gt;socket通信流程&lt;/h2&gt;

&lt;p&gt;以使用TCP协议通讯的socket为例，其交互流程大概是这样子的&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/aJRALE8cFmZonkg.png&#34; alt=&#34;Socket通信流程&#34; /&gt;Socket通信流程&lt;/p&gt;

&lt;h2 id=&#34;实列&#34;&gt;实列&lt;/h2&gt;

&lt;h3 id=&#34;编写一个网络应用程序-包含客户端和服务端-客户端向服务端发送一个字符串-服务端收到字符串并打印到命令行同时向客户端返回字符串长度-最后客户端输出收到的字符串长度-分别用tcp和udp实现&#34;&gt;&lt;strong&gt;编写一个网络应用程序，包含客户端和服务端，客户端向服务端发送一个字符串，服务端收到字符串并打印到命令行同时向客户端返回字符串长度，最后客户端输出收到的字符串长度，分别用TCP和UDP实现。&lt;/strong&gt;&lt;/h3&gt;

&lt;h4 id=&#34;tcp方式&#34;&gt;TCP方式：&lt;/h4&gt;

&lt;p&gt;服务端&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TCPServer {
    public static void main(String[] args) throws Exception {
        //创建socket,并将socket绑定到65000端口
        ServerSocket ss = new ServerSocket(65000);
        //死循环，使得socket一直等待并处理客户端发送过来的请求
        while (true) {
            //监听65000端口，直到客户端返回连接信息后才返回
            Socket socket = ss.accept();
            //获取客户端的请求信息后，执行相关业务逻辑
            new LengthCalculator(socket).start();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;服务端业务逻辑&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class LengthCalculator extends Thread {
    //以socket为成员变量
    private Socket socket;
    public LengthCalculator(Socket socket) {
        this.socket = socket;
    }
    @Override
    public void run() {
        try {
            //获取socket的输出流
            OutputStream os = socket.getOutputStream();
            //获取socket的输入流
            InputStream is = socket.getInputStream();
            int ch = 0;
            byte[] buff = new byte[1024];
            //buff主要用来读取输入的内容，存成byte数组，ch主要用来获取读取数组的长度
            ch = is.read(buff);
            //将接收流的byte数组转换成字符串，这里获取的内容是客户端发送过来的字符串参数
            String content = new String(buff, 0, ch);
            System.out.println(content);
            //往输出流里写入获得的字符串的长度，回发给客户端
            os.write(String.valueOf(content.length()).getBytes());
            //不要忘记关闭输入输出流以及socket
            is.close();
            os.close();
            socket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;客户端&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TCPClient {
    public static void main(String[] args) throws Exception {
        //创建socket，并指定连接的是本机的端口号为65000的服务器socket
        Socket socket = new Socket(&amp;quot;127.0.0.1&amp;quot;, 65000);
        //获取输出流
        OutputStream os = socket.getOutputStream();
        //获取输入流
        InputStream is = socket.getInputStream();
        //将要传递给server的字符串参数转换成byte数组，并将数组写入到输出流中
        os.write(new String(&amp;quot;hello world&amp;quot;).getBytes());
        int ch = 0;
        byte[] buff = new byte[1024];
        //buff主要用来读取输入的内容，存成byte数组，ch主要用来获取读取数组的长度
        ch = is.read(buff);
        //将接收流的byte数组转换成字符串，这里是从服务端回发回来的字符串参数的长度
        String content = new String(buff, 0, ch);
        System.out.println(content);
        //不要忘记关闭输入输出流以及socket
        is.close();
        os.close();
        socket.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/Rg5GzaCweFlMtjL.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/iITvbCjR18d2HMY.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;UDP方式：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;服务端&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UDPServer {
    public static void main(String[] args) throws Exception {
        // 服务端接受客户端发送的数据报
        DatagramSocket socket = new DatagramSocket(65001); //监听的端口号
        byte[] buff = new byte[100]; //存储从客户端接受到的内容
        DatagramPacket packet = new DatagramPacket(buff, buff.length);
        //接受客户端发送过来的内容，并将内容封装进DatagramPacket对象中
        socket.receive(packet);
        byte[] data = packet.getData(); //从DatagramPacket对象中获取到真正存储的数据
        //将数据从二进制转换成字符串形式
        String content = new String(data, 0, packet.getLength());
        System.out.println(content);
        //将要发送给客户端的数据转换成二进制
        byte[] sendedContent = String.valueOf(content.length()).getBytes();
        // 服务端给客户端发送数据报
        //从DatagramPacket对象中获取到数据的来源地址与端口号
        DatagramPacket packetToClient = new DatagramPacket(sendedContent,
                sendedContent.length, packet.getAddress(), packet.getPort());
        socket.send(packetToClient); //发送数据给客户端
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;客户端&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UDPClient {
    public static void main(String[] args) throws Exception {
        // 客户端发数据报给服务端
        DatagramSocket socket = new DatagramSocket();
        // 要发送给服务端的数据
        byte[] buf = &amp;quot;Hello World&amp;quot;.getBytes();
        // 将IP地址封装成InetAddress对象
        InetAddress address = InetAddress.getByName(&amp;quot;127.0.0.1&amp;quot;);
        // 将要发送给服务端的数据封装成DatagramPacket对象 需要填写上ip地址与端口号
        DatagramPacket packet = new DatagramPacket(buf, buf.length, address,
                65001);
        // 发送数据给服务端
        socket.send(packet);
        // 客户端接受服务端发送过来的数据报
        byte[] data = new byte[100];
        // 创建DatagramPacket对象用来存储服务端发送过来的数据
        DatagramPacket receivedPacket = new DatagramPacket(data, data.length);
        // 将接受到的数据存储到DatagramPacket对象中
        socket.receive(receivedPacket);
        // 将服务器端发送过来的数据取出来并打印到控制台
        String content = new String(receivedPacket.getData(), 0,
                receivedPacket.getLength());
        System.out.println(content);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/RuBrkvAVp5aFTx3.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>HTTP 与 HTTPS</title>
      <link>https://halklein.github.io/2019/10/</link>
      <pubDate>Sun, 03 Nov 2019 15:52:12 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/10/</guid>
      <description>

&lt;h2 id=&#34;1-http协议&#34;&gt;1. HTTP协议&lt;/h2&gt;

&lt;p&gt;超文本传输协议（英语：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。 通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接 。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HTTP 协议构建于 TCP/IP 协议之上，是一个应用层协议，默认端口号是 80&lt;/li&gt;
&lt;li&gt;HTTP 是&lt;strong&gt;无连接无状态&lt;/strong&gt;的&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-版本&#34;&gt;2. 版本&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;HTTP/0.9&lt;/strong&gt; 已过时。只接受GET一种请求方法，没有在通讯中指定版本号，且不支持请求头。由于该版本不支持POST方法，因此客户端无法向服务器传递太多信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HTTP/1.0&lt;/strong&gt; 这是第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用，特别是在代理服务器中。[来源请求]&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HTTP/1.1&lt;/strong&gt; 持久连接被默认采用，并能很好地配合代理服务器工作。还支持以管道方式在同时发送多个请求，以便降低线路负载，提高传输速度。HTTP/1.1相较于HTTP/1.0协议的区别主要体现在：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;缓存处理&lt;/li&gt;
&lt;li&gt;带宽优化及网络连接的使用&lt;/li&gt;
&lt;li&gt;错误通知的管理&lt;/li&gt;
&lt;li&gt;消息在网络中的发送&lt;/li&gt;
&lt;li&gt;互联网地址的维护&lt;/li&gt;
&lt;li&gt;安全性及完整性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;HTTP/2&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当前版本，于2015年5月作为互联网标准正式发布。&lt;/p&gt;

&lt;p&gt;HTTP目前处于多个版本共存的情况，包括仍被广泛采用的HTTP１.0，主流是1.1（ 1.1 版的最大变化，就是引入 Keep-Alive， 简单说就是保持当前的TCP连接，避免了重新建立连接。 ）， HTTP/2 目前应用较少（主要是因为1.1基本能满足需求，还有升级成本问题）&lt;/p&gt;

&lt;h2 id=&#34;2-超文本传输协议http主要特点&#34;&gt;2. 超文本传输协议HTTP主要特点&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;支持B/S及C/S模式&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;简单快速&lt;/strong&gt; ：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;灵活：&lt;/strong&gt;HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无连接：&lt;/strong&gt;无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无状态：&lt;/strong&gt;HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;3-http请求结构&#34;&gt;3. HTTP请求结构&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/G4fT2BQZSq7U6jn.png&#34; alt=&#34;HTTP请求结构&#34; /&gt;HTTP请求结构&lt;/p&gt;

&lt;p&gt;HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;序号&lt;/th&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;请求指定的页面信息，并返回实体主体。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;HEAD&lt;/td&gt;
&lt;td&gt;类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;POST&lt;/td&gt;
&lt;td&gt;向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;PUT&lt;/td&gt;
&lt;td&gt;从客户端向服务器传送的数据取代指定的文档的内容。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;DELETE&lt;/td&gt;
&lt;td&gt;请求服务器删除指定的页面。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;CONNECT&lt;/td&gt;
&lt;td&gt;HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;OPTIONS&lt;/td&gt;
&lt;td&gt;允许客户端查看服务器的性能。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;TRACE&lt;/td&gt;
&lt;td&gt;回显服务器收到的请求，主要用于测试或诊断。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;PATCH&lt;/td&gt;
&lt;td&gt;是对 PUT 方法的补充，用来对已知资源进行局部更新 。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;请求头部用来设置HTTP请求的一些参数，如Host、User-Agen&lt;/p&gt;

&lt;p&gt;请求数据，表示要上传的数据，其和头部之间是是有空行的，且请求头部后面的空行是必须的（即使请求数据为空）。&lt;/p&gt;

&lt;h2 id=&#34;4-http响应结构&#34;&gt;4. HTTP响应结构&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/RoUCGZ16VKHb4hk.png&#34; alt=&#34;HTTP响应结构&#34; /&gt;HTTP响应结构&lt;/p&gt;

&lt;h3 id=&#34;状态码类别&#34;&gt;状态码类别&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;分类&lt;/th&gt;
&lt;th&gt;分类描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1**&lt;/td&gt;
&lt;td&gt;指示信息，表示服务器收到请求，需要请求者继续执行操作&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2**&lt;/td&gt;
&lt;td&gt;成功，操作被成功接收并处理&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3**&lt;/td&gt;
&lt;td&gt;重定向，需要进一步的操作以完成请求&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4**&lt;/td&gt;
&lt;td&gt;客户端错误，请求包含语法错误或无法完成请求&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5**&lt;/td&gt;
&lt;td&gt;服务器错误，服务器在处理请求的过程中发生了错误&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;常见状态码&#34;&gt;&lt;strong&gt;常见状态码&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;200 OK&lt;/code&gt; 客户端请求成功&lt;/li&gt;
&lt;li&gt;&lt;code&gt;301 Moved Permanently&lt;/code&gt; 请求永久重定向&lt;/li&gt;
&lt;li&gt;&lt;code&gt;302 Moved Temporarily&lt;/code&gt; 请求临时重定向&lt;/li&gt;
&lt;li&gt;&lt;code&gt;304 Not Modified&lt;/code&gt; 文件未修改，可以直接使用缓存的文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;400 Bad Request&lt;/code&gt; 由于客户端请求有语法错误，不能被服务器所理解。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;401 Unauthorized&lt;/code&gt; 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;403 Forbidden&lt;/code&gt; 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;404 Not Found&lt;/code&gt; 请求的资源不存在，例如，输入了错误的URL。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;500 Internal Server Error&lt;/code&gt; 服务器发生不可预期的错误，导致无法完成客户端的请求。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;503 Service Unavailable&lt;/code&gt; 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;详细的状态码，可以 &lt;a href=&#34;https://www.runoob.com/http/http-status-codes.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;在这里查看&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;5-http抓包分析&#34;&gt;5. HTTP抓包分析&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/azHYDUIAb4yJw6Q.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;双击第一条&lt;strong&gt;HTTP请求&lt;/strong&gt;，查看详细请求报文：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/JryvnTqcubGUMDS.png&#34; alt=&#34;HTTP请求&#34; /&gt;HTTP请求&lt;/p&gt;

&lt;p&gt;双击第二条&lt;strong&gt;HTTP响应&lt;/strong&gt;，查看详细响应报文：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/fjxp98r1Nign46K.png&#34; alt=&#34;HTTP响应&#34; /&gt;HTTP响应&lt;/p&gt;

&lt;h2 id=&#34;6-http请求-响应的步骤&#34;&gt;6. HTTP请求/响应的步骤&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;客户端连接到Web服务器，客户端（通常是浏览器）与Web服务器的端口（默认80）建立TCP套接字（ socket ）连接&lt;/li&gt;
&lt;li&gt;客户端发送HTTP请求&lt;/li&gt;
&lt;li&gt;服务器接受请求并返回HTTP响应&lt;/li&gt;
&lt;li&gt;释放连接TCP连接。若连接模式为close则服务器主动关闭TCP连接；若连接模式为Keep-Alive则该连接会保持一段时间，在该时间内可以继续接收请求。&lt;/li&gt;
&lt;li&gt;客户端浏览器解析HTML内容&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;7-一些问题&#34;&gt;7. 一些问题&lt;/h2&gt;

&lt;h3 id=&#34;7-1-在浏览器地址栏键入带有http请求的url-按下回车之后经历的流程&#34;&gt;7.1 在浏览器地址栏键入带有HTTP请求的URL，按下回车之后经历的流程？&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;DNS解析。浏览器会根据URL逐层（浏览器缓存 – 系统缓存 – 路由器缓存 – IPS服务器缓存 – 域名服务器缓存 – 顶级域名服务器缓存，找到即可返回不再需要查询后面的缓存）查询DNS缓存，解析URL中的域名对应的IP地址。&lt;/li&gt;
&lt;li&gt;TCP连接。根据IP地址和端口与服务器建立TCP连接（三次握手）。&lt;/li&gt;
&lt;li&gt;发送HTTP请求。建立连接后浏览器向服务器发出读取文件的HTTP请求。&lt;/li&gt;
&lt;li&gt;服务器处理请求并返回HTTP报文。&lt;/li&gt;
&lt;li&gt;浏览器解析渲染页面。&lt;/li&gt;
&lt;li&gt;连接结束。浏览器释放TCP连接。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;7-2-get请求和post请求的区别&#34;&gt;7.2 GET请求和POST请求的区别？&lt;/h3&gt;

&lt;p&gt;从三个层面来解答&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;1. Http报文层面：&lt;/strong&gt;GET将请求信息放在URL，POST放在报文体中（想获得请求详细必须请求报文，所以安全性较GET方式高一些，事实上要获得报文体中的请求信息也是很容易的‘Wireshark就可以查看’，因此安全性上两者并没有太多的区别，具体解决安全性的问题需要HTTPS）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/DQaeRE6JoPSrfYn.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;2. 数据库层面：&lt;/strong&gt;CET符合幂等性（多次操作获得结果一样）和安全性（不会改变数据库数据，GET做查询操作），POST都不符合。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;3. 其他层面：&lt;/strong&gt;GET可以被缓存、被存储，而POST不行。所以GET现在依然规范使用。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;7-3-cookie和session的区别&#34;&gt;7.3 Cookie和Session的区别？&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Cookie简介&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;是由服务器发给客户端的特殊信息，以文本的形式存放在客户端 客户端再次请求的时候，会把Cookie回发 服务器接收到后，会解析Cookie生成与客户端相对应的内容&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Cookie的设置以及发送过程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/2hP1culNRmJwZej.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;客户端发送一个http请求到服务器端&lt;/li&gt;
&lt;li&gt;服务器端发送一个http响应到客户端，其中包含Set-Cookie头部&lt;/li&gt;
&lt;li&gt;客户端发送一个http请求到服务器端，其中包含Cookie头部&lt;/li&gt;
&lt;li&gt;服务器端发送一个http响应到客户端&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Session简介&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;服务器端的机制，在服务器上保存的信息 解析客户端请求并操作session id，按需保存状态信息&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Session的实现方式&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用Cookie来实现&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/nGwOtgZTQxP8lCU.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用URL回写来实现。服务器在发送给浏览器的所有连接中都携带JSESSIONID的参数，这样客户端点击任何一个路径都会带回JSESSIONID。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;二者的区别：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Cookie数据存放在客户的浏览器上，Session数据放在服务器上&lt;/li&gt;
&lt;li&gt;Session相对于Cookie更安全&lt;/li&gt;
&lt;li&gt;若考虑减轻服务器负担，应当使用Cookie&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;7-4-http和https的区别&#34;&gt;7.4 HTTP和HTTPS的区别？&lt;/h2&gt;

&lt;h3 id=&#34;https简介&#34;&gt;HTTPS简介&lt;/h3&gt;

&lt;p&gt;超文本传输安全协议（英语：HyperText Transfer Protocol Secure，缩写：HTTPS；常称为HTTP over TLS、HTTP over SSL或HTTP Secure）是一种通过计算机网络进行安全通信的传输协议。是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。&lt;/p&gt;

&lt;h3 id=&#34;ssl&#34;&gt;SSL&lt;/h3&gt;

&lt;p&gt;SSL（Security Sockets Layer，安全套接层）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;为网络通信提供安全及数据完整性的一种安全协议&lt;/li&gt;
&lt;li&gt;是操作系统对外的API，SSL3.0后更名为TLS&lt;/li&gt;
&lt;li&gt;采用身份验证和数据加密保证网络通信的安全和数据的完整性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;加密的方式&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;对称加密：也叫私钥加密，指加密和解密使用相同密钥的加密算法。有时又叫传统密码算法，就是加密密钥能够从解密密钥中推算出来，同时解密密钥也可以从加密密钥中推算出来。而在大多数的对称算法中，加密密钥和解密密钥是相同的，所以也称这种加密算法为秘密密钥算法或单密钥算法。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;常见的对称加密有：DES（Data Encryption Standard）、AES（Advanced Encryption Standard）、RC4、IDEA。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;非对称加密：与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）；并且加密密钥和解密密钥是成对出现的。非对称加密算法在加密和解密过程使用了不同的密钥，非对称加密也称为公钥加密，在密钥对中，其中一个密钥是对外公开的，所有人都可以获取到，称为公钥，其中一个密钥是不公开的称为私钥。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;非对称加密算法对加密内容的长度有限制，不能超过公钥长度。比如现在常用的公钥长度是 2048 位，意味着待加密内容不能超过 256 个字节。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;摘要算法：采用单项Hash函数将需要加密的明文“摘要”成一串固定长度的密文，这一串密文又称为数字指纹，它有固定的长度，而且不同的明文摘要成密文，其结果总是不同的，而同样的明文其摘要必定一致。“数字摘要“是https能确保数据完整性和防篡改的根本原因，算法不可逆。&lt;/li&gt;
&lt;li&gt;数字签名：数字签名技术就是对“非对称密钥加解密”和“数字摘要“两项技术的应用，它将摘要信息用发送者的私钥加密，与原文一起传送给接收者。接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与解密的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;数字签名的&lt;strong&gt;过程&lt;/strong&gt;如下：&lt;/p&gt;

&lt;p&gt;明文 –&amp;gt; hash运算 –&amp;gt; 摘要 –&amp;gt; 私钥加密 –&amp;gt; 数字签名&lt;/p&gt;

&lt;p&gt;数字签名有两种&lt;strong&gt;作用&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;一、能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。&lt;/p&gt;

&lt;p&gt;二、数字签名能确定消息的完整性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;https数据传输流程&#34;&gt;HTTPS数据传输流程&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;浏览器将支持的加密算法信息发送给服务器&lt;/li&gt;
&lt;li&gt;服务器选择一套浏览器支持的加密算法，以证书的形式回发浏览器&lt;/li&gt;
&lt;li&gt;浏览器验证证书合法性，并结合证书公钥加密信息发送给服务器&lt;/li&gt;
&lt;li&gt;服务器使用私钥解密信息，验证哈希，加密响应消息回发浏览器&lt;/li&gt;
&lt;li&gt;浏览器解密响应消息，并对消息进行验真，之后进行加密交互数据&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;http和https的区别&#34;&gt;HTTP和HTTPS的区别?&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;HTTPS需要到CA申请证书，HTTP不需要&lt;/li&gt;
&lt;li&gt;HTTPS密文传输，HTTP明文传输&lt;/li&gt;
&lt;li&gt;连接方式不同，HTTPS默认使用443端口，HTTP使用80端口&lt;/li&gt;
&lt;li&gt;HTTPS=HTTP+加密+认证+完整性保护，较HTTP安全&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;https真的很安全吗&#34;&gt;HTTPS真的很安全吗?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;那倒未必&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;浏览器默认填充http://，请求需要进行跳转，有被劫持的风险.&lt;/li&gt;
&lt;li&gt;可以使用HSTS（HTTP Strict Transport Security）优化.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TCP滑动窗口</title>
      <link>https://halklein.github.io/2019/09/</link>
      <pubDate>Sat, 02 Nov 2019 19:45:16 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/09/</guid>
      <description>

&lt;h2 id=&#34;1-rtt-和-rto&#34;&gt;1. RTT 和 RTO&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;RTT（round trip time） 往返时延 ：发送一个数据包到收到对应的ACK，所花费的时间。&lt;/li&gt;
&lt;li&gt;RTO（retransamission timeout） ：重传时间间隔，由RTT计算得出，不是写死的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由TCP的重传机制，我们知道Timeout的设置对重置非常重要，设置长了会影响重发效率，设置短了可能导致还没丢失就又重传了。 而网络状况更是复杂，所以我们没有办法设置一个死的Timeout值 。为了动态地设置，TCP引入了RTT， 这样发送端就大约知道需要多少的时间，从而可以方便地设置Timeout——RTO（ Retransmission TimeOut ） ， 以让重传机制更高效。 &lt;a href=&#34;http://tools.ietf.org/html/rfc793&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;RFC793&lt;/a&gt; 中有对算法详细的定义。&lt;/p&gt;

&lt;h2 id=&#34;2-tcp的滑动窗口&#34;&gt;2. TCP的滑动窗口&lt;/h2&gt;

&lt;p&gt;我们都知道，TCP必需要解决的可靠传输以及包乱序（reordering）的问题，所以，TCP必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。 所以，TCP引入了一些技术和设计来做网络流控，Sliding Window是其中一个技术。TCP头里有一个字段叫Window，又叫Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。&lt;/p&gt;

&lt;h3 id=&#34;下面-模拟tcp缓冲区&#34;&gt;&lt;strong&gt;下面，模拟TCP缓冲区：&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/JUC5zmwxbLkyvFq.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;发送端的LastByteAcked指向了被接收端Ack过的位置（表示成功发送确认），LastByteSent表示发出去了，但还没有收到成功确认的Ack，LastByteWritten指向的是上层应用正在写的地方。&lt;/li&gt;
&lt;li&gt;接收端LastByteRead指向了TCP缓冲区中读到的位置，NextByteExpected指向的地方是收到的连续包的最后一个位置，LastByteRcved指向的是收到的包的最后一个位置，我们可以看到中间有些数据还没有到达，所以有数据空白区。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;窗口数据计算过程&#34;&gt;&lt;strong&gt;窗口数据计算过程：&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;接收端在给发送端回ACK中，会汇报自己的 &lt;strong&gt;AdvertisedWindow&lt;/strong&gt; = MaxRcvBuffer – （LastByteRcvd – Last Byte Read），（LastByteRcvd – LastByteRead）表示接收到的数据已占用缓存的大小;&lt;/li&gt;
&lt;li&gt;发送方根据Advertised Window的值，要保证已发送未确认的数据&amp;lt;= Advertised Window的大小，待发送数据大小**EffectiveWindow **= AdvertisedWindow – (LastByteSent – LastByteAcked)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;滑动窗口的基本原理&#34;&gt;滑动窗口的基本原理&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;TCP会话的发送方，滑动窗口示意图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/cnU7JxGLl1hySEe.png&#34; alt=&#34;发送方滑动窗口示意图&#34; /&gt;发送方滑动窗口示意图&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TCP会话的接收方，滑动窗口示意图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/rFw3h7ES8Ze2VAb.png&#34; alt=&#34;接收方滑动窗口示意图&#34; /&gt;接收方滑动窗口示意图&lt;/p&gt;

&lt;p&gt;需要指出的是，滑动窗口的大小可以依据一定的策略动态调整。应用会根据自身处理能力的变化，通过对本端TCP接收窗口大小的控制来实现对端的发送窗口进行流量限制。&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TCP和UDP的区别</title>
      <link>https://halklein.github.io/2019/08/</link>
      <pubDate>Fri, 01 Nov 2019 14:26:16 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/08/</guid>
      <description>

&lt;h2 id=&#34;1-udp协议&#34;&gt;1. UDP协议&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;用户数据报协议&lt;/strong&gt;（英语：&lt;strong&gt;U&lt;/strong&gt;ser &lt;strong&gt;D&lt;/strong&gt;atagram &lt;strong&gt;P&lt;/strong&gt;rotocol，缩写：&lt;strong&gt;UDP&lt;/strong&gt;；又称&lt;strong&gt;用户数据包协议&lt;/strong&gt;）是一个简单的面向数据报的通信协议，位于OSI模型的传输层。该协议由 &lt;a href=&#34;https://zh.wikipedia.org/w/index.php?title=David_P._Reed&amp;amp;action=edit&amp;amp;redlink=1&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;David P. Reed&lt;/a&gt; 在1980年设计且在&lt;a href=&#34;https://tools.ietf.org/html/rfc768&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;RFC 768&lt;/a&gt;中被规范。典型网络上的众多使用UDP协议的关键应用在一定程度上是相似的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/tk53hsSwfUxFKAE.png&#34; alt=&#34;UDP头部结构&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;UDP头部包含了以下几个数据：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;两个16位的端口号，分别为源端口（可选）和目标端口&lt;/li&gt;
&lt;li&gt;数据报的长度&lt;/li&gt;
&lt;li&gt;数据报的检验和（IPv4 可选字段），该字段用于发现头部信息和数据中的错误&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;UDP相比于TCP明显要简单很多，因此UDP头部开销小，只有8个字节，在传输数据报文时是很高效的。当然也就不支持错误重传，滑动窗口等精细的控制。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;UDP的特点：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;面向非连接，传输数据之前不需要先建立连接。&lt;/li&gt;
&lt;li&gt;不维护连接状态，支持同时向多个客户端传输相同的消息， 支持一对一、一对多、多对多、多对一的传输方式，也就是说 UDP 提供了单播，多播，广播的功能。&lt;/li&gt;
&lt;li&gt;数据包报头只有8个字节，额外开销较小&lt;/li&gt;
&lt;li&gt;吞吐量只受限于数据生成速率、传输速率以及机器性能&lt;/li&gt;
&lt;li&gt;不可靠：尽最大努力交付，不保证可靠交付，不需要维持复杂的链接状态表&lt;/li&gt;
&lt;li&gt;面向报文，不对应用程序提交的报文信息进行拆分或者合并&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-tcp和udp的区别&#34;&gt;2. TCP和UDP的区别&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;TCP&lt;/th&gt;
&lt;th&gt;UDP&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;是否连接&lt;/td&gt;
&lt;td&gt;面向连接&lt;/td&gt;
&lt;td&gt;无连接&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;可靠性&lt;/td&gt;
&lt;td&gt;可靠传输，使用流量控制和拥塞控制&lt;/td&gt;
&lt;td&gt;不可靠传输，不使用流量控制和拥塞控制&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;有序性&lt;/td&gt;
&lt;td&gt;有序&lt;/td&gt;
&lt;td&gt;无序&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;速率&lt;/td&gt;
&lt;td&gt;慢&lt;/td&gt;
&lt;td&gt;快&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;量级&lt;/td&gt;
&lt;td&gt;重量级&lt;/td&gt;
&lt;td&gt;轻量级&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;连接对象个数&lt;/td&gt;
&lt;td&gt;只支持一对一通信&lt;/td&gt;
&lt;td&gt;支持一对一，一对多，多对一、多对多通信&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;传输方式&lt;/td&gt;
&lt;td&gt;面向字节流&lt;/td&gt;
&lt;td&gt;面向报文&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;首部开销&lt;/td&gt;
&lt;td&gt;首部最小20字节，最大60字节&lt;/td&gt;
&lt;td&gt;首部开销小，仅8字节&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;适用场景&lt;/td&gt;
&lt;td&gt;要求可靠传输的应用，例如文件传输&lt;/td&gt;
&lt;td&gt;实时应用（IP电话、视频会议、直播等）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TCP四次挥手</title>
      <link>https://halklein.github.io/2019/07/</link>
      <pubDate>Thu, 31 Oct 2019 13:56:16 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/07/</guid>
      <description>

&lt;h2 id=&#34;1-四次挥手-关闭连接&#34;&gt;1. 四次挥手，关闭连接&lt;/h2&gt;

&lt;p&gt;由于TCP连接是全双工的，即连接双方可以在一条TCP连接上互相传输数据，每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个&lt;code&gt;FIN&lt;/code&gt;来终止这个方向的连接。收到一个&lt;code&gt;FIN&lt;/code&gt;只意味着这一方向上没有数据流动，一个 TCP 连接在收到一个&lt;code&gt;FIN&lt;/code&gt;后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭，因此在断开时存在一个半关闭状态，即有有一方失去发送数据的能力，却还能接收数据。所以，断开连接需要分为四次 ，称为&lt;strong&gt;四次挥手&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行&lt;code&gt;close()&lt;/code&gt;操作即可产生挥手操作。&lt;/p&gt;

&lt;p&gt;以下，我们假设由客户端主动触发close()。&lt;/p&gt;

&lt;h2 id=&#34;2-四次挥手流程图&#34;&gt;2. 四次挥手流程图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/5pbistqQF7XTxBV.png&#34; alt=&#34;四次挥手流程图&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;第一次挥手(FIN=1，seq=u)&lt;/strong&gt;
假设假客户端主动触发close()，客户端发送一个FIN标志位为 1 的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。因为有可能服务器还要发送数据，所以发送自己的序列号seq=u，等待服务器确认。发送完毕后，客户端进入FIN_WAIT_1状态。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;第二次挥手(ACK=1，seq=v，ack=u+1)&lt;/strong&gt;
服务器端确认客户端的FIN包，发送一个确认包【ACK=1(确认)、seq=v(自己的序列号)、ack=u+1(确认收到序列号)】，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接(可能有数据发送)。
发送完毕后，服务器端进入CLOSE_WAIT状态，客户端接收到这个确认包之后，进入FIN_WAIT_2状态，等待服务器端关闭连接。
在这过程中 TCP 服务器进程会通知高层应用进程。然后从客户端到服务器这个方向的连接就释放了，TCP 连接处于半关闭状态。但是服务器若发送数据，客户端仍要接收。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;第三次挥手(FIN=1，ACK=1，seq=w，ack=u+1)&lt;/strong&gt;
若服务器已经没有要向客户端发送的数据，其应用进程就通知 TCP 释放连接。
服务器端准备好关闭连接时，向客户端发送结束连接请求FIN置为 1，ACK=1，seq=w(有数据发送过)，ack=u+1。
发送完毕后，服务器端进入LAST_ACK状态，等待来自客户端的最后一个ACK。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;第四次挥手(ACK=1，seq=u+1，ack=w+1)&lt;/strong&gt;
客户端接收到来自服务器端的关闭请求，发送一个确认包(在确认报文段中ACK=1，确认号ack=w+1，自己的序号seq=u+1)，并进入TIME_WAIT状态，等待可能出现的要求重传的ACK包。(这个确认包是内核进行发送的，上面不能发数据的是客户端的send函数)
服务器端接收到这个确认包之后，关闭连接，进入CLOSED状态。
客户端等待了某个固定时间（两个最大段生命周期，&lt;code&gt;2MSL&lt;/code&gt;（2 Maximum Segment Lifetime），即2个最长报文段寿命， &lt;code&gt;RFC 793&lt;/code&gt;中规定MSL为2分钟，而Linux中设置为30秒 ）之后，没有收到服务器端的ACK，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入CLOSED状态。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-四次挥手抓包分析&#34;&gt;3. 四次挥手抓包分析&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/4ZnKhodQpuNfmiE.png&#34; alt=&#34;四次挥手抓包分析&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;4-问题&#34;&gt;4. 问题&lt;/h2&gt;

&lt;h3 id=&#34;为什么会有time-wait状态&#34;&gt;为什么会有TIME_WAIT状态？&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;网络可能不可靠，需要确保有足够的时间让对方收到ACK包。被动关闭方处于&lt;code&gt;LAST_ACK&lt;/code&gt;状态下的&lt;code&gt;SOCKET&lt;/code&gt;可能会因为超时未收到ACK报文，而重发FIN报文（这一来一去正好是2SML）。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;避免新旧连接混淆。有的路由器会缓存IP数据包，如果连接被重用了，那么这些延迟收到的包就有可能会跟新连接混在一起。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;time-wait状态会带来的影响&#34;&gt;TIME_WAIT状态会带来的影响 ?&lt;/h3&gt;

&lt;p&gt;当某个连接的一端处于TIME_WAIT状态时，该连接将不能再被使用。事实上，对于我们比较有现实意义的是，这个端口将不能再被使用。&lt;/p&gt;

&lt;p&gt;某个端口处于TIME_WAIT状态(其实应该是这个连接)时，这意味着这个 TCP 连接并没有断开(完全断开)，那么，如果你bind这个端口，就会失败。对于服务器而言，如果服务器突然坏掉了，那么它将无法再2MSL内重新启动，因为bind会失败。&lt;/p&gt;

&lt;p&gt;解决这个问题的一个方法就是设置 socket 的&lt;code&gt;SO_REUSEADDR&lt;/code&gt;选项。这个选项意味着你可以重用一个地址。&lt;/p&gt;

&lt;h3 id=&#34;服务器出现大量close-wait状态的原因&#34;&gt;服务器出现大量CLOSE_WAIT状态的原因？&lt;/h3&gt;

&lt;p&gt;对方关闭socket连接，我方忙于读或写，没有及时关闭连接。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;检查代码，特别是释放资源的代码&lt;/li&gt;
&lt;li&gt;检查配置，特别是处理请求的线程配置&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以使用以下命令查看服务器是否有大量CLOSE_WAIT&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;netstat -n | awk &#39;/^tcp/{++S[$NF]}END{for(a in S) print a,S[a]}&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/5XsPjp2oZCmOngW.jpg&#34; alt=&#34;MacOS下的测试&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;为什么需要四次握手才能断开连接&#34;&gt;为什么需要四次握手才能断开连接？&lt;/h3&gt;

&lt;p&gt;因为全双工，发送方和接收方都需要FIN报文和ACK报文，当被动方收到主动方的FIN报文通知时，它仅仅表示主动方没有数据再发送给被动方了。但未必被动方所有的数据都完整的发送给了主动方，所以被动方不会马上关闭SOCKET，它可能还需要发送一些数据给主动方后，再发送FIN报文给主动方，告诉主动方同意关闭连接，所以这里的ACK报文和FIN报文多数情况下都是分开发送的。&lt;/p&gt;

&lt;p&gt;由于网络服务的不可靠性，必须考虑到在释放连接时，可能由于数据包的失序而使释放连接请求的数据包会比其他数据包先到达目的端。此时，如果目的端由于收到了释放连接请求的数据包而立即释放该连接，则会造成那些先发而后至的数据包丢失。&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TCP三次握手</title>
      <link>https://halklein.github.io/2019/06/</link>
      <pubDate>Thu, 31 Oct 2019 09:14:18 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/06/</guid>
      <description>

&lt;h2 id=&#34;1-tcp-transmission-control-protocol-传输控制协议&#34;&gt;1. TCP(Transmission Control Protocol)　传输控制协议&lt;/h2&gt;

&lt;p&gt;TCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接。&lt;/p&gt;

&lt;p&gt;TCP工作在网络 OSI 的七层模型中的第四层（Transport层），IP在第三层（Network层），ARP在第二层（Data Link层）；在第二层上的数据，我们把它叫Frame，在第三层上的数据叫Packet，第四层的数据叫Segment。 数据从应用层发下来，会在每一层都会加上头部信息，进行封装，然后再发送到数据接收端。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一种&lt;strong&gt;面向连接的、可靠的、基于字节流的&lt;/strong&gt;传输层通信协议&lt;/li&gt;
&lt;li&gt;将应用层的数据流分割成报文段并发送给目标节点的TCP层&lt;/li&gt;
&lt;li&gt;数据包都有序号，对方收到则发送ACK确认，未收到则重传&lt;/li&gt;
&lt;li&gt;使用校验和来检验数据在传输过程中是否有误&lt;/li&gt;
&lt;li&gt;在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP&lt;/li&gt;
&lt;li&gt;TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复&lt;/li&gt;
&lt;li&gt;TCP 使用&lt;strong&gt;滑动窗口机制&lt;/strong&gt;来实现流量控制，通过动态改变窗口的大小进行拥塞控制&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在进行数据传输之前，需要在传输数据的两端（客户端和服务器端）创建一个连接，这个连接由一对插口地址唯一标识，即是在IP报文首部的源IP地址、目的IP地址，以及TCP数据报首部的源端口地址和目的端口地址&lt;/p&gt;

&lt;h2 id=&#34;2-tcp头部结构&#34;&gt;2. TCP头部结构&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/dLhNgTlbYtBA3FW.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Source port&lt;/code&gt;源端口、&lt;code&gt;Destination port&lt;/code&gt;目的端口，他们各占用2个字节。TCP和UDP的数据包都是不包含IP地址信息的，因为那是IP层要处理的，但是TCP和UDP都会有源端口和目的端口。在计算机本地我们可以用PID唯一标识一个进程，但是在网络中不同计算机的进程可能会有相同的PID，可以通过在传输层中使用协议端口号来解决，这样我们就可以用 IP+协议+端口号来唯一标识网络中的一个进程.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Sequence Number&lt;/code&gt;序号：Seq序号，占4个字节，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。是包的序号，用来解决网络包乱序（reordering）问题。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Acknowledgement Number&lt;/code&gt;确认序号：Ack序号，占4个字节，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Data offset&lt;/code&gt;数据偏移：由于头部有可选字段长度不固定，因此它指出TCP报文的数据离TCP报文起始有多远。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Reserved&lt;/code&gt;保留域：保留以后使用的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;TCP Flags&lt;/code&gt; 标志位：常见的有6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;URG&lt;/code&gt; 紧急指针标志：为1时有效，为0则忽略。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ACK&lt;/code&gt; &lt;strong&gt;确认序号标志&lt;/strong&gt;：为1时确认号有效，为0标识报文中不含确认信息。 TCP 规定在连接建立后传送的所有报文段都必须把 ACK 置为一。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;PSH&lt;/code&gt; push标志：为1时，指示接收方接收到报文后应该尽快将这个报文交给应用层程序，而不是在缓冲区排队。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;RST&lt;/code&gt; 重置连接标志：重置连接，重置由于主机崩溃或其它原因而出现的异常连接，或者用于拒绝非法的报文段和拒绝连接请求。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SYN&lt;/code&gt; &lt;strong&gt;同步序号&lt;/strong&gt;：用于建立连接过程。 当SYN=1，ACK=0时，表示当前报文段是一个连接请求报文。当SYN=1，ACK=1时，表示当前报文段是一个同意建立连接的应答报文。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;FIN&lt;/code&gt; &lt;strong&gt;finish标志&lt;/strong&gt;：用于释放连接。为1时， 该字段为一表示此报文段是一个释放连接的请求报文&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Window Size&lt;/code&gt;窗口大小，指滑动窗口的大小，用于告知发送端接受方的缓存大小，以此控制发送端发送数据的速率从而进行流量控制 。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Checksum&lt;/code&gt;校验和，指奇偶校验，对整个TCP报文以16位进行计算所得，由发送端计算和存储并由接收端验证。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Urgent Pointer&lt;/code&gt; 紧急指针，当TCP Flags中的&lt;code&gt;URG&lt;/code&gt;为1时才有效，指出本TCP报文中紧急数据的字节数。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;TCP Options&lt;/code&gt; 可选项，其长度可变，定义一些其它的可选参数。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;3-tcp三次握手&#34;&gt;3. TCP三次握手&lt;/h2&gt;

&lt;p&gt;“握手”是为了&lt;strong&gt;建立连接&lt;/strong&gt;，TCP三次握手的流程图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/tbrGiOqwZ6Jpe3K.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;其中，前两次握手是不允许携带数据的，第三握手可以携带数据，如果第三次握手不携带数据就可以不消耗序号。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第一次握手&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;建立连接时， Client将标志位SYN置为1，随机产生一个值seq=x ， 并将该数据包发送给Server ，Client进入SYN_SEND状态，等待Server 确认；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第二次握手&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Server 收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1  ， ack=x+1 ，同时随机产生一个值seq=y ， 并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第三次握手&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Client收到Server的SYN+ACK包， 检查ack是否为y+1，标志位ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，seq=x+1， 并将该数据包发送给Server ;  Server检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;不要将确认序号ack与标志位中的ACK搞混了。&lt;/li&gt;
&lt;li&gt;确认方ack=发起方seq+1，两端配对。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-三次握手抓包分析&#34;&gt;4. 三次握手抓包分析&lt;/h2&gt;

&lt;p&gt;筛选过滤，将我们访问的地址作为筛选的 目标地址 和 源地址，筛选出 源地址 是因为三次握手中，访问的地址也会作为源地址向我们的计算机发送请求。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;ip.dst==61.128.252.10 or ip.src==61.128.252.10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/pbmqrR3fvd2xls4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;顺便查阅归纳下，&lt;strong&gt;Wireshark的过滤规则&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 过滤IP&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;ip.src eq 192.168.1.108 or ip.dst eq 192.168.1.108
或者ip.addr eq 192.168.1.107
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2. 过滤端口&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;tcp.port eq 80 //不管端口是源端口的还是目标端口都显示
tcp.port eq 80 or udp.port eq 80
tcp.dstport == 80 //只显tcp协议的目标端口80
tcp.srcport == 80 //只显tcp协议的源端口80
tcp.port &amp;gt;= 1 and tcp.port &amp;lt;= 80 //端口范围过滤
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3. 过滤协议&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;直接输入协议名：tcp、udp、arp、icmp、http、smtp、ftp、dns、msnms、ip、ssl、oicq、bootp等
排除协议过滤：如 !arp 或者 not arp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;4. 过滤MAC&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;eth.dst == 48:7d:2e:98:61:d1 或 eth.dst==48-7d-2e-98-61-d1 //过滤目标mac
eth.src eq 48:7d:2e:98:61:d1 //过滤来源mac
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;小于 less than（lt）&lt;/p&gt;

&lt;p&gt;等于 eq&lt;/p&gt;

&lt;p&gt;大于等于 ge&lt;/p&gt;

&lt;p&gt;不等 ne&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5. 包长度过滤&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;udp.length == 26 //这个长度是指udp本身固定长度8加上udp下面那块数据包之和
tcp.len &amp;gt;= 7   //指的是ip数据包(tcp下面那块数据),不包括tcp本身
ip.len == 94 //除了以太网头固定长度14,其它都算是ip.len,即从ip本身到最后
frame.len == 119 //整个数据包长度,从eth开始到最后
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;6. http模式过滤&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;例子:
http.request.method == “GET”
http.request.method == “POST”
http.request.uri == “/img/logo.png”
http contains “GET”
http contains “HTTP/1.”
http.request.method == “GET” &amp;amp;&amp;amp; http contains “Host: “

http.host == xxx.com	// 过滤 host
http.response == 1	// 过滤所有的 http 响应包
http.response.code == 302	// 过滤状态码 202
http.request.method==POST 	// 过滤 POST 请求包
http.cookie contains xxx	// cookie 包含 xxx
http.request.uri==&amp;quot;/robots.txt&amp;quot;	//过滤请求的uri，取值是域名后的部分
http.request.full_uri==&amp;quot;http://1.com&amp;quot;	// 过滤含域名的整个url
http.server contains &amp;quot;nginx&amp;quot;	//过滤http头中server字段含有nginx字符的数据包
http.content_type == &amp;quot;text/html&amp;quot;	//过滤content_type是text/html
http.content_encoding == &amp;quot;gzip&amp;quot;	//过滤content_encoding是gzip的http包
http.transfer_encoding == &amp;quot;chunked&amp;quot;	//根据transfer_encoding过滤
http.content_length == 279
http.content_length_header == &amp;quot;279&amp;quot;	//根据content_length的数值过滤
http.request.version == &amp;quot;HTTP/1.1&amp;quot;	//过滤HTTP/1.1版本的http包，包括请求和响应
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;5-问题&#34;&gt;5. 问题&lt;/h2&gt;

&lt;h3 id=&#34;为什么需要三次握手才能建立起连接&#34;&gt;为什么需要三次握手才能建立起连接&lt;/h3&gt;

&lt;p&gt;为了初始化Sequence Number的初始值，通信双方要互相通知对方自己的Sequence Number，作为以后数据通信的序号，以保证接收到的数据不会因为网络上的问题而乱序，即TCP会用这个序号来拼接数据， 确保数据能够完整传输。&lt;/p&gt;

&lt;h3 id=&#34;首次握手的隐患-syn超时&#34;&gt;首次握手的隐患&amp;ndash;SYN超时&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;原因&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;三次握手过程中，Server收到Client的SYN，回复SYN-ACK后（ Server收到Client的ACK之前的TCP连接称为半连接（&lt;code&gt;half-open connect&lt;/code&gt;），此时Server处于SYN_RCVD状态 ）， Cient就掉线了，Server端没有收到Client的ACK确认。 于是 Server会不断重试直到超时，在Linux系统中会默认进行5次重试（每次重试隔时间从1s开始每次都翻售 ，即1+2+4+6+8+16+32=63秒）TCP才断开连接。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SYN攻击&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，把Server的syn连接的队列耗尽 ，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;检测&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以可以查看&lt;code&gt;SYN_RECV&lt;/code&gt;状态：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;# netstat -nap | grep SYN_RECV
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;针对SYN Flood的防护措施&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Linux下给了一个叫&lt;code&gt;tcp_syncookies&lt;/code&gt;的参数来应对这个事——当SYN队列满了后，TCP会通过源地址端口、目标地址端口和时间戳打造出一个特别的&lt;code&gt;Sequence Number&lt;/code&gt;发回去（又叫SYN Cookie），如果是攻击者则不会有响应，如果是正常连接，则会把这个 &lt;code&gt;SYN Cookie&lt;/code&gt;发回来，然后服务端可以通过cookie建连接（即使你不在SYN队列中）。请注意，慎用&lt;code&gt;tcp_syncookies&lt;/code&gt;来处理正常的大负载的连接的情况。因为，&lt;code&gt;synccookies&lt;/code&gt;是妥协版的TCP协议，并不严谨。 对于正常的请求，可以调整以下三个参数：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;tcp_synack_retries&lt;/code&gt; ，用于减少重试次数；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tcp_max_syn_backlog&lt;/code&gt;，用于增大SYN连接数；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tcp_abort_on_overflow&lt;/code&gt; ，处理不过来，直接拒绝连接了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;保活机制&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果建立连接后，Client出现故障，向对方发送保活探测报文，如果未收到响应则继续发送，尝试次数达到保活探测数仍未收到响应则中断连接&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>OSI模型和TCP/IP模型</title>
      <link>https://halklein.github.io/2019/05/</link>
      <pubDate>Thu, 31 Oct 2019 09:06:36 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/05/</guid>
      <description>

&lt;h2 id=&#34;1-osi-开放式系统互联参考模型&#34;&gt;1. OSI 开放式系统互联参考模型&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;开放式系统互联模型&lt;/strong&gt;（英语：&lt;strong&gt;O&lt;/strong&gt;pen &lt;strong&gt;S&lt;/strong&gt;ystem &lt;strong&gt;I&lt;/strong&gt;nterconnection Model，缩写：OSI；简称为&lt;strong&gt;OSI模型&lt;/strong&gt;）是一种&lt;a href=&#34;https://zh.wikipedia.org/wiki/概念模型&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;概念模型&lt;/a&gt;，由&lt;a href=&#34;https://zh.wikipedia.org/wiki/国际标准化组织&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;国际标准化组织&lt;/a&gt;提出，一个试图使各种计算机在世界范围内互连为网络的标准框架。定义于ISO/IEC 7498-1。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/TLr5NUxWHKmJszP.gif&#34; alt=&#34;OSI 开放式系统互联参考模型&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;物理层-physical-layer&#34;&gt;物理层（Physical Layer）&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/N2o1gwMl95GfFsD.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在局部局域网上传送&lt;a href=&#34;https://zh.wikipedia.org/wiki/数据帧&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;数据帧&lt;/a&gt;（data frame），它负责管理电脑通信设备和网络媒体之间的互通， 定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率 ，主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换），这一层的数据叫做比特，单位是bit比特。包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机接口卡、 调制解调器等。典型的协议有 RS 232C、RS 449/422/423、V.24 和 X.21、X.21bis&lt;/p&gt;

&lt;h3 id=&#34;数据链路层-datalink-layer&#34;&gt;数据链路层&lt;strong&gt;（Datalink Layer）&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/oSpjkPZy9ftYGVa.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;定义了如何让格式化数据以进行传输，以及如何让控制对物理介质的访问，这一层通常还提供错误检测和纠正，以确保数据的可靠传输。交换机(二层)、网桥设备在这一层。数据链路层协议的代表包括： &lt;code&gt;HDLC&lt;/code&gt; 、&lt;code&gt;PPP&lt;/code&gt;、&lt;code&gt;STP&lt;/code&gt;等。&lt;/p&gt;

&lt;h3 id=&#34;网络层-network-layer&#34;&gt;网络层 &lt;strong&gt;（Network Layer）&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/wexCdOuZ2QH54B3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择，Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。网络层负责在源机器和目标机器之间建立它们所使用的路由。路由器在该层。协议有：&lt;code&gt;IP&lt;/code&gt;、&lt;code&gt;ICMP&lt;/code&gt;（互联网控制报文协议）、&lt;code&gt;ARP&lt;/code&gt;（地址转换协议）、&lt;code&gt;RARP&lt;/code&gt;（反向地址转换协议）&lt;/p&gt;

&lt;h3 id=&#34;传输层-transport-layer&#34;&gt;&lt;strong&gt;传输层（Transport Layer）&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/YQgGIThdiAEn23f.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;OSI 模型中最重要的一层。定义了一些传输数据的协议和端口号（WWW端口80等），如：&lt;code&gt;TCP&lt;/code&gt;（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），&lt;code&gt;UDP&lt;/code&gt;（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）， 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组，常常把这一层数据叫做段。&lt;/p&gt;

&lt;h3 id=&#34;会话层-session-layer&#34;&gt;&lt;strong&gt;会话层（Session Layer）&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/4hayBOXImwVbAct.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;负责在网络中的两节点之间建立、维持和终止通信。 会话层的功能包括：建立通信链接，保持会话过程通信链接的畅通，同步两个节点之间的对话，决定通信是否被中断以及通信中断时决定从何处重新发送。&lt;/p&gt;

&lt;p&gt;通过传输层（端口号：传输端口与接收端口）建立数据传输的通路，主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。&lt;/p&gt;

&lt;p&gt;常见的协议有 &lt;code&gt;ADSP&lt;/code&gt;、&lt;code&gt;RPC&lt;/code&gt; 等。&lt;/p&gt;

&lt;h3 id=&#34;表示层-presentation-layer&#34;&gt;&lt;strong&gt;表示层（Presentation Layer）&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/PRd9vurV1UCfqTw.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;应用程序和网络之间的翻译官，在表示层，数据将按照网络能理解的方案进行格式化；这种格式化也因所使用网络的类型不同而不同。表示层管理数据的解密与加密，如系统口令的处理。可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。 常见的协议有&lt;code&gt;ASCII&lt;/code&gt;、&lt;code&gt;SSL/TLS&lt;/code&gt; 等。&lt;/p&gt;

&lt;h3 id=&#34;应用层-application-layer&#34;&gt;&lt;strong&gt;应用层（Application Layer）&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/qTcn6Y3klSOetdN.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;是最靠近用户的OSI层，这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务 。常见的协议有 &lt;code&gt;HTTP&lt;/code&gt;，&lt;code&gt;FTP&lt;/code&gt;，&lt;code&gt;TELNET&lt;/code&gt;、&lt;code&gt;SMTP&lt;/code&gt; 等。&lt;/p&gt;

&lt;h3 id=&#34;osi模型-数据传输流程概览&#34;&gt;OSI模型 数据传输流程概览&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/peH8BVr75dWE34c.png&#34; alt=&#34;&#34; style=&#34;zoom:67%;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-tcp-ip四层网络模型&#34;&gt;2. TCP/IP四层网络模型&lt;/h2&gt;

&lt;h3 id=&#34;提出&#34;&gt;提出&lt;/h3&gt;

&lt;p&gt;OSI模型是一个定义良好的协议规范集，定义了开放系统的层次结构和之间的关系，但并没有提供一个可实现的方法，其并非一个标准，而是一个慨念型框架。TCP/IP是被广泛使用的OSI模型的实现。&lt;/p&gt;

&lt;h3 id=&#34;简介&#34;&gt;简介&lt;/h3&gt;

&lt;p&gt;TCP/IP协议栈是美国国防部高级研究计划局计算机网（Advanced Research Projects Agency Network，ARPANET）和其后继因特网使用的参考模型。ARPANET是由美国国防部（U.S．Department of Defense，DoD）赞助的研究网络。最初，它只连接了美国境内的四所大学。随后的几年中，它通过租用的电话线连接了数百所大学和政府部门。最终ARPANET发展成为全球规模最大的互连网络-因特网。最初的ARPANET于1990年永久性地关闭。&lt;/p&gt;

&lt;p&gt;TCP/IP是一组协议的代名词，它&lt;strong&gt;还包括许多协议，组成了TCP/IP协议簇&lt;/strong&gt;。TCP/IP协议簇分为四层，IP位于协议簇的第二层(对应OSI的第三层)，TCP位于协议簇的第三层(对应OSI的第四层)。&lt;/p&gt;

&lt;h3 id=&#34;层次&#34;&gt;层次&lt;/h3&gt;

&lt;p&gt;TCP/IP协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的网络来完成自己的需求。分别为：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;应用层&lt;/strong&gt;：应用程序间沟通的层，如简单电子邮件传输（SMTP）、文件传输协议（FTP）、网络远程访问协议（Telnet）等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;传输层&lt;/strong&gt;：在此层中，它提供了节点间的数据传送服务，如传输控制协议（TCP）、用户数据报协议（UDP）等，TCP和UDP给数据包加入传输数据并把它传输到下一层中，这一层负责传送数据，并且确定数据已被送达并接收。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;网络层&lt;/strong&gt;：负责提供基本的数据封包传送功能，让每一块数据包都能够到达目的主机（但不检查是否被正确接收），如网际协议（IP）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;网络接口层&lt;/strong&gt;：对实际的网络媒体的管理，定义如何使用实际网络（如Ethernet、Serial Line等）来传送数据。&lt;/p&gt;

&lt;h3 id=&#34;对应关系及协议整理&#34;&gt;对应关系及协议整理&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/Ip71j6NFub3Ugr5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;tcp-ip模型-数据传输流程概览&#34;&gt;TCP/IP模型 数据传输流程概览&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/NWbI9otOVEwkJaL.png&#34; alt=&#34;&#34; style=&#34;zoom:50%;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;3-问题&#34;&gt;3. 问题&lt;/h2&gt;

&lt;h3 id=&#34;交换机工作在osi的哪一层&#34;&gt;交换机工作在OSI的哪一层？&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;二层交换机&lt;/strong&gt; 工作在OSI的第二层数据链路层，，由于它们要对帧解码并使用帧信息将数据发送到正确的接收方，所以它们是工作在数据链路层的。
&lt;strong&gt;三层交换机&lt;/strong&gt; 是工作在OSI的网络层，因为三层交换机有路由功能。&lt;/p&gt;

&lt;h3 id=&#34;路由器工作在osi的哪一层&#34;&gt;路由器工作在OSI的哪一层？&lt;/h3&gt;

&lt;p&gt;路由器工作在OSI七层模型的第3层，网络层。由于网络层处理，并智能指导数据传送，路由器连接网络各段，所以路由器属于网络层。在网络中，“路由”是基于编址方案、使用模式以及可达性来指引数据的发送。 网络层负责在源机器和目标机器之间建立它们所使用的路由。&lt;/p&gt;

&lt;h3 id=&#34;ping命令使用osi哪一层协议&#34;&gt;PING命令使用OSI哪一层协议？&lt;/h3&gt;

&lt;p&gt;ping命令使用的是ICMP协议，位于OSI七层网络模型中的第三层，网络层。&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>插入排序</title>
      <link>https://halklein.github.io/2019/04/</link>
      <pubDate>Tue, 29 Oct 2019 22:56:37 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/04/</guid>
      <description>

&lt;h2 id=&#34;1-直接插入排序&#34;&gt;1. 直接插入排序&lt;/h2&gt;

&lt;h3 id=&#34;思想&#34;&gt;思想&lt;/h3&gt;

&lt;p&gt;通俗的来说，直接插入排序 类似于给扑克牌排序的方法。我们假设先看到了左边第1张牌；然后看第2张牌并与之前的第1张牌比较，如果要小我们就抽出插入到第1张前面，否则我们就不动；继续看第3张牌，和之前的两张进行比较并放到合适的位置；依次类推即可。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/H6oOmeQatGKr9Tw.png&#34; alt=&#34;过程演示&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;c语言代码实现&#34;&gt;C语言代码实现：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
/* 直接插入排序 */
void InsertSort( int A[], int n )
{
	int i, j;
	for ( i = 2; i &amp;lt;= n; i++ )
	{
		if ( A[i] &amp;lt; A[i - 1] )
		{
			A[0] = A[i]; /* 第一个位置 A[0] 作为哨兵 */
			for ( j = i - 1; A[0] &amp;lt; A[j]; j-- )
				A[j + 1] = A[j];
			A[j + 1] = A[0];
		}
	}
}

int main()
{
	int e, n, i;
	printf( &amp;quot;序列元素个数：&amp;quot; );
	scanf( &amp;quot;%d&amp;quot;, &amp;amp;n );
	int A[n + 1];
	printf( &amp;quot;请依次输入：\n&amp;quot; );
	for ( i = 1; i &amp;lt;= n; i++ )
	{
		scanf( &amp;quot;%d&amp;quot;, &amp;amp;e );
		A[i] = e;
	}
	InsertSort( A, n );
	printf( &amp;quot;直接插入排序结果：&amp;quot; );
	for ( i = 1; i &amp;lt;= n; i++ )
		printf( &amp;quot;%4d&amp;quot;, A[i] );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;测试效果&#34;&gt;测试效果：&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/X8sVS957BqgcwLf.png&#34; alt=&#34;测试效果&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·No End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>迁移小记</title>
      <link>https://halklein.github.io/2019/02/</link>
      <pubDate>Tue, 15 Oct 2019 12:46:35 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/02/</guid>
      <description>

&lt;h2 id=&#34;1-提高-git-clone-的速度&#34;&gt;1. 提高 git clone 的速度&lt;/h2&gt;

&lt;p&gt;之前建博客的时候 git clone 感觉挺快的，现在找了几个项目练习有几十M大，发现git clone的速度就50k/s左右实在是受不了！自己是有小飞机的，开了全局代理，居然还是很慢&lt;/p&gt;

&lt;p&gt;最后找到原因：git 的代理要单独配置，命令如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;git config --global http.https://github.com.proxy socks5://127.0.0.1:1086
git config --global https.https://github.com.proxy socks5://127.0.0.1:1086
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-macos-启用未知来源&#34;&gt;2. MacOS 启用未知来源&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;sudo spctl --master-disable
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-常用git命令&#34;&gt;3. 常用Git命令&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;//初始化git仓库
git init
//连接到Github
git remote add origin https://github.com/[Github 用户名]/[Github 用户名].github.io.git
//提交所有的更改
git add -A
//提交并添加说明
git commit -m &amp;quot;提交说明&amp;quot;
//推到master主分支
git push -u origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;//拉去整个项目
git clone [url]
//拉取远程仓库里面master分支到本地
git pull origin master
//查看有哪些文件夹
dir
//查看当前git配置
git config --list
//编辑git配置文件
git config --user.name
//设置git用户信息
git config [--global] user.name &amp;quot;[name]&amp;quot;
git config [--global] user.email &amp;quot;[email address]&amp;quot;
//查看仓库当前的状态
$ git status
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;4-一些hugo命令&#34;&gt;4. 一些Hugo命令&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;//创建网站
hugo new site myBlog
//创建页面
hugo new about.md
//本地运行测试
hugo server -D
//生成
hugo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;center&gt; ·No End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>博客迁移 Hugo</title>
      <link>https://halklein.github.io/2019/01/</link>
      <pubDate>Thu, 10 Oct 2019 14:56:35 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/01/</guid>
      <description>&lt;p&gt;​       &lt;strong&gt;你眼中有春与秋，&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​       &lt;strong&gt;胜过我见过爱过的一切山川与河流；&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​       &lt;strong&gt;有一天我会懂你，&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​       &lt;strong&gt;也懂这世界悲欢，&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​       &lt;strong&gt;陪你走千帆，仍方寸不乱。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>算法比赛模板（一）</title>
      <link>https://halklein.github.io/2019/12/</link>
      <pubDate>Sat, 23 Mar 2019 21:47:12 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/12/</guid>
      <description>

&lt;h2 id=&#34;工具类&#34;&gt;工具类&lt;/h2&gt;

&lt;h3 id=&#34;线性筛素数&#34;&gt;线性筛素数&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;
#define SIZE 1000
int main()
{
	int	check[SIZE]	= { 0 };
	int	prime[SIZE]	= { 0 };
	int	pos		= 0;
	for ( int i = 2; i &amp;lt; SIZE; i++ )
	{
		/* 是素数 */
		if ( !check[i] )
			prime[pos++] = i;
		for ( int j = 0; j &amp;lt; pos &amp;amp;&amp;amp; i * prime[j] &amp;lt; SIZE; j++ )
		{
			/* 筛掉 */
			check[i * prime[j]] = 1;
			if ( i % prime[j] == 0 )
				break;
		}
	}
	for ( int i = 0; prime[i] != 0; i++ )
		printf( &amp;quot;%d &amp;quot;, prime[i] );
	return(0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;以文本作为c-的数据输入&#34;&gt;以文本作为C++的数据输入&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;freopen( &amp;quot;DATA.in&amp;quot;, &amp;quot;r&amp;quot;, stdin );
freopen( &amp;quot;DATA.out&amp;quot;, &amp;quot;w&amp;quot;, stdout );
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;星期计算公式&#34;&gt;星期计算公式&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;


/*
 * 基姆拉尔森：w=(d+2*m+3*(m+1)/5+y+y/4-y/100+y/400)%7
 * w：0:星期一...依此类推
 */
int cal1( int y, int m, int d )
{
	if ( m == 1 || m == 2 )
		m += 12, y--;
	int w = (d + 2 * m + 3 * (m + 1) / 5 + y + y / 4 - y / 100 + y / 400) % 7;
	/* 结果加 1，返回 星期一：1 ——到星期日：7 */
	return(++w);
}


int main()
{
	int y, m, d;
	scanf( &amp;quot;%d %d %d&amp;quot;, &amp;amp;y, &amp;amp;m, &amp;amp;d );
	int x = cal1( y, m, d );
	printf( &amp;quot;%dn&amp;quot;, x );
	return(0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;大数阶乘-java&#34;&gt;大数阶乘（Java）&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;import java.io.*;
import java.util.*;
import java.math.BigInteger;
public class Main {
	public static void main( String[] args )
	{
		Scanner		cin	= new Scanner( System.in );
		int		n	= cin.nextint();
		BigInteger	ans	= BigInteger.ONE;
		for ( int i = 1; i &amp;lt;= n; i++ )
			ans = ans.multiply( BigInteger.valueOf( i ) );
		System.out.println( ans );
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;全排列-函数&#34;&gt;全排列 函数&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;

int main()
{
    int num[8] = { 1, 2, 3, 4, 5, 6, 7, 8 };
    do
    {
        cout    &amp;lt;&amp;lt; num[0] &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; num[1] &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; num[2] &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; num[3] &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; num[4] &amp;lt;&amp;lt; &amp;quot; &amp;quot;
            &amp;lt;&amp;lt; num[5] &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; num[6] &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; num[7] &amp;lt;&amp;lt; endl;
    }
    while ( next_permutation( num, num + 8 ) ); /* 全排列函数 */

    return(0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;经典例题&#34;&gt;经典例题&lt;/h2&gt;

&lt;h3 id=&#34;说反话&#34;&gt;说反话&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;stack&amp;gt;
using namespace std;
int main()
{
	stack&amp;lt;string&amp;gt;	v;
	string		s;
	while ( cin &amp;gt;&amp;gt; s )
		v.push( s );
	/* 入站 */
	cout &amp;lt;&amp;lt; v.top();
	/* 站顶 */
	v.pop();
	/* 弹出站顶 */
	while ( !v.empty() )
	{
		cout &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; v.top();
		v.pop();
	}
	return(0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;悄悄关注&#34;&gt;悄悄关注&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * 新浪微博上有个“悄悄关注”，一个用户悄悄关注的人，不出现在这个用户的关注列表上，但系统会推送其悄悄关注的人发表的微博给该用户。现在我们来做一回网络侦探，根据某人的关注列表和其对其他用户的点赞情况，扒出有可能被其悄悄关注的人。
 * 输入格式：
 * 输入首先在第一行给出某用户的关注列表，格式如下：
 * 人数N 用户1 用户2 …… 用户N
 * 其中N是不超过5000的正整数，每个“用户i”（i=1, ..., N）是被其关注的用户的ID，是长度为4位的由数字和英文字母组成的字符串，各项间以空格分隔。
 * 之后给出该用户点赞的信息：首先给出一个不超过10000的正整数M，随后M行，每行给出一个被其点赞的用户ID和对该用户的点赞次数（不超过1000），以空格分隔。注意：用户ID是一个用户的唯一身份标识。题目保证在关注列表中没有重复用户，在点赞信息中也没有重复用户。
 * 输出格式：
 * 我们认为被该用户点赞次数大于其点赞平均数、且不在其关注列表上的人，很可能是其悄悄关注的人。根据这个假设，请你按用户ID字母序的升序输出可能是其悄悄关注的人，每行1个ID。如果其实并没有这样的人，则输出“Bing Mei You”。
 */
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;map&amp;gt;
using namespace std;

/* 结构体数组 */
struct pepole
{
    char    name[20];
    int    num;
}
peoples[10001];

/* 结构体排序 */
bool cmp( pepole x, pepole y )
{
    return(x.name &amp;gt; y.name); /*按姓名排序 */
}


int main()
{
    int            n, num;
    double            sum = 0;
    char            a[20];
    map&amp;lt;string, int&amp;gt;    m;

    cin &amp;gt;&amp;gt; n;
    for ( int i = 0; i &amp;lt; n; i++ )
    {
        cin &amp;gt;&amp;gt; a;
        m[a] = 1; /* map键值对赋值 */
    }

    cin &amp;gt;&amp;gt; num;
    for ( int i = 0; i &amp;lt; num; i++ )
    {
        scanf( &amp;quot;%s %d&amp;quot;, &amp;amp;peoples[i].name, &amp;amp;peoples[i].num );
        sum += peoples[i].num;
    }
    sort( peoples, peoples + num, cmp ); /* 自定义排序 */
    sum /= num;

    int flag = 1;
    for ( int i = 0; i &amp;lt; num; i++ )
    {
        /* 大于平均值 且 不在关注列表中 */
        if ( peoples[i].num &amp;gt; sum &amp;amp;&amp;amp; m[peoples[i].name] == 0 )
            printf( &amp;quot;%sn&amp;quot;, peoples[i].name ), flag = 0;
    }
    if ( flag )
        printf( &amp;quot;Bing Mei Youn&amp;quot; );

    return(0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;括号配对&#34;&gt;括号配对&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;stack&amp;gt;
using namespace std;
int main()
{
	int t, len;
	scanf( &amp;quot;%d&amp;quot;, &amp;amp;t );
	getchar();
	while ( t-- )
	{
		char		s[10010];
		stack&amp;lt;char&amp;gt;	m;
		gets( s );
		len = strlen( s );
		m.push( s[0] );
		for ( int i = 1; i &amp;lt; len; i++ )
		{
			if ( m.size() == 0 )
				m.push( s[i] );
			else{
				if ( m.top() == &#39;(&#39; &amp;amp;&amp;amp; s[i] == &#39;)&#39; )
					m.pop();
				else if ( m.top() == &#39;[&#39; &amp;amp;&amp;amp; s[i] == &#39;]&#39; )
					m.pop();
				else
					m.push( s[i] );
			}
		}
		if ( m.empty() )
			printf( &amp;quot;Yes\n&amp;quot; );
		else
			printf( &amp;quot;No\n&amp;quot; );
	}
	return(0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>纪念姚贝儿诞辰37周年</title>
      <link>https://halklein.github.io/2018/14/</link>
      <pubDate>Wed, 26 Sep 2018 20:00:35 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2018/14/</guid>
      <description>&lt;p&gt;今天是2018年9月26日，一转眼，你离开我们已经三年半了&lt;/p&gt;

&lt;p&gt;我大概不是一个合格的粉丝，因为知道你的时候实在是太晚了。我一向是不爱看选秀娱乐节目的，2018年3月在家闲得无聊就回放了中国好声音；当听到你声音的时候我震惊了，好久没有听过这么纯粹干净而有力的声音了，每个字都清晰可见。当看到那个穿着牛仔裤、体恤衫、平底鞋，面上露出灿烂笑容的你时，感觉特别的自然亲切，一首 也许明天 ，那是我认识你的歌，惊叹于娇小身躯里蕴含的强大爆发力。
&lt;img src=&#34;https://i.loli.net/2019/12/09/rRJTVKZAuxjNlPq.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;2006年青歌赛亚军，2008年青歌赛史上唯一满分冠军的你本就具有常人所不及的实力，不需要选秀来证明自己。一开始我是很不理解的，感觉你在欺负对手，好声音的学员本来大部分就是业余歌手。带着太多的不解，我找了你很多资料，也终于明白了你，你不想待在海政文工团，那不是你梦想的地方；终于得了抑郁症的你在生命的最艰难的时刻，决定从军队中脱离了出来，想唱流行音乐，也想像那些歌手一样，站在舞台上，穿一身休闲装，吼得歇斯底里。而不是穿一身的军装，站的端庄典雅。而选秀节目当然是一个好机会。选秀无论有多少黑幕，那对你来说其实都不重要，你已经成功了，很多人都就此认识了你，如今好声音已经不存在了，而你虽已走，却活在了很多人心里。逐渐认识你之后，我发现自己曾经哼的许多歌，原来是你唱的，曾经惊讶于甄嬛传《红颜劫》的歌声，有时哼唱的《随他吧》、《如果我们没有遇见》还有好听的年欢晚会歌曲《天耀中华》原来都是你演唱的！
&lt;img src=&#34;https://i.loli.net/2019/12/09/G3e5BVgJDEK4hXL.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;有人说喜欢一个明星就是 &lt;strong&gt;始于颜值，陷于才华，忠于人品&lt;/strong&gt;  ；我觉得说得非常对了。我所理解的明星大都是利益的产物，大多演员都具有美丽的容颜，而歌手一般都比较有才华，但是他们大多源于利益又促进利益，很多人也渐渐追逐利益；真正谈得上人品的实在太少了。这也是我一直不追星的原因。&lt;/p&gt;

&lt;p&gt;喜欢你，始于你的音乐天赋。姚贝儿你应该算是人品好的，2015年1月16日下午16时55分，因乳腺癌复发，于北京大学深圳医院病逝，离世前，决定捐献眼角膜，如今这对眼角膜已经帮助三四名病者重现光明，成为深圳市第九百多例角膜捐献者。获得“广东好人”荣誉称号，并成为第五届全国道德模范广东省候选人。之后，家里拍卖了部分遗物，而所有的都捐到了新疆西藏等贫困地区用于修建爱心图书馆。是怎样的家庭才能培养出如此优秀善良的女儿呢？
&lt;img src=&#34;https://i.loli.net/2019/12/09/Z8CrSdtFXeG5Vpq.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;2015年4月9日，据国际天文学联合会（IAU）出版的小行星公告，将第41981号小行星被命名为“ &lt;strong&gt;姚贝娜星&lt;/strong&gt; ”（Yaobeina）。这也刚好对应了你1981出生日期。美国宇航局网站上这样介绍姚贝娜：姚贝娜（1981-2015），一位才华横溢又充满勇气的中国女歌手，曾因在流行音乐方面的造诣屡获奖项。她有一首歌叫做《心火》，讲述她与癌症抗争的故事。不幸离世后，她捐献出了自己的眼角膜。”，姚贝娜的“教父”、诗人、词作家&lt;strong&gt;唐跃生&lt;/strong&gt;为姚贝娜写了一首词，名为《女儿》：“有个女儿好比拥有许多自己，你代替我去穿越阳光风雨；如果有一天回到我身边，请全世界暂时离开你”。姚峰说，有了这颗姚贝娜星，他想把词中的“阳光风雨”改为“苍穹天宇”，要为它好好地谱个曲，再好好地唱出来。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;爸，我不怕死，&lt;/p&gt;

&lt;p&gt;可是我死了之后，爸爸妈妈怎么办！&lt;/p&gt;

&lt;p&gt;我的粉丝，他们对我太好了，&lt;/p&gt;

&lt;p&gt;如果我死了，他们一定会很伤心的，&lt;/p&gt;

&lt;p&gt;我对不起他们啊……&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如今你真的不在了，你可知，你走后，那段时间百度搜索你的名字都是灰色的；你走后，一颗小行星以你的名字命名，北京文艺频道三年为你制作纪念特辑，刘家昌老师发布了你的专辑《永存》所有收入都一样捐赠了，以你名义建立的爱心书屋越来越多，李玉刚老师还为你写了歌；做重要的是贝壳们一直想着你念着你，他们经常来石门峰看你，你的墓前一直鲜花不败，写给你的祝福挂满了长廊。贝壳将带你继续看这个美丽的世界。&lt;/p&gt;

&lt;p&gt;在此，怀着深深的不舍和敬意向你祝福：愿天堂没有病痛，愿你能在天堂继续快乐的歌唱，姚贝儿37岁生日快乐！
&lt;img src=&#34;https://i.loli.net/2019/12/09/6EyqfbwBzjoOeA4.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>汉明码（海明码）计算与纠错</title>
      <link>https://halklein.github.io/2018/13/</link>
      <pubDate>Wed, 12 Sep 2018 20:36:39 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2018/13/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;海明码在网络、通信和操作系统中都有着广泛的运用，同时也是软考的必考内容，所以写这篇笔记以备忘
关于海明码
海明码是一种线性纠错码，由理查德 · 卫斯里 · 汉明于 1950 年发明；汉明码是完备码，它在于它分组长度相同、最小距离为 3 的码中能达到最高的码率。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;1-求海明码&#34;&gt;1. 求海明码&lt;/h2&gt;

&lt;h3 id=&#34;1-1-确定校验码的位数-k&#34;&gt;1.1 确定校验码的位数 k&lt;/h3&gt;

&lt;p&gt;假设校验位有 r 位，信息位有 k 位，整个码字的长度就是 k+r；每一位的数据只有两种状态，不是 1 就是 0，有 a 位数据就应该能表示出 2^a 种状态，每一种状态非 0 即 1，代表一个码元发生了错误，有 k+r 位码元，就要有 k+r 种状态来表示，另外还要有一种状态来表示数据正确的情况，所以 2^r≥k+r+1 才能检查一位错误，即：2^r-1≥k+r&lt;/p&gt;

&lt;p&gt;假设信息位为 01101110，共 8 位（k=8）, 所以至少要 4 个校验位来检测一位错误（r=4）&lt;/p&gt;

&lt;h3 id=&#34;1-2-确定校验码的位置&#34;&gt;1.2 确定校验码的位置&lt;/h3&gt;

&lt;p&gt;校验码 Pi（i 取 1,2,4,8…）在编码中的位置为 2^(i-1)&lt;/p&gt;

&lt;p&gt;假设上面的例子数据从左到右为 D1、D2、……、D8&lt;/p&gt;

&lt;p&gt;校验码为 P1、P2、P4、P8，即校验位在 1，2，4，8，16… 等位置上&lt;/p&gt;

&lt;p&gt;M1,M2….Mn 表示海明码&lt;/p&gt;

&lt;p&gt;得到如下表格：
&lt;img src=&#34;https://i.loli.net/2019/12/09/P6ziJxdayuYjLXA.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;填入数据后：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/09/knwhHtyFxSBeuNm.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;即，得到了 M3、M5、M6、M7、M9、M10、M11、M12 的值，现在只要求得校验位 P1、P2、P4、P8 的值也就求出了海明码。&lt;/p&gt;

&lt;h3 id=&#34;1-3-求出校验位的值&#34;&gt;1.3 求出校验位的值&lt;/h3&gt;

&lt;p&gt;Pi 校验的位是从 Mi 开始连续 i 位，然后间隔 i 位，再校验连续 i 位，再间隔…….
&lt;img src=&#34;https://img2018.cnblogs.com/blog/1177175/201904/1177175-20190413223732922-861465090.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;即 ：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;P1 校验数据位 1，3，5，7，9，11，…&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;P2 校验数据位 2，3，6，7，10，11，…&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;P4 校验数据位 4，5，6，7，12，…&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;P8 校验数据位 8，9，10，11，12，…&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然后根据公式进行异或运算：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;P1=M1⊕M3⊕M5⊕M7⊕M9⊕M11&lt;/li&gt;
&lt;li&gt;P2=M2⊕M3⊕M6⊕M7⊕M10⊕M11&lt;/li&gt;
&lt;li&gt;P4=M4⊕M5⊕M6⊕M7⊕M12&lt;/li&gt;
&lt;li&gt;P8=M8⊕M9⊕M10⊕M11⊕M12&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;与校验位数据和信息位数据对应后得到：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;P1=P1⊕D1⊕D2⊕D4⊕D5⊕D7&lt;/li&gt;
&lt;li&gt;P2=P2⊕D1⊕D3⊕D4⊕D6⊕D7&lt;/li&gt;
&lt;li&gt;P4=P4⊕D2⊕D3⊕D4⊕D8&lt;/li&gt;
&lt;li&gt;P8=P8⊕D5⊕D6⊕D7⊕D8&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果海明码没有错误信息，那 P1 、P2 、P4 、P4… 应该都为 0。等式右边的值也得为 0，由于是异或运算，所以 Pi（i 取 1,2,4…）的值跟后边的式子必须同为 0 或 1，才能使整个式子的值为零，故：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;P1=D1⊕D2⊕D4⊕D5⊕D7&lt;/li&gt;
&lt;li&gt;P2=D1⊕D3⊕D4⊕D6⊕D7&lt;/li&gt;
&lt;li&gt;P4=D2⊕D3⊕D4⊕D8&lt;/li&gt;
&lt;li&gt;P8=D5⊕D6⊕D7⊕D8&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;带入数据位对应的值&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;P1=0⊕1⊕1⊕0⊕1 = 1&lt;/li&gt;
&lt;li&gt;P2=0⊕1⊕1⊕1⊕1 = 0&lt;/li&gt;
&lt;li&gt;P4=1⊕1⊕1⊕0 = 1&lt;/li&gt;
&lt;li&gt;P8=0⊕1⊕1⊕0 = 0

&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;1-4-得到海明码&#34;&gt;1.4 得到海明码&lt;/h3&gt;

&lt;p&gt;​   就校验位和信息位合起来就得到海明码，即上面例子所求海明码为：(0110 0111 1001)
​   由于上面的式子中，出现 Pi 的次数不同，其中 D4 和 D7 出现了 3 次，而 D1，D2，D3，D5，D6，D8 只出现了 2 次，此时不同代码的海明码 码距不等，为此再补充一位校验位 (假设为 Pv)，使得 Pv = D1⊕D2⊕D3⊕D5⊕D6⊕D8 , 这样使得每个信息位都出现 3 次，当任一信息位发生变化时，将引起 3 个 Pi 的值跟着变化，即合法海明码的码距都为 4。&lt;/p&gt;

&lt;p&gt;​   该例子求得 Pv = 1，故最后求得海明码为：(1 0110 0111 1001)&lt;/p&gt;

&lt;h2 id=&#34;2-海明码纠错&#34;&gt;2. 海明码纠错&lt;/h2&gt;

&lt;p&gt;​   现在假设第 5 位出错了，也就是第五位在传输的过程中被改为 “1“了（D5 由 0 变为 1）。即得到的数据为 (1 0111 0111 1001)。现在要找出错误的位置（假设现在不知道出错的位置）。&lt;/p&gt;

&lt;p&gt;​   我们继续按上式求解，得到&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;S1=P1⊕D1⊕D2⊕D4⊕D5⊕D7 = 1&lt;/li&gt;
&lt;li&gt;S2=P2⊕D1⊕D3⊕D4⊕D6⊕D7 = 0&lt;/li&gt;
&lt;li&gt;S3=P4⊕D2⊕D3⊕D4⊕D8 = 0&lt;/li&gt;
&lt;li&gt;S4=P8⊕D5⊕D6⊕D7⊕D8 = 1&lt;/li&gt;
&lt;li&gt;S5=Pv⊕D1⊕D2⊕D3⊕D5⊕D6⊕D8 = 0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​   然后将 S5S4S3S2S1 = 01001 转为十进制 = 9，即求得 (1 0111 0111 1001) 第 9 位出错，将 1 改为 0 完成纠错&lt;/p&gt;

&lt;h2 id=&#34;3-ps&#34;&gt;3. PS&lt;/h2&gt;

&lt;p&gt;​   海明码如果要检测 d 位错误，需要一个海明距为 d+1 的编码方案；&lt;/p&gt;

&lt;p&gt;​   如果要纠出 d 位错误，需要一个海明距为 2d+1 的编码方案；&lt;/p&gt;

&lt;p&gt;​   海明码的纠错能力恒小于等于检错能力。&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>八月长沙行</title>
      <link>https://halklein.github.io/2018/15/</link>
      <pubDate>Wed, 29 Aug 2018 19:39:09 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2018/15/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/10/eOPspgf7MBX8bcq.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;18年暑假大部分时间是在湖南度过的，由于气温一直不比重庆凉快，所以就没出门去，最后还是决定去长沙玩几天。&lt;/p&gt;

&lt;p&gt;已经不是第一次来长沙，上一次来是去年国庆的时候，当时还有幸看了一场橘子洲的焰火表演，场面甚是壮观，是我见过最壮美的烟花表演了&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;史料记载，“湖南生产鞭炮始于唐代，发达于宋末及清乾隆年间……湘东之平江、浏阳、醴陵……均为爆竹制造中心地”。至今已有1300多年的历史。在2010年，长沙市政府为提升城市竞争力，发展长沙旅游业，决定以“浏阳花炮”为品牌，以橘子洲为载体，把山、水、洲、城这一独特的城市景观展示给国内外游客，开始了烟花表演。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;由于燃放规模十分的大，它所带来的环境污染问题也同样不容小觑，中央环保督察组巡视长沙环保工作情况时，就提出长沙要整改在橘子洲燃放大型焰火的问题，据传，今后很可能取消橘子洲的焰火表演，真的是看一次少一次了！可惜没能找到去年拍的照片了。&lt;/p&gt;

&lt;p&gt;长沙，最出名应该是美食了，比如长沙臭豆腐、糖油粑粑等，大街小巷都有。&lt;/p&gt;

&lt;p&gt;其实，对我而言长沙有一个好喝的奶茶 — 茶颜悦色&lt;/p&gt;

&lt;p&gt;茶颜悦色是长沙本土奶茶品牌，主打新中式鲜茶；这个店只在长沙开，记得17年来长沙的时候应该也就十来个门店吧，可是这次去发现时长拐角都能看见，其实我不太想看到这样的结果，我更希望它只是那几个一直精美的奶茶店。不过还是想喝，去买了两杯，没错还是熟悉的味道，每种口味都那么好喝，都是每次来必喝的茶颜啊！&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/10/izgfLFvBaCJZQYX.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后是这次长沙行的第一站：&lt;strong&gt;岳麓山&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/10/JyUCSQR1g9fVApb.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;选择的是索道上山，这也是我第一次坐索道（嗯，下一次要去试试重庆长江索道），一开始还是有点怕的，高的地方大概有二三十米吧，而且我觉得索道那个装置怎么看起来这么不靠谱（哈哈），不过还是上了，主要是懒得爬山&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/10/o8W2HaXjPIzKMeE.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;上去之后发现其实岳麓山也没想象中好玩，只是在索道和山上能俯瞰长沙的风景，还是挺不错；难道这就是《沁园春 雪》里“橘子洲头，看万山红遍”，里说的山吗？&lt;/p&gt;

&lt;p&gt;之后，沿着路走，一直到了&lt;strong&gt;爱晚亭&lt;/strong&gt;，杜牧的《山行》就写的这儿，爱晚亭也是中国四大名亭之一。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;远上寒山石径斜，白云生处有人家。&lt;/strong&gt;
&lt;strong&gt;停车坐爱枫林晚，霜叶红于二月花。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/10/5QZm3tyxEIcj2L7.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在离爱晚亭不远处，就是岳麓书院了，又是一个中国四大之一….&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/10/SCy6Q7iqOtRvKFu.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;第二天，去了 &lt;strong&gt;长沙IFS&lt;/strong&gt; （长沙国际金融中心），是长沙第一高楼，集大型精品商场、高端写字楼及国际白金五星级酒店等设施于一体的超高层大型城市综合体。总建筑面积101万平方米，主塔楼设计高度452米，副塔楼设计高度315米。上一次来的时候是阴天，有薄薄的雾，整个IFS大楼直插云霄&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/10/1S5LwKAfEXZgpVB.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后是去了IFS里号称米其林一星级餐厅的 – &lt;strong&gt;鹅夫人&lt;/strong&gt; 餐厅品尝一番，感觉有点贵呀，5片鹅肝59元， 感觉有点腻，不是很喜欢吃…&lt;/p&gt;

&lt;p&gt;还是这道天鹅叉烧酥比较好看&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/10/fBgaMY8eP5KscLT.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最后一天，去了被誉为“&lt;strong&gt;星城之眼&lt;/strong&gt;”的亚洲第一巨型摩天轮&lt;/p&gt;

&lt;p&gt;坐落在长沙贺龙体育广场．这个巨型摩天轮高120m，直径99m，最令人称奇的是它建立在巨型屋顶上；摩天轮还有一个特点，就是每到夜间，由电脑控制的它能散发50多种不同组合的光芒。
&lt;img src=&#34;https://i.loli.net/2019/12/10/zvPnT1rdCgsiGjx.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;一开始以为120m不高，可是当转到半空后，开始感觉到有点恐高，第一次坐摩天轮，还是比较好玩。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;传说摩天轮的每个盒子里都装满了幸福&lt;/p&gt;

&lt;p&gt;当我们仰望摩天轮的时候&lt;/p&gt;

&lt;p&gt;就是在仰望幸福&lt;/p&gt;

&lt;p&gt;幸福有多高&lt;/p&gt;

&lt;p&gt;摩天轮就有多高&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最后的最后当然是离开长沙了，有点不舍…&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/10/ohARFik2eaGUpwO.jpg&#34; alt=&#34;长沙南站&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;ps&#34;&gt;PS&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;自从上了大学后，感觉万年没有写文章了，&lt;/p&gt;

&lt;p&gt;所以，疯狂放图…留个纪念&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;拍摄设备：&lt;strong&gt;Meizu 16 th&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;压缩工具：&lt;strong&gt;Antelope&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>