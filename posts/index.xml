<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on HalKlein`s Blog</title>
    <link>https://halklein.github.io/posts/</link>
    <description>Recent content in Posts on HalKlein`s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <managingEditor>dev.HalKlein@gmail.com (HalKlein)</managingEditor>
    <webMaster>dev.HalKlein@gmail.com (HalKlein)</webMaster>
    <lastBuildDate>Sun, 02 Feb 2020 09:41:30 +0800</lastBuildDate>
    <atom:link href="https://halklein.github.io/posts/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Spring 整合 Kafka</title>
      <link>https://halklein.github.io/2020/035/</link>
      <pubDate>Sun, 02 Feb 2020 09:41:30 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2020/035/</guid>
      <description>

&lt;h2 id=&#34;引入依赖&#34;&gt;引入依赖&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://mvnrepository.com/artifact/org.springframework.kafka/spring-kafka&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://mvnrepository.com/artifact/org.springframework.kafka/spring-kafka&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;为更好的兼容性，使用父pom中声明的版本即可，不要单独声明版本&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.kafka&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-kafka&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;配置kafka&#34;&gt;配置Kafka&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;# 配置 Kafka
# 服务器地址及端口
spring.kafka.bootstrap-servers=localhost:9092
# 消费者分组ID，对应consumer.properties文件中的配置
spring.kafka.consumer.group-id=community-consumer-group
# 是否自动提交消费者的偏移量
spring.kafka.consumer.enable-auto-commit=true
# 自动提交的频率（单位：ms）
spring.kafka.consumer.auto-commit-interval=3000
# 当消费者找不到指定Topic时忽略该异常，Kafka 2.3之后新增，
# 否则可能启动不起项目，报错：java.lang.IllegalStateException: Topic(s) [xxx] is/are not present and missingTopicsFatal is true
spring.kafka.listener.missing-topics-fatal=false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;访问kafka&#34;&gt;访问Kafka&lt;/h2&gt;

&lt;h3 id=&#34;先启用服务&#34;&gt;先启用服务&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;1.先启动Zookeeper&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;打开一个cmd窗口，cd到Kafka安装目录，执行（使用指定配置文件，启动Zookeeper）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;$ bin\windows\zookeeper-server-start.bat config\zookeeper.properties
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2.启动Kafka&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;另外打开一个cmd窗口，cd到Kafka安装目录，执行（使用指定配置文件，启动Kafka）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;$ bin\windows\kafka-server-start.bat config\server.properties
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你修改过配置文件，记得重启服务才能生效。&lt;/p&gt;

&lt;h3 id=&#34;开发测试类&#34;&gt;开发测试类&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootTest
@ContextConfiguration(classes = CommunityApplication.class)
public class KafkaTests {

    @Autowired
    private KafkaProducer kafkaProducer;

    @Test
    public void testKafka() {

        // 生产者发信息
        kafkaProducer.sendMessage(&amp;quot;test&amp;quot;, &amp;quot;你好！&amp;quot;);
        kafkaProducer.sendMessage(&amp;quot;test&amp;quot;, &amp;quot;在吗？&amp;quot;);

        // 阻塞，等待
        try {
            Thread.sleep(1000 * 10);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

    }

}

// 生产者
@Component
class KafkaProducer {

    @Autowired
    private KafkaTemplate kafkaTemplate;

    // 发消息
    public void sendMessage(String topic, String content) {
        kafkaTemplate.send(topic, content);
    }

}

// 消费者
@Component
class KafkaConsumer {

    // 收消息
    @KafkaListener(topics = {&amp;quot;test&amp;quot;})
    // 收到消息会封装到ConsumerRecord
    public void handleMessage(ConsumerRecord record) {
        System.out.println(record.value());
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;运行测试类主方法&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;你好！
在吗？
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kafka入门</title>
      <link>https://halklein.github.io/2020/034/</link>
      <pubDate>Sun, 02 Feb 2020 09:38:38 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2020/034/</guid>
      <description>

&lt;h2 id=&#34;kafka简介&#34;&gt;Kafka简介&lt;/h2&gt;

&lt;p&gt;早先的时候Kafka只是一个消息队列，只是用来发消息，后来经过不断的完善，扩充自己的功能，慢慢的其功能就不再仅仅局限于消息队列了，所以其官网自称：Apache Kafka® is &lt;em&gt;a distributed streaming platform&lt;/em&gt; 。其应用也十分广泛，消息系统、日志收集、用户行为追踪、流式处理等。&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;kafka的特点&#34;&gt;Kafka的特点&lt;/h2&gt;

&lt;p&gt;高吞吐量、消息持久化、高可靠性、高扩展性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;消息持久化&lt;/strong&gt;是指，Kafka会将消息存到硬盘等永久介质上，这也是Kafka能够构建TB级别消息系统的基础。误区也在这里，硬盘存取效率这么低存到硬盘上不会影响性能吗？其实，硬盘在顺序读写时其性能是很高的，甚至可能高于对内存的随机读写，Kafka就利用了这一点，它对硬盘的读写都是顺序的，这样既保持了高性能又保证了足够大的空间。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;高可靠性&lt;/strong&gt;，主要体现在它是一个分布式的服务器，可以做集群部署。&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;kafka相关术语&#34;&gt;Kafka相关术语&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Broker&lt;/strong&gt;：Kafka服务器 。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Zookeeper&lt;/strong&gt;：是一个独立的应用和概念，用来管理集群，Kafka需要做集群，就可以使用Zookeeper 。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Topic&lt;/strong&gt;：消息队列实现的方式大致有两种：点对点的方式，发布订阅方式；Kafka采用发布订阅方式，生产者把消息发布到的空间就叫Topic 。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Partition&lt;/strong&gt;：分区，对Topic的分区，可以对多个分区进行多线程写入，提高并发能力  。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/02/02/uyw86jHIfW5ahsD.png&#34; alt=&#34;Partition&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Offset&lt;/strong&gt;：消息在Partition内存放的索引&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/02/02/2dwDHtVxsqeEG8S.png&#34; alt=&#34;Offset&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Replica&lt;/strong&gt;：副本，对数据做备份，Kafka是分布式的所以为了保证可靠性数据不会只存一份，需要通过副本的形式对数据存储很多份，每个分区有多个副本。分为 Leader Replica（主副本） 和 Follower Replica （随从副本），如果主副本失效了，那么集群会从众多随从副本中选一个新的作为主副本。&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;安装kafka&#34;&gt;安装Kafka&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://kafka.apache.org/downloads&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://kafka.apache.org/downloads&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下载的Kafka的包中，解压后bin目录能看到里面内置了用于Linux的.sh的命令，也有用于Windows的.bat命令。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;配置Zookeeper.properties`&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;配置Kafka内置的Zookeeper的配置文件 &lt;code&gt;zookeeper.properties&lt;/code&gt; ，主要是配置Zookeeper运行时产生的数据的存放位置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;dataDir=e:/Test/data/zookeeper
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;配置server.properties&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Kafka日志存放位置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;log.dirs=e:/Test/log/kafka-logs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;使用kafka-示例&#34;&gt;使用Kafka，示例&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;1.先启动Zookeeper&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;打开一个cmd窗口，cd到Kafka安装目录，执行（使用指定配置文件，启动Zookeeper）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;$ bin\windows\zookeeper-server-start.bat config\zookeeper.properties
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2.启动Kafka&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;另外打开一个cmd窗口，cd到Kafka安装目录，执行（使用指定配置文件，启动Kafka）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;$ bin\windows\kafka-server-start.bat config\server.properties
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.使用Kafka&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;另外打开一个cmd窗口，cd到Kafka的bin/windows目录下，执行以下命令创建主题Topic&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;# 在 bootstrap-server服务器主机地址和端口 上创建1个副本1个分区的主题‘test’
$ kafka-topics.bat --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看所有主题，验证上条命令是否执行成功&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;$ kafka-topics.bat --list --bootstrap-server localhost:9092
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;4.往主题上发送消息（生产者身份）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;执行如下命令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;$ kafka-console-producer.bat --broker-list localhost:9092 --topic test
&amp;gt;Hello
&amp;gt;World
&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;5.获取消息（消费着身份）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;另外打开一个cmd窗口，cd到Kafka的bin/windows目录下，执行如下命令，看看能不能得到消息Hello和World&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;$ kafka-console-consumer.bat --bootstrap-server localhost:9092 --topic test --from-beginning
Hello
World

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时，在生产者命令窗口继续发消息比如&amp;rsquo;Hello Kafka&amp;rsquo;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;&amp;gt;Hello
&amp;gt;World
&amp;gt;Hello Kafka
&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再打开消费者命令窗口，就可以看到收到了消息‘Hello Kafka’&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;Hello
World
Hello Kafka

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>阻塞队列 BlockingQueue</title>
      <link>https://halklein.github.io/2020/033/</link>
      <pubDate>Sat, 01 Feb 2020 19:23:29 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2020/033/</guid>
      <description>

&lt;h2 id=&#34;blockingqueue&#34;&gt;BlockingQueue&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/02/01/YD12so6nTyWihrx.png&#34; alt=&#34;BlockingQueue&#34; /&gt;&lt;/p&gt;

&lt;p&gt;阻塞队列是Java自带的核心API，具体来说就是一个BlockingQueue接口，主要用来解决线程通信的问题。当然我们有很多解决线程通信问题的方法，只不过BlockingQueue更简单易用些，其主要有两个方法put、take来解决问题，用于存队列中存和取一个数据。比如上图，线程1与线程2通信，线程1调用put方法将数据放入阻塞队列中，然后线程2调用take方法从阻塞队列中取值，这样处理问题的方式满足&lt;strong&gt;生产者消费者模式&lt;/strong&gt;，线程1是生产者，线程2是消费者，BlockingQueue其实就是在生产者和消费者之间构建了一个缓冲区，避免了两个线程之间直接打交道，带来的问题（生产的一直生产，等待的一直等待，造成CPU资源的浪费）。&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;blockingqueue的实现类&#34;&gt;BlockingQueue的实现类&lt;/h2&gt;

&lt;p&gt;BlockingQueue是一个接口，不能直接使用，JDK中带了很多它的实现类，它们各有特点和优势。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;​ ArrayBlockingQueue，数组实现&lt;/li&gt;
&lt;li&gt;​ LinkedBlockingQueue，链表实现&lt;/li&gt;
&lt;li&gt;​ PriorityBlockingQueue、SynchronousQueue、DelayQueue等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;更多查阅 Java API ：&lt;a href=&#34;https://docs.oracle.com/javase/8/docs/api/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://docs.oracle.com/javase/8/docs/api/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h3 id=&#34;arrayblockingqueue阻塞队列测试&#34;&gt;ArrayBlockingQueue阻塞队列测试&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.Random;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;

public class BlockingQueueTests {

    public static void main(String[] args) {
        // 使用ArrayBlockingQueue进行测试，长度：10
        BlockingQueue queue = new ArrayBlockingQueue(10);

        new Thread(new Producer(queue)).start();

        new Thread(new Consumer(queue)).start();
        new Thread(new Consumer(queue)).start();
        new Thread(new Consumer(queue)).start();
    }

}

// 生产者线程
class Producer implements Runnable {

    private BlockingQueue&amp;lt;Integer&amp;gt; queue;

    public Producer(BlockingQueue&amp;lt;Integer&amp;gt; queue) {
        this.queue = queue;
    }

    @Override
    public void run() {
        try {
            for (int i = 0; i &amp;lt; 100; i++) {
                // 设置间隔
                Thread.sleep(20);
                queue.put(i);
                System.out.println(Thread.currentThread().getName() + &amp;quot; 生产: &amp;quot; + queue.size());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

// 消费者线程
class Consumer implements Runnable {

    private BlockingQueue&amp;lt;Integer&amp;gt; queue;

    public Consumer(BlockingQueue&amp;lt;Integer&amp;gt; queue) {
        this.queue = queue;
    }

    @Override
    public void run() {
        try {
            while (true) {
                // 设置间隔
                Thread.sleep(new Random().nextInt(1000));
                queue.take();
                System.out.println(Thread.currentThread().getName() + &amp;quot; 消费: &amp;quot; + queue.size());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;运行结果&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;Thread-0 生产: 1
Thread-0 生产: 2
Thread-1 消费: 1
Thread-0 生产: 2
Thread-0 生产: 3
Thread-0 生产: 4
Thread-0 生产: 5
Thread-0 生产: 6
Thread-0 生产: 7
Thread-0 生产: 8
Thread-0 生产: 9
Thread-0 生产: 10
Thread-1 消费: 9
Thread-0 生产: 10
Thread-3 消费: 9
Thread-0 生产: 10
...
...
...
Thread-3 消费: 9
Thread-0 生产: 10
Thread-1 消费: 9
Thread-0 生产: 10
Thread-3 消费: 9
Thread-3 消费: 8
Thread-2 消费: 7
Thread-1 消费: 6
Thread-2 消费: 5
Thread-2 消费: 4
Thread-1 消费: 3
Thread-2 消费: 2
Thread-2 消费: 1
Thread-2 消费: 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，生产者线程一直在生产数据，但是达到10个时停止生产，3个消费者线程，错杂消费着数据，直到最后生产者停止生产，消费者最终将数据消费完，此时程序并没有结束，消费者线程还在等待着数据。ArrayBlockingQueue实现了这个过程中数据的缓冲。&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Spring 整合 Redis</title>
      <link>https://halklein.github.io/2020/032/</link>
      <pubDate>Fri, 31 Jan 2020 11:54:23 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2020/032/</guid>
      <description>

&lt;h2 id=&#34;引入依赖&#34;&gt;引入依赖&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-redis&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;&lt;strong&gt;spring-boot-starter-data-redis&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- SpringBoot整合Redis，这里可以不要写version，因为在spring-boot-starter-parent中默认已经指定，
并且Spring自己测试过与当前兼容的Redis版本，这样不容易出错 --&amp;gt;
&amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;配置redis数据库参数&#34;&gt;配置Redis数据库参数&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;# 配置 Redis
# 使用的库（0-15）
spring.redis.database=11
# 主机地址
spring.redis.host=localhost
# 端口号，默认（6379）
spring.redis.port=6379
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;编写redis配置类-构造redistemplate&#34;&gt;编写Redis配置类，构造RedisTemplate&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.RedisSerializer;

// Redis 配置类
@Configuration
public class RedisConfig {

    /**
     * RedisAutoConfiguration中默认是RedisTemplate&amp;lt;Object, Object&amp;gt;，但Redis中的key都是String类型的
     * 虽然说Object具有通用性，但是多数时候不便于我们使用，这里直接就改为String类型的key好了
     *
     * @factory redisTemplate要想访问数据库，我们就需要将Redis数据库的连接工厂注入进来
     * @return
     */
    @Bean
    public RedisTemplate&amp;lt;String, Object&amp;gt; redisTemplate(RedisConnectionFactory factory) {
        RedisTemplate&amp;lt;String, Object&amp;gt; template = new RedisTemplate&amp;lt;&amp;gt;();
        template.setConnectionFactory(factory);

        // 指定key的序列化方式为String
        template.setKeySerializer(RedisSerializer.string());
        // 指定普通的value的序列化方式为JSON
        template.setValueSerializer(RedisSerializer.json());
        // Hash比较特殊单独设置
        // 指定Hash的key的序列化方式
        template.setHashKeySerializer(RedisSerializer.string());
        // 指定Hash的value的序列化方式
        template.setHashValueSerializer(RedisSerializer.json());

        // 使参数生效
        template.afterPropertiesSet();
        return template;
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;访问redis&#34;&gt;访问Redis&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.data.redis.core.BoundValueOperations;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.test.context.ContextConfiguration;

import java.util.concurrent.TimeUnit;

@SpringBootTest
//使用正式环境里面的配置类
@ContextConfiguration(classes = CommunityApplication.class)
public class RedisTests {

    @Autowired
    private RedisTemplate redisTemplate;

    /**
     * Redis 字符串测试
     */
    @Test
    public void testStrings() {
        String redisKey = &amp;quot;test:count&amp;quot;;

        // 存数据
        redisTemplate.opsForValue().set(redisKey, 1);
        // 获取数据
        System.out.println(redisTemplate.opsForValue().get(redisKey));
        System.out.println(redisTemplate.opsForValue().increment(redisKey));
        System.out.println(redisTemplate.opsForValue().decrement(redisKey));
    }


    /**
     * Redis Hash测试
     */
    @Test
    public void testHash() {
        String redisKey = &amp;quot;test:user&amp;quot;;

        // 存数据
        redisTemplate.opsForHash().put(redisKey, &amp;quot;id&amp;quot;, 1);
        redisTemplate.opsForHash().put(redisKey, &amp;quot;username&amp;quot;, &amp;quot;HalKlein&amp;quot;);

        // 取数据
        System.out.println(redisTemplate.opsForHash().get(redisKey, &amp;quot;id&amp;quot;));
        System.out.println(redisTemplate.opsForHash().get(redisKey, &amp;quot;username&amp;quot;));

    }


    /**
     * Redis List测试
     */
    @Test
    public void testLists() {
        String redisKey = &amp;quot;test:ids&amp;quot;;

        // 存数据
        redisTemplate.opsForList().leftPush(redisKey, 101);
        redisTemplate.opsForList().leftPush(redisKey, 102);
        redisTemplate.opsForList().leftPush(redisKey, 103);

        // 统计数据量
        System.out.println(redisTemplate.opsForList().size(redisKey));
        // 取数据
        System.out.println(redisTemplate.opsForList().index(redisKey, 0));
        System.out.println(redisTemplate.opsForList().range(redisKey, 0, 2));

        // 弹出数据
        System.out.println(redisTemplate.opsForList().leftPop(redisKey));
        System.out.println(redisTemplate.opsForList().leftPop(redisKey));
        System.out.println(redisTemplate.opsForList().leftPop(redisKey));
    }


    /**
     * Redis set集合测试
     */
    @Test
    public void testSets() {
        String redisKey = &amp;quot;test:teachers&amp;quot;;

        // 存数据
        redisTemplate.opsForSet().add(redisKey, &amp;quot;小明&amp;quot;, &amp;quot;小李&amp;quot;, &amp;quot;张三&amp;quot;, &amp;quot;小王&amp;quot;);

        // 统计数据量
        System.out.println(redisTemplate.opsForSet().size(redisKey));
        // 弹出数据
        System.out.println(redisTemplate.opsForSet().pop(redisKey));
        // 显示数据
        System.out.println(redisTemplate.opsForSet().members(redisKey));
    }


    /**
     * Redis SortedSets有序集合测试
     */
    @Test
    public void testSortedSets() {
        String redisKey = &amp;quot;test:students&amp;quot;;

        // 存数据
        redisTemplate.opsForZSet().add(redisKey, &amp;quot;悟空&amp;quot;, 100);
        redisTemplate.opsForZSet().add(redisKey, &amp;quot;八戒&amp;quot;, 80);
        redisTemplate.opsForZSet().add(redisKey, &amp;quot;沙僧&amp;quot;, 70);

        // 取数据
        System.out.println(redisTemplate.opsForZSet().zCard(redisKey));
        System.out.println(redisTemplate.opsForZSet().score(redisKey, &amp;quot;八戒&amp;quot;));
        System.out.println(redisTemplate.opsForZSet().reverseRank(redisKey, &amp;quot;悟空&amp;quot;));
        System.out.println(redisTemplate.opsForZSet().range(redisKey, 0, 1));
    }


    /**
     * Redis Key相关命令测试
     */
    @Test
    public void testKeys() {
        // 删除Key
        redisTemplate.delete(&amp;quot;test:user&amp;quot;);

        // 某个Key存在吗？
        System.out.println(redisTemplate.hasKey(&amp;quot;test:user&amp;quot;));

        // Key的有效时间
        redisTemplate.expire(&amp;quot;test:students&amp;quot;, 10, TimeUnit.SECONDS);
    }


    // 绑定Key，便于多次重复访问同一个key
    @Test
    public void testBoundOperations() {
        String redisKey = &amp;quot;test:count&amp;quot;;

        // 绑定Key
        BoundValueOperations operations = redisTemplate.boundValueOps(redisKey);

        System.out.println(operations.increment());
        System.out.println(operations.increment());
        System.out.println(operations.increment());
        System.out.println(operations.decrement());

        System.out.println(operations.get());
    }


}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;redis事务管理&#34;&gt;Redis事务管理&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/01/31/SpVmEIsaOig7Cj6.png&#34; alt=&#34;Redis事务&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Redis的事务，是将事务中产生的命令都添加到事务队列中，待整个事务提交后再统一出队按序进行执行。所以事务中的命令不会立即执行，比如 你在事务中做了一个查询，这个查询不会立即返回结果。由于这样的机制，通常对于Redis的事务管理，我们不会使用声明式事务，更多的使用编程式事务。&lt;/p&gt;

&lt;p&gt;另外，需要注意的是，Redis中的事务是&lt;strong&gt;不会回滚&lt;/strong&gt;（roll back）的，有一条命令出现错误，之前的命令不会回滚，会面的命令也将继续执行，因为Redis认为这些错误是由程序员自身的错误引起的并且回滚也不能实质性的解决问题，Redis选择了这样更加简单高效的事务处理方式。&lt;/p&gt;

&lt;h3 id=&#34;redis事务相关的命令&#34;&gt;&lt;strong&gt;Redis事务相关的命令&lt;/strong&gt;&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令原型&lt;/th&gt;
&lt;th&gt;命令描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;MULTI&lt;/td&gt;
&lt;td&gt;用于标记事务的开始，其后执行的命令都将被存入命令队列，直到执行EXEC时，这些命令才会被原子的执行。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;EXEC&lt;/td&gt;
&lt;td&gt;执行在一个事务内命令队列中的所有命令，同时将当前连接的状态恢复为正常状态，即非事务状态。如果在事务中执行了WATCH命令，那么只有当WATCH所监控的Keys没有被修改的前提下，EXEC命令才能执行事务队列中的所有命令，否则EXEC将放弃当前事务中的所有命令。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;DISCARD&lt;/td&gt;
&lt;td&gt;回滚事务队列中的所有命令，同时再将当前连接的状态恢复为正常状态，即非事务状态。如果WATCH命令被使用，该命令将UNWATCH所有的Keys。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;WATCH &lt;em&gt;key [key &amp;hellip;]&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;在MULTI命令执行之前，可以指定待监控的Keys，然而在执行EXEC之前，如果被监控的Keys发生修改，EXEC将放弃执行该事务队列中的所有命令。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;UNWATCH&lt;/td&gt;
&lt;td&gt;取消当前事务中指定监控的Keys，如果执行了EXEC或DISCARD命令，则无需再手工执行该命令了，因为在此之后，事务中所有被监控的Keys都将自动取消。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Redis编程式事务测试
 */
@Test
public void testTransactional() {
    Object obj = redisTemplate.execute(new SessionCallback() {
        @Override
        public Object execute(RedisOperations redisOperations) throws DataAccessException {
            String redisKey = &amp;quot;test:tx&amp;quot;;
            // 启用事务
            redisOperations.multi();

            // 事务逻辑
            redisOperations.opsForSet().add(redisKey,&amp;quot;张三&amp;quot;);
            redisOperations.opsForSet().add(redisKey,&amp;quot;李四&amp;quot;);
            redisOperations.opsForSet().add(redisKey,&amp;quot;王五&amp;quot;);
			// 该查询在事务内，不会有效
            System.out.println(redisOperations.opsForSet().members(redisKey));

            // 提交事务并返回
            return redisOperations.exec();
        }
    });

    System.out.println(obj);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;输出&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;[]
[1, 1, 1, [王五, 李四, 张三]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Redis 高性能存储入门</title>
      <link>https://halklein.github.io/2020/031/</link>
      <pubDate>Thu, 30 Jan 2020 15:31:41 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2020/031/</guid>
      <description>

&lt;h2 id=&#34;redis简介&#34;&gt;Redis简介&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/01/30/TSIZAhWOYXGcjVn.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Redis是一款基于键值对的&lt;strong&gt;NoSQL&lt;/strong&gt;数据库，它的值支持多种数据结构：
字符串（strings）、哈希（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）等。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Redis将所有的数据都存放在内存中，所以它的读写性能十分惊人。
同时，Redis还可以将内存中的数据以快照 (RDB，适合空闲的时候进行定时备份) 或日志 (AOF，可以实时存储，但恢复速度慢)  的形式保存到硬盘上，以保证数据的安全性。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Redis典型的应用场景包括：&lt;strong&gt;缓存&lt;/strong&gt;、&lt;strong&gt;排行榜&lt;/strong&gt;、&lt;strong&gt;计数器&lt;/strong&gt;、&lt;strong&gt;社交网络&lt;/strong&gt;、&lt;strong&gt;消息队列&lt;/strong&gt; (但Redis不是专业的消息队列工具) 等。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;官网：&lt;a href=&#34;https://redis.io&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://redis.io&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Windows平台：&lt;a href=&#34;https://github.com/microsoftarchive/redis&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/microsoftarchive/redis&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;安装-for-windows&#34;&gt;安装 for Windows&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;下载地址&lt;/strong&gt;：&lt;a href=&#34;https://github.com/microsoftarchive/redis/releases&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/microsoftarchive/redis/releases&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;默认端口&lt;/strong&gt;：&lt;code&gt;6379&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Redis默认内置了16个库 ，可以通过 select 0-15 进行切换，默认进入0&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;$ redis-cli
127.0.0.1:6379&amp;gt; select 1
OK
127.0.0.1:6379[1]&amp;gt; select 0
OK
127.0.0.1:6379&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;刷除库内的数据&lt;/strong&gt;：flushdb&lt;/p&gt;

&lt;p&gt;注意Redis中key的命名提倡使用 &lt;code&gt;:&lt;/code&gt; 连接而不是 &lt;code&gt;_&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;redis常用数据类型的使用&#34;&gt;Redis常用数据类型的使用&lt;/h2&gt;

&lt;h3 id=&#34;字符串-string-类型数据-测试&#34;&gt;&lt;strong&gt;字符串 （String）类型数据 测试&lt;/strong&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;# 存String测试
127.0.0.1:6379&amp;gt; set author HalKlein
OK
# 查询String数据
127.0.0.1:6379&amp;gt; get author
&amp;quot;HalKlein&amp;quot;
127.0.0.1:6379&amp;gt;
127.0.0.1:6379&amp;gt; set count 1
OK
127.0.0.1:6379&amp;gt; get count
&amp;quot;1&amp;quot;
# 加1
127.0.0.1:6379&amp;gt; incr count
(integer) 2
# 减1
127.0.0.1:6379&amp;gt; decr count
(integer) 1
127.0.0.1:6379&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h3 id=&#34;哈希-hashes-类型数据-测试&#34;&gt;哈希（hashes）类型数据 测试&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;# Hash存数据
127.0.0.1:6379&amp;gt; hset test:user id 1
(integer) 1
# Hash存数据
127.0.0.1:6379&amp;gt; hset test:user username HalKlein
(integer) 1
# Hash取数据
127.0.0.1:6379&amp;gt; hget test:user username
&amp;quot;HalKlein&amp;quot;
# Hash取数据
127.0.0.1:6379&amp;gt; hget test:user id
&amp;quot;1&amp;quot;
127.0.0.1:6379&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h3 id=&#34;列表-lists-类型数据-测试&#34;&gt;列表（lists）类型数据 测试&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/01/30/hIRMju15YPQnHFg.png&#34; alt=&#34;Redis列表&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Redis的列表可以看作一个横向的容器，&lt;/p&gt;

&lt;p&gt;我们往里面存数据时，支持从左边往里“装”，也支持从右边往里“装”，&lt;/p&gt;

&lt;p&gt;取数据时，支持从左边取数据，也支持从右边取数据，&lt;/p&gt;

&lt;p&gt;根据这样的设计，如果我们的数据从一端进，从另一端出，就可以看作是一个&lt;strong&gt;队列&lt;/strong&gt;；&lt;/p&gt;

&lt;p&gt;如果我们的数据从一端进，也从该端出，就可以看作是一个&lt;strong&gt;栈&lt;/strong&gt;；&lt;/p&gt;

&lt;h4 id=&#34;list左进右出演示&#34;&gt;&lt;strong&gt;List左进右出演示&lt;/strong&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;# List左端进数据
127.0.0.1:6379&amp;gt; lpush test:ids 101 102 103
(integer) 3
# List长度查询
127.0.0.1:6379&amp;gt; llen test:ids
(integer) 3
# 根据List下标查数据
127.0.0.1:6379&amp;gt; lindex test:ids 0
&amp;quot;103&amp;quot;
# 查询List某范围之间的数据
127.0.0.1:6379&amp;gt; lrange test:ids 0 2
1) &amp;quot;103&amp;quot;
2) &amp;quot;102&amp;quot;
3) &amp;quot;101&amp;quot;
# 从右端弹出数据
127.0.0.1:6379&amp;gt; rpop test:ids
&amp;quot;101&amp;quot;
# 从右端弹出数据
127.0.0.1:6379&amp;gt; rpop test:ids
&amp;quot;102&amp;quot;
# List长度查询
127.0.0.1:6379&amp;gt; llen test:ids
(integer) 1
127.0.0.1:6379&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h3 id=&#34;集合-sets-类型数据-测试&#34;&gt;集合（sets）类型数据 测试&lt;/h3&gt;

&lt;p&gt;集合是无序的，且内容是不能重复的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;# 集合中添加数据
127.0.0.1:6379&amp;gt; sadd test:student aaa bbb ccc ddd eee
(integer) 5
# 统计集合中元素个数
127.0.0.1:6379&amp;gt; scard test:student
(integer) 5
# 从集合中随机弹出一个元素
127.0.0.1:6379&amp;gt; spop test:student
&amp;quot;aaa&amp;quot;
# 从集合中随机弹出一个元素
127.0.0.1:6379&amp;gt; spop test:student
&amp;quot;eee&amp;quot;
# 查看集合中的元素
127.0.0.1:6379&amp;gt; smembers test:student
1) &amp;quot;bbb&amp;quot;
2) &amp;quot;ccc&amp;quot;
3) &amp;quot;ddd&amp;quot;
127.0.0.1:6379&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h3 id=&#34;有序集合-sorted-sets-类型数据-测试&#34;&gt;有序集合（sorted sets）类型数据 测试&lt;/h3&gt;

&lt;p&gt;顾名思义，该集合是有序的，它会根据元素的score进行排序（默认由小到大）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;# 有序集合添加数据
127.0.0.1:6379&amp;gt; zadd test:teachers 20 aaa 10 bbb 50 ccc 30 ddd 40 eee
(integer) 5
# 统计有序集合中元素数量
127.0.0.1:6379&amp;gt; zcard test:teachers
(integer) 5
# 查询有序集合中的元素的score
127.0.0.1:6379&amp;gt; zscore test:teachers eee
&amp;quot;40&amp;quot;
# 查询有序集合中元素的位置排名
127.0.0.1:6379&amp;gt; zrank test:teachers eee
(integer) 3
# 查询某个范围间的所有元素
127.0.0.1:6379&amp;gt; zrange test:teachers 0 3
1) &amp;quot;bbb&amp;quot;
2) &amp;quot;aaa&amp;quot;
3) &amp;quot;ddd&amp;quot;
4) &amp;quot;eee&amp;quot;
127.0.0.1:6379&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;其它的一些常用命令&#34;&gt;其它的一些常用命令&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;# 查询所有的key
127.0.0.1:6379&amp;gt; keys *
1) &amp;quot;author&amp;quot;
2) &amp;quot;test:user&amp;quot;
3) &amp;quot;count&amp;quot;
4) &amp;quot;test:ids&amp;quot;
5) &amp;quot;test:student&amp;quot;
6) &amp;quot;test:teachers&amp;quot;
# 查询以 ‘test’开头的key
127.0.0.1:6379&amp;gt; keys test*
1) &amp;quot;test:user&amp;quot;
2) &amp;quot;test:ids&amp;quot;
3) &amp;quot;test:student&amp;quot;
4) &amp;quot;test:teachers&amp;quot;
# 查询某个key对应的value的值的类型
127.0.0.1:6379&amp;gt; type test:user
hash
# 查询某个key是否存在
127.0.0.1:6379&amp;gt; exists test:user
(integer) 1
# 删除某个key，会连带value一起删除
127.0.0.1:6379&amp;gt; del test:user
(integer) 1
# 再次查询某个key是否存在
127.0.0.1:6379&amp;gt; exists test:user
(integer) 0
# 指定某个key的有效时间
127.0.0.1:6379&amp;gt; expire test:student 10
(integer) 1
# 查询所有的key
127.0.0.1:6379&amp;gt; keys *
1) &amp;quot;author&amp;quot;
2) &amp;quot;count&amp;quot;
3) &amp;quot;test:ids&amp;quot;
4) &amp;quot;test:student&amp;quot;
5) &amp;quot;test:teachers&amp;quot;
# 10多秒后，再次查询所有的key
127.0.0.1:6379&amp;gt; keys *
1) &amp;quot;author&amp;quot;
2) &amp;quot;count&amp;quot;
3) &amp;quot;test:ids&amp;quot;
4) &amp;quot;test:teachers&amp;quot;
127.0.0.1:6379&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用Spring AOP统一记录日志</title>
      <link>https://halklein.github.io/2020/030/</link>
      <pubDate>Thu, 30 Jan 2020 12:26:21 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2020/030/</guid>
      <description>

&lt;h2 id=&#34;需求&#34;&gt;需求&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/01/30/vaD453kgpyC9nI1.png&#34; alt=&#34;需求&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果我们每次都在业务组件中记录日志，但是记录日志并不是业务需求，它属于系统需求。&lt;/p&gt;

&lt;h2 id=&#34;aop的概念&#34;&gt;AOP的概念&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Aspect Oriented Programing&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​   即面向方面（切面）编程。
​   AOP是一种编程思想，是对OOP的补充，可以进一步提高编程的效率。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/01/30/hZgODSCvFdHEliQ.png&#34; alt=&#34;AOP的概念&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;aop的术语&#34;&gt;&lt;strong&gt;AOP的术语&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/01/30/FbLUmHqE5BWy7Nx.png&#34; alt=&#34;AOP的术语&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Target&lt;/strong&gt;：目标对象，程序中的每一个要处理的Bean我们称之为Target&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Joinpoint&lt;/strong&gt;：连接点，目标对象有很多地方能够被织入代码，其可以织入代码的地方，我们称之为连接点&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Aspect&lt;/strong&gt;：切面组件，AOP解决统一处理这些系统需求的方式是将代码定义到一个额外的Bean中，Pointcut声明代码到底要织入到哪些对象的哪些位置，Advice通知方法说明这个切面组件要处理怎样的逻辑。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Weaving&lt;/strong&gt;：切面组件在程序运行之前或之后，通过框架织入到某些连接点之上，在编译时织入效率会很高，但是系统未运行时，可能有些条件我们并不能得到，就需要在运行时织入，运行时织入很方便灵活，但是效率不高。&lt;/p&gt;

&lt;h2 id=&#34;aop的实现&#34;&gt;AOP的实现&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;AspectJ&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​   AspectJ是&lt;strong&gt;语言级&lt;/strong&gt;的实现（新的语言），它扩展了Java语言，定义了AOP语法。&lt;/p&gt;

&lt;p&gt;​   AspectJ在&lt;strong&gt;编译期&lt;/strong&gt;织入代码，支持各种类型的连接点，它有一个专门的编译器，用来生成遵守Java字节码规范的class文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Spring AOP&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​   Spring AOP使用纯 &lt;strong&gt;Java实现&lt;/strong&gt;，它&lt;strong&gt;不需要专门的编译过程&lt;/strong&gt;，也&lt;strong&gt;不需要特殊的类装载器&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;​   Spring AOP在 &lt;strong&gt;运行时&lt;/strong&gt; 通过代理的方式织入代码，&lt;strong&gt;只支持方法类型的连接点&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;​   Spring&lt;strong&gt;支持&lt;/strong&gt;对&lt;strong&gt;AspectJ&lt;/strong&gt;的集成。&lt;/p&gt;

&lt;h2 id=&#34;spring-aop-代理&#34;&gt;Spring AOP 代理&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;JDK 动态代理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​   Java提供的动态代理技术，可以在运行时创建&lt;strong&gt;接口&lt;/strong&gt;的代理实例。&lt;/p&gt;

&lt;p&gt;​   Spring AOP&lt;strong&gt;默认&lt;/strong&gt;采用此种方式，在接口的代理实例中织入代码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CGLib 动态代理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​   采用底层的&lt;strong&gt;字节码技术&lt;/strong&gt;，在运行时创建&lt;strong&gt;子类&lt;/strong&gt;代理实例。&lt;/p&gt;

&lt;p&gt;​   当目标对象不存在接口时，Spring AOP会采用此种方式，在子类实例中织入代码。&lt;/p&gt;

&lt;h2 id=&#34;示例-记录用户访问方法的信息&#34;&gt;示例 记录用户访问方法的信息&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
// 切面组件
@Aspect
public class ServiceLogAspect {

    // 记录日志
    private static final Logger logger = LoggerFactory.getLogger(ServiceLogAspect.class);

    /**
     * 定义切点@Pointcut，其中筛选目标，
     * 第1个*表示返回值任意，
     * 第2个*表示所有组件，
     * 第3个*表示所有的方法，
     * (..)表示所有的参数
     */
    @Pointcut(&amp;quot;execution(* me.halklein.community.service.*.*(..))&amp;quot;)
    public void pointcut() {

    }

    // 在连接点开始@Before，pointcut()表示切点是什么
    @Before(&amp;quot;pointcut()&amp;quot;)
    public void before(JoinPoint joinPoint) {
        // 记录格式：用户[IP地址]，在[xxx]，访问了[me.halklein.community.service.xxx()]
        // 获取Request对象
        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        HttpServletRequest request = attributes.getRequest();
        // 获取访问者IP
        String ip = request.getRemoteHost();
        String now = new SimpleDateFormat(&amp;quot;yyyy-MM-dd HH:mm:ss&amp;quot;).format(new Date());
        // 获取类名，方法名
        String target = joinPoint.getSignature().getDeclaringTypeName() + &amp;quot;.&amp;quot; + joinPoint.getSignature().getName();
        logger.info(String.format(&amp;quot;用户[%s]，在[%s]，访问了[%s].&amp;quot;, ip, now, target));
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;查看日志&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/01/30/aCo5ALIVRyr6l9U.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Spring统一处理异常</title>
      <link>https://halklein.github.io/2020/029/</link>
      <pubDate>Thu, 30 Jan 2020 11:57:56 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2020/029/</guid>
      <description>

&lt;p&gt;在系统出现错误时，我们希望系统给用户图形化的反馈，而不是一些状态错误信息。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/01/30/WfvGOd1js3tcQMe.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;各个层次都会出现错误，但其实最终都会抛出异常给表现层。所以我们只用在表现层中捕获异常，处理异常，就能处理系统中所有的异常。&lt;/p&gt;

&lt;h2 id=&#34;springboot自动化处理异常&#34;&gt;&lt;strong&gt;SpringBoot自动化处理异常&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;SpringBoot统一处理异常，我们需要在templates目录下新建&lt;code&gt;error&lt;/code&gt;目录，然后在里面新建错误页面文件，且文件的名字一定要对应错误状态码。就可以简单实现对异常的统一处理。&lt;/p&gt;

&lt;h2 id=&#34;spring处理异常&#34;&gt;&lt;strong&gt;Spring处理异常&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;但是SpringBoot统一处理异常，并不是很详细，有时候并不能满足我们的需要，我们可能需要进行更加详细和复杂的操作，这时可以使用Spring进行更详细的配置。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;@ControllerAdvice&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​   用于修饰类，表示该类是Controller的全局配置类。&lt;/p&gt;

&lt;p&gt;​   在此类中，可以对Controller进行如下三种全局配置：&lt;strong&gt;异常处理方案、绑定数据方案、绑定参数方案&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;@ExceptionHandler&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​   用于修饰方法，该方法会在Controller出现异常&lt;strong&gt;后&lt;/strong&gt;被调用，用于&lt;strong&gt;处理捕获到的异常&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;@ModelAttribute&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​   用于修饰方法，该方法会在Controller方法执行&lt;strong&gt;前&lt;/strong&gt;被调用，用于为Model对象&lt;strong&gt;绑定参数&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;@DataBinder&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​   用于修饰方法，该方法会在Controller方法执行&lt;strong&gt;前&lt;/strong&gt;被调用，用于&lt;strong&gt;绑定参数&lt;/strong&gt;的转换器。&lt;/p&gt;

&lt;p&gt;在controller包下advice包，里面新建ExceptionAdvice类，用于处理全局异常&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Controller异常全局配置类
 * annotations = Controller.class 只扫描Controller组件
 */
@ControllerAdvice(annotations = Controller.class)
public class ExceptionAdvice {

    private static final Logger logger = LoggerFactory.getLogger(ExceptionAdvice.class);

    /**
     * @ExceptionHandler 声明该方法用于处理异常
     * Exception.class 处理所有异常
     */
    @ExceptionHandler({Exception.class})
    public void handleException(Exception e, HttpServletRequest request, HttpServletResponse response) throws IOException {
        logger.error(&amp;quot;服务器发生异常: &amp;quot;, e.getMessage());
        // 遍历详细的异常栈信息
        for (StackTraceElement element : e.getStackTrace()) {
            logger.error(element.toString());
        }

        // 重定向
        // 判断是普通请求还是异步请求
        String xRequestWith = request.getHeader(&amp;quot;x-requested-with&amp;quot;);

        if (&amp;quot;XMLHttpRequest&amp;quot;.equals(xRequestWith)) {
            // XMLHttpRequest 异步请求

            // application/json 返回字符串后，浏览器会自动转换为json对象
            // application/plain 返回一个普通字符串，可以是json格式，浏览器需要认为转换为js对象
            response.setContentType(&amp;quot;application/plain;charset=utf-8&amp;quot;);
            // 输出
            PrintWriter writer = response.getWriter();
            writer.write(CommunityUtil.getJsonString(1, &amp;quot;服务器异常！&amp;quot;));
        } else {
            // 是一个普通请求，发生错误，我们进行重定向
            response.sendRedirect(request.getContextPath() + &amp;quot;/error&amp;quot;);
        }
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Spring事务管理</title>
      <link>https://halklein.github.io/2020/028/</link>
      <pubDate>Tue, 28 Jan 2020 18:59:06 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2020/028/</guid>
      <description>

&lt;h2 id=&#34;什么是事务&#34;&gt;什么是事务&lt;/h2&gt;

&lt;p&gt;事务是由N步数据库操作序列组成的逻辑执行单元，这系列操作要么全执行，要么全放弃执行。&lt;/p&gt;

&lt;h2 id=&#34;事务的特性-acid&#34;&gt;事务的特性（ACID）&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/01/28/NesIWh9K742wjdP.png&#34; alt=&#34;事务的特性&#34; /&gt;&lt;/p&gt;

&lt;p&gt;原子性（Atomicity）：事务是应用中不可再分的最小执行体。&lt;/p&gt;

&lt;p&gt;一致性（Consistency）：事务执行的结果，须使数据从一个一致性状态，变为另一个一致性状态。&lt;/p&gt;

&lt;p&gt;隔离性（Isolation）：各个事务的执行互不干扰，任何事务的内部操作对其他的事务都是隔离的。&lt;/p&gt;

&lt;p&gt;持久性（Durability）：事务一旦提交，对数据所做的任何改变都要记录到永久存储器中。&lt;/p&gt;

&lt;h2 id=&#34;事务的隔离性&#34;&gt;事务的隔离性&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;常见的并发异常&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一类丢失更新、第二类丢失更新。&lt;/p&gt;

&lt;p&gt;脏读、不可重复读、幻读。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;常见的隔离级别&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Read Uncommitted：读取未提交的数据。&lt;/p&gt;

&lt;p&gt;Read Committed：读取已提交的数据。&lt;/p&gt;

&lt;p&gt;Repeatable Read：可重复读。&lt;/p&gt;

&lt;p&gt;Serializable：串行化 （性能低）。&lt;/p&gt;

&lt;h3 id=&#34;常见的并发异常&#34;&gt;常见的并发异常&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;第一类丢失更新&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;某一个事务的回滚，导致另外一个事务已更新的数据丢失了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/01/28/r3B2UXDYupGqRtb.png&#34; alt=&#34;第一类丢失更新&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第二类丢失更新&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;某一个事务的提交，导致另外一个事务已更新的数据丢失了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/01/28/PHW9FnDOIZ6gRid.png&#34; alt=&#34;第二类丢失更新&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;脏读&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;某一个事务，读取了另外一个事务未提交的数据。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/01/28/uDXo7y28nI3ZVBs.png&#34; alt=&#34;脏读&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;不可重复读&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;某一个事务，对同一个数据前后读取的结果不一致。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/01/28/ZdOCKQrPpyBYE36.png&#34; alt=&#34;不可重复读&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;幻读&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;某一个事务，对同一个表前后查询到的行数不一致。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/01/28/CoYSLuRg2tQPWMf.png&#34; alt=&#34;幻读&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;常见的隔离级别&#34;&gt;常见的隔离级别&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/01/28/1lMsQTVYJGynihg.png&#34; alt=&#34;常见的隔离级别&#34; /&gt;&lt;/p&gt;

&lt;p&gt;一般来说，我们选择中间两种。第一中几乎没有改善；第四种由于性能非常低，一般是不选用的，除非是金融类业务，政府部分数据等才考虑。&lt;/p&gt;

&lt;h2 id=&#34;实现机制&#34;&gt;实现机制&lt;/h2&gt;

&lt;h3 id=&#34;悲观锁-数据库&#34;&gt;悲观锁（数据库）&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;共享锁（S锁）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;事务A对某数据加了共享锁后，其他事务只能对该数据加共享锁，但不能加排他锁。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;排他锁（X锁）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;事务A对某数据加了排他锁后，其他事务对该数据既不能加共享锁，也不能加排他锁。&lt;/p&gt;

&lt;h3 id=&#34;乐观锁-自定义&#34;&gt;乐观锁（自定义）&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;版本号、时间戳等&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在更新数据前，检查版本号是否发生变化。若变化则取消本次更新，否则就更新数据（版本号+1）。&lt;/p&gt;

&lt;h2 id=&#34;spring-事务管理-https-docs-spring-io-spring-docs-current-spring-framework-reference-data-access-html-spring-data-tier&#34;&gt;&lt;a href=&#34;https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#spring-data-tier&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Spring 事务管理&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;声明式事务&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过XML配置，声明某方法的事务特征。&lt;/p&gt;

&lt;p&gt;通过注解，声明某方法的事务特征。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;编程式事务&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过 TransactionTemplate 管理事务，并通过它执行数据库的操作。&lt;/p&gt;

&lt;p&gt;声明式事务基于 AOP，将具体业务逻辑与事务处理解耦。声明式事务管理使业务代码逻辑不受污染，因此在实际使用中声明式事务用的比较多。声明式事务有两种方式，一种是在配置文件（xml）中做相关的事务规则声明，另一种是基于@Transactional 注解的方式，注释配置是目前流行的使用方式。&lt;/p&gt;

&lt;h5 id=&#34;transactional-注解的属性信息&#34;&gt;@Transactional 注解的属性信息&lt;/h5&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;属性名&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;name&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;当在配置文件中有多个 TransactionManager , 可以用该属性指定选择哪个事务管理器。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;propagation&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;事务的传播行为，默认值为 REQUIRED。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;isolation&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;事务的隔离度，默认值采用 DEFAULT。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;timeout&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;read-only&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;指定事务是否为只读事务，默认值为 false；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;rollback-for&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;用于指定能够触发事务回滚的异常类型，如果有多个异常类型需要指定，各类型之间可以通过逗号分隔。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;no-rollback- for&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;抛出 no-rollback-for 指定的异常类型，不回滚事务。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;声明式事务示例&#34;&gt;声明式事务示例&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;业务方法&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
/*Spring容器管理的Bean默认是单例的，如果需要每次getBean都新建一个实例，需要加上如下
@Scope(&amp;quot;singleton&amp;quot;)是默认的（单例的）*/
@Scope(&amp;quot;prototype&amp;quot;) // 非单例，（极少使用）
public class AlphaService {

    @Autowired
    private UserMapper userMapper;

    @Autowired
    private DiscussPostMapper discussPostMapper;

    /**
     * Spring 事务管理测试
     * Spring 事务管理，加注解：@Transactional，设置事务级别：isolation = Isolation.READ_COMMITTED
     * propagation 事务的传播机制，解决事务交叉问题。如【 业务方法A 去调用 业务方法B 】他们都加有事务注解，那么B的事务应该以谁为准？的问题
     *      REQUIRED 支持当前事务（外部事务，上例事务A），如果不存在则创建新事务
     *      REQUIRES_NEW 创建一个新的事务，并且暂定当前事务（外部事务）
     *      NESTED 如果存在当前事务（外部事务），则嵌套在该事务中执行（B有独立的提交和回滚），否则就和 REQUIRED 一样
     *
     * @return
     */
    @Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRED)
    public Object save1() {
        // 新增用户
        User user = new User();
        user.setUsername(&amp;quot;alpha&amp;quot;);
        user.setSalt(CommunityUtil.generateUUID().substring(0, 5));
        user.setPassword(CommunityUtil.md5(&amp;quot;123&amp;quot;) + user.getSalt());
        user.setEmail(&amp;quot;alpha@qq.com&amp;quot;);
        user.setHeaderUrl(&amp;quot;http://image.nowcoder.com/99t.png&amp;quot;);
        user.setCreateTime(new Date());
        userMapper.insertUser(user);

        // 新增帖子
        DiscussPost post = new DiscussPost();
        post.setUserId(user.getId());
        post.setTitle(&amp;quot;Hello&amp;quot;);
        post.setContent(&amp;quot;新人报道&amp;quot;);
        post.setCreateTime(new Date());
        discussPostMapper.insertDiscussPost(post);

        // 人工制造错误，用于测试
        Integer.valueOf(&amp;quot;abc&amp;quot;);

        return &amp;quot;OK&amp;quot;;
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;测试类&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootTest
@ContextConfiguration(classes = CommunityApplication.class)
public class TransactionTests {

    @Autowired
    private AlphaService alphaService;

    @Test
    public void testSave1() {
        Object obj = alphaService.save1();
        System.out.println(obj);
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;测试结果&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;没有在数据库中新增用户，也没有新增一条帖子。&lt;/p&gt;

&lt;h3 id=&#34;编程式事务示例&#34;&gt;编程式事务示例&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;业务方法&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
/*Spring容器管理的Bean默认是单例的，如果需要每次getBean都新建一个实例，需要加上如下
@Scope(&amp;quot;singleton&amp;quot;)是默认的（单例的）*/
@Scope(&amp;quot;prototype&amp;quot;) //非单例，（极少使用）
public class AlphaService {

    @Autowired
    private UserMapper userMapper;

    @Autowired
    private DiscussPostMapper discussPostMapper;

    @Autowired
    private TransactionTemplate transactionTemplate;

    
    /**
     * 编程式事务示例
     * 1. 注入 TransactionTemplate ，这个Bean是Spring自动创建并装配到容器中的，所以直接注入即可
     * @return
     */
    public Object save2(){
        // 设置事务级别
        transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_READ_COMMITTED);
        // 设置传播机制
        transactionTemplate.setPropagationBehavior(transactionTemplate.PROPAGATION_REQUIRED);

        return transactionTemplate.execute(new TransactionCallback&amp;lt;Object&amp;gt;() {
            @Override
            public Object doInTransaction(TransactionStatus transactionStatus) {
                // 新增用户
                User user = new User();
                user.setUsername(&amp;quot;beta&amp;quot;);
                user.setSalt(CommunityUtil.generateUUID().substring(0, 5));
                user.setPassword(CommunityUtil.md5(&amp;quot;123&amp;quot;) + user.getSalt());
                user.setEmail(&amp;quot;beta@qq.com&amp;quot;);
                user.setHeaderUrl(&amp;quot;http://image.nowcoder.com/999t.png&amp;quot;);
                user.setCreateTime(new Date());
                userMapper.insertUser(user);

                // 新增帖子
                DiscussPost post = new DiscussPost();
                post.setUserId(user.getId());
                post.setTitle(&amp;quot;你好&amp;quot;);
                post.setContent(&amp;quot;我是新人&amp;quot;);
                post.setCreateTime(new Date());
                discussPostMapper.insertDiscussPost(post);

                // 人工制造错误，用于测试
                Integer.valueOf(&amp;quot;abc&amp;quot;);

                return &amp;quot;OK&amp;quot;;
            }
        });
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;测试类&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootTest
@ContextConfiguration(classes = CommunityApplication.class)
public class TransactionTests {

    @Autowired
    private AlphaService alphaService;


    @Test
    public void testSave2() {
        Object obj = alphaService.save2();
        System.out.println(obj);
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;测试结果&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;同上，没有在数据库中新增用户，也没有新增一条帖子。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PS&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一般情况下我们选用简单的声明式事务，但是如果有些业务方法过于复杂，而我们只希望管理其中一部分事务，则选用编程式事务。&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>IDEA引入依赖失败的解决办法</title>
      <link>https://halklein.github.io/2020/027/</link>
      <pubDate>Mon, 27 Jan 2020 19:11:39 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2020/027/</guid>
      <description>

&lt;h2 id=&#34;问题&#34;&gt;问题&lt;/h2&gt;

&lt;p&gt;今天学习异步消息，用到 FastJson 对 json 进行解析和生成，但是在 &lt;code&gt;pom.xml&lt;/code&gt; 中引入下面的依赖描述时，等待许久也无法下载完成。之后尝试进行科学上网，并开启全局代理，依然是下载失败或下载不完全。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;fastjson&amp;lt;/artifactId&amp;gt;
   &amp;lt;version&amp;gt;1.2.62&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;解决办法&#34;&gt;解决办法&lt;/h2&gt;

&lt;p&gt;1.在 &lt;a href=&#34;https://mvnrepository.com/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;MVNrepository&lt;/a&gt; 官网直接找到对应的 jar 包链接，&lt;a href=&#34;https://repo1.maven.org/maven2/com/alibaba/fastjson/1.2.62/fastjson-1.2.62.jar&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;点击进行下载&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/01/27/gOTSzU6IrYm1WtA.png&#34; alt=&#34;MVNrepository&#34; /&gt;&lt;/p&gt;

&lt;p&gt;2.找到下载jar包的所在目录，使用maven命令直接进行安装，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;mvn install:install-file -Dfile=E:\Download\Chrome\fastjson-1.2.62.jar -DgroupId=com.alibaba -DartifactId=fastjson -Dversion=1.2.62 -Dpackaging=jar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/01/27/2AB9iKW6RIdGCXT.png&#34; alt=&#34;对应参数&#34; /&gt;&lt;/p&gt;

&lt;p&gt;安装成功后显示存放路径&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/01/27/L4Hk3bv5F1CrwaM.png&#34; alt=&#34;安装成功&#34; /&gt;&lt;/p&gt;

&lt;p&gt;重启IDEA，重新加载依赖，就可以成功了！同理，其它的依赖应该也可以这样操作。&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;update-2020-01-30&#34;&gt;Update 2020/01/30&lt;/h2&gt;

&lt;p&gt;博主最后找到了原因（来自初学者的无奈），是因为Maven的配置路径被修改了，可能是因为我之前对IDEA进行了一次更新，导致部分配置丢失，恢复了默认配置。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/01/30/goHQhP8tO1C4a7Y.png&#34; alt=&#34;修改为本地的Maven，配置文件改为本地Maven的配置文件&#34; /&gt;&lt;/p&gt;

&lt;p&gt;其实这很容易发现，当SpringBoot添加依赖的时候，点击下方的进度条查看详细，你就可以看到该包的下载路径，如果不是来自于&lt;a href=&#34;maven.aliyun.com&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;maven.aliyun.com&lt;/a&gt;，是来自apache、maven.org这些的话下载会非常慢甚至失败！&lt;/p&gt;

&lt;p&gt;所以你需要在IDEA的setting中配置Maven为用户自己的Maven，但是主要的是Maven的配置文件无论用自带的还是自己的Mavan你都需要添加阿里云的镜像，这样在国内导入依赖的时候会快很多。&lt;/p&gt;

&lt;p&gt;在本地Maven配置文件settings.xml中修改（或添加）aliyun镜像：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;mirror&amp;gt;
      &amp;lt;id&amp;gt;alimaven&amp;lt;/id&amp;gt;
      &amp;lt;mirrorOf&amp;gt;central&amp;lt;/mirrorOf&amp;gt;
      &amp;lt;name&amp;gt;aliyun maven&amp;lt;/name&amp;gt;
      &amp;lt;url&amp;gt;https://maven.aliyun.com/repository/central&amp;lt;/url&amp;gt;
&amp;lt;/mirror&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>用前缀树过滤敏感词</title>
      <link>https://halklein.github.io/2020/026/</link>
      <pubDate>Mon, 27 Jan 2020 12:09:44 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2020/026/</guid>
      <description>

&lt;h3 id=&#34;前缀树&#34;&gt;&lt;strong&gt;前缀树&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;​   &lt;strong&gt;名称：&lt;/strong&gt;Trie、字典树、查找树&lt;/p&gt;

&lt;p&gt;​   &lt;strong&gt;特点：&lt;/strong&gt;查找效率高，消耗内存大&lt;/p&gt;

&lt;p&gt;​   &lt;strong&gt;应用：&lt;/strong&gt;字符串检索、词频统计、字符串排序等&lt;/p&gt;

&lt;h3 id=&#34;敏感词过滤器&#34;&gt;&lt;strong&gt;敏感词过滤器&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;​   定义前缀树根据敏感词&lt;/p&gt;

&lt;p&gt;​   初始化前缀树&lt;/p&gt;

&lt;p&gt;​   编写过滤敏感词的方法&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;简单的进行查找和replace替换无疑效率是非常低的，我们使用一种叫前缀树（Trie、字典树、查找树）的数据结构来实现高效过滤敏感词，数据结构及过滤图示如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/01/27/W93QTOZsYUSN6IB.png&#34; alt=&#34;过滤敏感词&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step1 定义敏感词文件sensitive-words.txt，放在resources目录下&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;VPN
翻墙
吸毒
开票
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Step2 敏感词过滤器&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 敏感词过滤器
@Component
public class SensitiveFilter {

    // 记录日志
    private static final Logger logger = LoggerFactory.getLogger(SensitiveFilter.class);

    // 替换符（检测到敏感词，替换为某符号，定义为常量）
    private static final String REPLACEMENT = &amp;quot;***&amp;quot;;

    // 初始化前缀树
    private TrieNode rootNode = new TrieNode();


    // @PostConstruct表示这是一个初始化方法，当容器实例化这个Bean以后在调用它的构造器之后这个方法就会被自动调用
    @PostConstruct
    public void init() {
        // 在classes路径下读取敏感词文件（需要先编译），获得字节流
        try (
                InputStream is = this.getClass().getClassLoader().getResourceAsStream(&amp;quot;sensitive-words.txt&amp;quot;);
                // 转为字符流，在转为缓冲流(效率会更高)
                BufferedReader reader = new BufferedReader(new InputStreamReader(is));
        ) {
            String keyword;
            while ((keyword = reader.readLine()) != null) {
                // 添加到前缀树中，这一步比较复杂，封装为一个方法
                this.addKeyword(keyword);
            }
        } catch (IOException e) {
            logger.error(&amp;quot;加载敏感词文件失败 : &amp;quot; + e.getMessage());
        }
    }

    // 将一个敏感词添加到前缀树中
    private void addKeyword(String keyword) {
        // 指针
        TrieNode tempNode = rootNode;
        for (int i = 0; i &amp;lt; keyword.length(); i++) {
            char c = keyword.charAt(i);
            TrieNode subNode = tempNode.getSubNode(c);
            if (subNode == null) {
                // 初始化子节点
                subNode = new TrieNode();
                tempNode.addSubNode(c, subNode);
            }

            // 让指针指向该子节点，进入下一轮循环
            tempNode = subNode;

            // 设置结束标识(到此为一个敏感词)
            if (i == keyword.length() - 1) {
                tempNode.setKeywordEnd(true);
            }
        }
    }


    /**
     * 过滤敏感词
     *
     * @param text 待过滤的文本
     * @return 过滤后的文本
     */
    public String filter(String text) {
        if (StringUtils.isBlank(text)) {
            return null;
        }

        // 指针1，指向前缀树
        TrieNode tempNode = rootNode;
        // 指针2，字符串指针
        int begin = 0;
        // 指针3，字符串指针
        int position = 0;
        // 记录生成的新字符串，使用可变长字符串
        StringBuilder sb = new StringBuilder();

        // 开始过滤
        while (position &amp;lt; text.length()) {
            char c = text.charAt(position);

            // 跳过符号，防止有的用户通过在敏感词中穿插各种符号来规避敏感词检测
            if (isSymbol(c)) {
                // 若指针1处于根节点，将此符号记入结果，让指针2向下走一步
                if (tempNode == rootNode) {
                    sb.append(c);
                    begin++;
                }
                // 无论符号在开头或中间，指针3都向下走一步
                position++;
                continue;
            }

            // 检查下级节点
            tempNode = tempNode.getSubNode(c);
            if (tempNode == null) {
                // 以begin为开头的字符串不是敏感词
                sb.append(text.charAt(begin));
                // 进入下一个位置
                position = ++begin;
                // 重新指向根节点
                tempNode = rootNode;
            } else if (tempNode.isKeywordEnd()) {
                // 发现了敏感词，将begin到position这段的字符串替换掉
                sb.append(REPLACEMENT);
                // 进入下一个位置
                begin = ++position;
                // 重新指向根节点
                tempNode = rootNode;
            } else {
                // 检查下一个字符
                position++;
            }
        }

        // 将最后一批字符计入结果
        sb.append(text.substring(begin));

        // 返回结果
        return sb.toString();
    }

    // 判断是否为符号
    private boolean isSymbol(Character c) {
        // 不是特殊符号，0x2E80到0x9FFF是东亚的文字范围
        return !CharUtils.isAsciiAlphanumeric(c) &amp;amp;&amp;amp; (c &amp;lt; 0x2E80 || c &amp;gt; 0x9FFF);
    }


    // 前缀树
    private class TrieNode {

        // 关键词结束标识
        private boolean isKeywordEnd = false;

        // 子节点(key是下级字符，value是下级节点)
        private Map&amp;lt;Character, TrieNode&amp;gt; subNodes = new HashMap&amp;lt;&amp;gt;();

        public boolean isKeywordEnd() {
            return isKeywordEnd;
        }

        public void setKeywordEnd(boolean keywordEnd) {
            isKeywordEnd = keywordEnd;
        }

        // 添加子节点
        public void addSubNode(Character c, TrieNode node) {
            subNodes.put(c, node);
        }

        //  获取子节点
        public TrieNode getSubNode(Character c) {
            return subNodes.get(c);
        }

    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Step3 过滤测试&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootTest
@ContextConfiguration(classes = CommunityApplication.class)
public class SensitiveTests {

    @Autowired
    private SensitiveFilter sensitiveFilter;

    @Test
    public void testSensitiveFilter(){
        String text = &amp;quot;我是敏感词，你来过滤我啊，测试VPN，测试翻墙，测试吸毒，测试开票，哈哈哈！&amp;quot;;
        System.out.println(sensitiveFilter.filter(text));

        text = &amp;quot;我是敏感词，你来过滤我啊，测试☆V☆P☆☆N☆，测试☆☆翻☆☆☆墙☆☆,☆测试☆吸☆☆毒☆☆☆，测试☆开☆☆票☆，哈哈哈！&amp;quot;;
        System.out.println(sensitiveFilter.filter(text));
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;我是敏感词，你来过滤我啊，测试***，测试***，测试***，测试***，哈哈哈！
我是敏感词，你来过滤我啊，测试☆***☆，测试☆☆***☆☆,☆测试☆***☆☆☆，测试☆***☆，哈哈哈！
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>常用的元注解</title>
      <link>https://halklein.github.io/2020/025/</link>
      <pubDate>Mon, 20 Jan 2020 20:35:11 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2020/025/</guid>
      <description>

&lt;h2 id=&#34;常用的元注解&#34;&gt;常用的元注解&lt;/h2&gt;

&lt;p&gt;当我们需要自定义注解时，要用到元注解定义我们自己的注解（所谓元注解，就是注解其它注解的注解），其中常见的元注解有以下四个：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;@Target&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;由于标识我们自定义注解的使用范围。从源码可以看到可以赋值为ElementType。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package java.lang.annotation;

@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.ANNOTATION_TYPE})
public @interface Target {
    ElementType[] value();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中ElementType定义如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public enum ElementType {
    TYPE,	// 类、接口、枚举类
    FIELD,	// 成员变量（包括：枚举常量）
    METHOD,	// 成员方法
    PARAMETER,	// 方法参数
    CONSTRUCTOR, 	// 构造方法
    LOCAL_VARIABLE,	// 局部变量
    ANNOTATION_TYPE,	// 注解类
    PACKAGE,	// 包
    TYPE_PARAMETER,	// 类型参数，JDK 1.8 新增
    TYPE_USE,	// 使用类型的任何地方，JDK 1.8 新增
    MODULE;	// 允许在模块上使用注解，JDK 1.9新增

    private ElementType() {
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@Retention&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用于说明自定义注解的有效时间或者说保留的时间（如：编译时有效、运行时有效等）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package java.lang.annotation;

@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.ANNOTATION_TYPE})
public @interface Retention {
    RetentionPolicy value();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;package java.lang.annotation;

public enum RetentionPolicy {
    SOURCE,	//源文件
    CLASS,	//编译时（默认）
    RUNTIME;	//运行时

    private RetentionPolicy() {
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@Document&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;声明在生成帮助文档的时候要不要把这个自定义注解信息也带上。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package java.lang.annotation;

@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.ANNOTATION_TYPE})
public @interface Documented {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@Inherited&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使被它修饰的自定义注解具有继承性。子类继承该自定义注解之后也具有该注解。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package java.lang.annotation;

@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.ANNOTATION_TYPE})
public @interface Inherited {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;PS&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一般来说，我们自定义注解，@Target和@Retention是都会用到的，用来指定作用的范围和时机&lt;/p&gt;

&lt;h2 id=&#34;如何读取注解&#34;&gt;如何读取注解&lt;/h2&gt;

&lt;p&gt;通过AnnotatedElement接口实现对自定义注解的解析&lt;/p&gt;

&lt;p&gt;Method.getDeclaredAnnotations（）
Method.getAnnotation（Class&lt;T&gt; annotationClass）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;看个例子：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;@Override
public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
    // 如果拦截到的是一个方法 : instanceof HandlerMethod
    if (handler instanceof HandlerMethod) {
        // 转型，方便获取内容
        HandlerMethod handlerMethod = (HandlerMethod) handler;
        Method method = handlerMethod.getMethod();
        // 取注解，取含有自定义注解：LoginRequired，的方法
        LoginRequired loginRequired = method.getAnnotation(LoginRequired.class);
        // 取注解后发现不为空，说明该方法需要登录才能访问，并且检测不到当前用户
        if (loginRequired != null &amp;amp;&amp;amp; hostHolder.getUser() == null) {
            // 使用response重定向到登录页
            response.sendRedirect(request.getContextPath() + &amp;quot;/login&amp;quot;);
            // 拒绝后续访问
            return false;
        }
    }
    return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>记第一次住院</title>
      <link>https://halklein.github.io/2020/024/</link>
      <pubDate>Fri, 03 Jan 2020 15:18:12 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2020/024/</guid>
      <description>&lt;p&gt;2020年元旦&lt;/p&gt;

&lt;p&gt;&lt;center&gt; ·No End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Web项目的一些调试技巧</title>
      <link>https://halklein.github.io/2019/023/</link>
      <pubDate>Sat, 28 Dec 2019 20:14:16 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/023/</guid>
      <description>

&lt;h2 id=&#34;1-响应状态码的含义&#34;&gt;1. 响应状态码的含义&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;200 OK&lt;/code&gt;，表明请求已经成功. 默认情况下状态码为200的响应可以被缓存。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;302 Found&lt;/code&gt;，重定向，服务器发送 &lt;code&gt;302&lt;/code&gt; 状态码和一个新的 &lt;code&gt;url&lt;/code&gt; 让浏览器再发一次新的请求，实现功能的跳转。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;404 Not Found&lt;/code&gt;，往往是路径配置有误。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;500 Internal Server Error&lt;/code&gt;，服务器接受到了请求，但是在处理的过程中发生了问题。&lt;/p&gt;

&lt;p&gt;详细信息请参考：&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-服务端断点调试技巧&#34;&gt;2. 服务端断点调试技巧&lt;/h2&gt;

&lt;p&gt;在IDEA中，打上断点后，需要以 Debug 方式运行程序。&lt;/p&gt;

&lt;p&gt;按 &lt;code&gt;F8&lt;/code&gt; 可以执行下一行&lt;/p&gt;

&lt;p&gt;按 &lt;code&gt;F7&lt;/code&gt; 可以进入到当前行执行的方法内部，查看更详细的调试信息&lt;/p&gt;

&lt;p&gt;按 &lt;code&gt;F9&lt;/code&gt; 可以一直向下执行直到遇到下一个断点处，注意在调试期间也可以在之后的程序代码中继续打断点，用于跳过一些繁杂的循环或者确定正确的程序段。&lt;/p&gt;

&lt;p&gt;有些信息可能是以Hash值显示，这时可以在下方调试框中展开看信息信息：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/28/ZM548VEUdLiYyaW.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果断点太多，你还可以批量管理断点：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/28/jRGKmuvIPdsegJk.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;3-客户端断点调试技巧&#34;&gt;3. 客户端断点调试技巧&lt;/h2&gt;

&lt;p&gt;这里主要是指对 JS 的调试。以Chrome浏览器为例，调出如下页面，&lt;code&gt;F10&lt;/code&gt;进入下一条语句，&lt;code&gt;F11&lt;/code&gt;进入当前语句，&lt;code&gt;F8&lt;/code&gt;到下一个断点或执行到底。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/28/hBezrIyuPVgJNUb.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;4-设置日志级别-并将日志输出到不同的终端&#34;&gt;4. 设置日志级别，并将日志输出到不同的终端&lt;/h2&gt;

&lt;p&gt;Spring boot内置默认的日志工具 &lt;a href=&#34;https://logback.qos.ch&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Logback&lt;/a&gt; ，&lt;a href=&#34;http://logback.qos.ch/manual/index.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;参考手册&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package org.slf4j; 
public interface Logger {
  // 日志级别，从低到高，等于或高于设定级别的日志将会在控制台输出
  public void trace(String message);
  public void debug(String message);
  public void info(String message); 
  public void warn(String message); 
  public void error(String message); 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;logger日志级别被Spring Boot整合后，可直接在 application.properties 文件中配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;# 配置logger日志级别，以便查看sql语句带来的错误等，方便查错
logging.level.me.leihao.community = debug
# 项目上线后是没有控制台的，我们可以将日志打印到文件里
logging.file.name = E:/Test/community.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在实际的项目开发中，日志文件是非常重要的，我们的设置会更复杂一些，会将不同级别的日志分成不同的文件，对单个文件如果太大也会进行拆分。&lt;/p&gt;

&lt;p&gt;首先，先注释掉 application.properties 文件中配置的 logger 日志&lt;/p&gt;

&lt;p&gt;然后，在 resources 目录下引入名为 &lt;code&gt;logback-spring.xml&lt;/code&gt; 的配置文件（注意命名是Spring规定的，不要乱改）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;configuration&amp;gt;
    &amp;lt;!--你的项目名--&amp;gt;
    &amp;lt;contextName&amp;gt;community&amp;lt;/contextName&amp;gt;
    &amp;lt;!--日志存储路径--&amp;gt;
    &amp;lt;property name=&amp;quot;LOG_PATH&amp;quot; value=&amp;quot;E:/Test/log&amp;quot;/&amp;gt;
    &amp;lt;!--子级目录，以区分不同项目--&amp;gt;
    &amp;lt;property name=&amp;quot;APPDIR&amp;quot; value=&amp;quot;community&amp;quot;/&amp;gt;

    &amp;lt;!-- error file --&amp;gt;
    &amp;lt;appender name=&amp;quot;FILE_ERROR&amp;quot; class=&amp;quot;ch.qos.logback.core.rolling.RollingFileAppender&amp;quot;&amp;gt;
        &amp;lt;!--分块规则--&amp;gt;
        &amp;lt;file&amp;gt;${LOG_PATH}/${APPDIR}/log_error.log&amp;lt;/file&amp;gt;
        &amp;lt;rollingPolicy class=&amp;quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&amp;quot;&amp;gt;
            &amp;lt;fileNamePattern&amp;gt;${LOG_PATH}/${APPDIR}/error/log-error-%d{yyyy-MM-dd}.%i.log&amp;lt;/fileNamePattern&amp;gt;
            &amp;lt;timeBasedFileNamingAndTriggeringPolicy class=&amp;quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&amp;quot;&amp;gt;
                &amp;lt;!--单个日志大小--&amp;gt;
                &amp;lt;maxFileSize&amp;gt;5MB&amp;lt;/maxFileSize&amp;gt;
            &amp;lt;/timeBasedFileNamingAndTriggeringPolicy&amp;gt;
            &amp;lt;!--日志最长保留时间--&amp;gt;
            &amp;lt;maxHistory&amp;gt;30&amp;lt;/maxHistory&amp;gt;
        &amp;lt;/rollingPolicy&amp;gt;
        &amp;lt;!--以追加方式存储日志--&amp;gt;
        &amp;lt;append&amp;gt;true&amp;lt;/append&amp;gt;
        &amp;lt;encoder class=&amp;quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&amp;quot;&amp;gt;
            &amp;lt;!--日志输出格式：日期、级别、线程、类、文件和行、提示--&amp;gt;
            &amp;lt;pattern&amp;gt;%d %level [%thread] %logger{10} [%file:%line] %msg%n&amp;lt;/pattern&amp;gt;
            &amp;lt;!--字符集--&amp;gt;
            &amp;lt;charset&amp;gt;utf-8&amp;lt;/charset&amp;gt;
        &amp;lt;/encoder&amp;gt;
        &amp;lt;filter class=&amp;quot;ch.qos.logback.classic.filter.LevelFilter&amp;quot;&amp;gt;
            &amp;lt;!--日志级别--&amp;gt;
            &amp;lt;level&amp;gt;error&amp;lt;/level&amp;gt;
            &amp;lt;onMatch&amp;gt;ACCEPT&amp;lt;/onMatch&amp;gt;
            &amp;lt;onMismatch&amp;gt;DENY&amp;lt;/onMismatch&amp;gt;
        &amp;lt;/filter&amp;gt;
    &amp;lt;/appender&amp;gt;

    &amp;lt;!-- warn file --&amp;gt;
    &amp;lt;appender name=&amp;quot;FILE_WARN&amp;quot; class=&amp;quot;ch.qos.logback.core.rolling.RollingFileAppender&amp;quot;&amp;gt;
        &amp;lt;file&amp;gt;${LOG_PATH}/${APPDIR}/log_warn.log&amp;lt;/file&amp;gt;
        &amp;lt;rollingPolicy class=&amp;quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&amp;quot;&amp;gt;
            &amp;lt;fileNamePattern&amp;gt;${LOG_PATH}/${APPDIR}/warn/log-warn-%d{yyyy-MM-dd}.%i.log&amp;lt;/fileNamePattern&amp;gt;
            &amp;lt;timeBasedFileNamingAndTriggeringPolicy class=&amp;quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&amp;quot;&amp;gt;
                &amp;lt;maxFileSize&amp;gt;5MB&amp;lt;/maxFileSize&amp;gt;
            &amp;lt;/timeBasedFileNamingAndTriggeringPolicy&amp;gt;
            &amp;lt;maxHistory&amp;gt;30&amp;lt;/maxHistory&amp;gt;
        &amp;lt;/rollingPolicy&amp;gt;
        &amp;lt;append&amp;gt;true&amp;lt;/append&amp;gt;
        &amp;lt;encoder class=&amp;quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&amp;quot;&amp;gt;
            &amp;lt;pattern&amp;gt;%d %level [%thread] %logger{10} [%file:%line] %msg%n&amp;lt;/pattern&amp;gt;
            &amp;lt;charset&amp;gt;utf-8&amp;lt;/charset&amp;gt;
        &amp;lt;/encoder&amp;gt;
        &amp;lt;filter class=&amp;quot;ch.qos.logback.classic.filter.LevelFilter&amp;quot;&amp;gt;
            &amp;lt;level&amp;gt;warn&amp;lt;/level&amp;gt;
            &amp;lt;onMatch&amp;gt;ACCEPT&amp;lt;/onMatch&amp;gt;
            &amp;lt;onMismatch&amp;gt;DENY&amp;lt;/onMismatch&amp;gt;
        &amp;lt;/filter&amp;gt;
    &amp;lt;/appender&amp;gt;

    &amp;lt;!-- info file --&amp;gt;
    &amp;lt;appender name=&amp;quot;FILE_INFO&amp;quot; class=&amp;quot;ch.qos.logback.core.rolling.RollingFileAppender&amp;quot;&amp;gt;
        &amp;lt;file&amp;gt;${LOG_PATH}/${APPDIR}/log_info.log&amp;lt;/file&amp;gt;
        &amp;lt;rollingPolicy class=&amp;quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&amp;quot;&amp;gt;
            &amp;lt;fileNamePattern&amp;gt;${LOG_PATH}/${APPDIR}/info/log-info-%d{yyyy-MM-dd}.%i.log&amp;lt;/fileNamePattern&amp;gt;
            &amp;lt;timeBasedFileNamingAndTriggeringPolicy class=&amp;quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&amp;quot;&amp;gt;
                &amp;lt;maxFileSize&amp;gt;5MB&amp;lt;/maxFileSize&amp;gt;
            &amp;lt;/timeBasedFileNamingAndTriggeringPolicy&amp;gt;
            &amp;lt;maxHistory&amp;gt;30&amp;lt;/maxHistory&amp;gt;
        &amp;lt;/rollingPolicy&amp;gt;
        &amp;lt;append&amp;gt;true&amp;lt;/append&amp;gt;
        &amp;lt;encoder class=&amp;quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&amp;quot;&amp;gt;
            &amp;lt;pattern&amp;gt;%d %level [%thread] %logger{10} [%file:%line] %msg%n&amp;lt;/pattern&amp;gt;
            &amp;lt;charset&amp;gt;utf-8&amp;lt;/charset&amp;gt;
        &amp;lt;/encoder&amp;gt;
        &amp;lt;filter class=&amp;quot;ch.qos.logback.classic.filter.LevelFilter&amp;quot;&amp;gt;
            &amp;lt;level&amp;gt;info&amp;lt;/level&amp;gt;
            &amp;lt;onMatch&amp;gt;ACCEPT&amp;lt;/onMatch&amp;gt;
            &amp;lt;onMismatch&amp;gt;DENY&amp;lt;/onMismatch&amp;gt;
        &amp;lt;/filter&amp;gt;
    &amp;lt;/appender&amp;gt;

    &amp;lt;!-- console 打印到控制台 --&amp;gt;
    &amp;lt;appender name=&amp;quot;STDOUT&amp;quot; class=&amp;quot;ch.qos.logback.core.ConsoleAppender&amp;quot;&amp;gt;
        &amp;lt;encoder&amp;gt;
            &amp;lt;pattern&amp;gt;%d %level [%thread] %logger{10} [%file:%line] %msg%n&amp;lt;/pattern&amp;gt;
            &amp;lt;charset&amp;gt;utf-8&amp;lt;/charset&amp;gt;
        &amp;lt;/encoder&amp;gt;
        &amp;lt;filter class=&amp;quot;ch.qos.logback.classic.filter.ThresholdFilter&amp;quot;&amp;gt;
            &amp;lt;!--控制台日志级别--&amp;gt;
            &amp;lt;level&amp;gt;debug&amp;lt;/level&amp;gt;
        &amp;lt;/filter&amp;gt;
    &amp;lt;/appender&amp;gt;

    &amp;lt;!--对某个包日志级别的单独声明--&amp;gt;
    &amp;lt;logger name=&amp;quot;me.leihao.community&amp;quot; level=&amp;quot;debug&amp;quot;/&amp;gt;

    &amp;lt;root level=&amp;quot;info&amp;quot;&amp;gt;
        &amp;lt;appender-ref ref=&amp;quot;FILE_ERROR&amp;quot;/&amp;gt;
        &amp;lt;appender-ref ref=&amp;quot;FILE_WARN&amp;quot;/&amp;gt;
        &amp;lt;appender-ref ref=&amp;quot;FILE_INFO&amp;quot;/&amp;gt;
        &amp;lt;appender-ref ref=&amp;quot;STDOUT&amp;quot;/&amp;gt;
    &amp;lt;/root&amp;gt;

&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>用 iTerm2 美化你的 Mac终端</title>
      <link>https://halklein.github.io/2019/022/</link>
      <pubDate>Wed, 25 Dec 2019 11:38:03 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/022/</guid>
      <description>

&lt;h2 id=&#34;先看看效果图&#34;&gt;先看看效果图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/25/bAyehHXWCwkLPSR.png&#34; alt=&#34;效果图&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;安装-iterm2&#34;&gt;安装 iTerm2&lt;/h2&gt;

&lt;p&gt;下载安装 &lt;a href=&#34;https://www.iterm2.com/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;iterm2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://iterm2.com/downloads/stable/latest&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://iterm2.com/downloads/stable/latest&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;安装 &lt;a href=&#34;https://ohmyz.sh/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;oh-my-zsh&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;sh -c &amp;quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;p&gt;sh -c &amp;ldquo;$(wget &lt;a href=&#34;https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh&lt;/a&gt; -O -)&amp;rdquo;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;若需要Homebrew，执行下面命令安装&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/usr/bin/ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;wget的安装&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;brew install wget
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如需科学上网：&lt;a href=&#34;https://www.noxxxx.com/mac-下终端走-ss-代理.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;参考&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在终端中直接运行命令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;export http_proxy=http://proxyAddress:port
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个办法的好处是简单直接，并且影响面很小（只对当前终端有效，退出就不行了）。&lt;/p&gt;

&lt;p&gt;如果你用的是ss代理，在当前终端运行以下命令，那么&lt;code&gt;wget&lt;/code&gt; &lt;code&gt;curl&lt;/code&gt; 这类网络命令都会经过ss代理&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;export ALL_PROXY=socks5://127.0.0.1:1080
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;下载配色方案&#34;&gt;下载配色方案&lt;/h2&gt;

&lt;p&gt;你可以在 &lt;a href=&#34;https://iterm2colorschemes.com/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;这里&lt;/a&gt; 查看配色方案。（这里我选择 &lt;strong&gt;Tomorrow Night Eighties&lt;/strong&gt;）&lt;/p&gt;

&lt;p&gt;然后到 &lt;a href=&#34;https://github.com/mbadolato/iTerm2-Color-Schemes&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;这里&lt;/a&gt; 下载 iterm2 的配色方案&lt;/p&gt;

&lt;p&gt;下载好之后，在iTerm2首选项中导入配色方案：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/25/b73i1KHnfIRov8N.png&#34; alt=&#34;首选项&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/25/BTOsYSQXWUZhHV3.png&#34; alt=&#34;选择配色文件&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;更换-zsh-默认的主题&#34;&gt;更换 zsh 默认的主题&lt;/h2&gt;

&lt;p&gt;我使用的主题是&lt;a href=&#34;https://github.com/Powerlevel9k/powerlevel9k/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;powerlevel9k&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;git clone https://github.com/bhilburn/powerlevel9k.git ~/.oh-my-zsh/custom/themes/powerlevel9k
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑配置文件 &lt;code&gt;vi ~/.zshrc&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;ZSH_THEME=&amp;quot;powerlevel9k/powerlevel9k&amp;quot;
# 命令左侧显示内容（当前目录 git 版本信息）
POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(context dir vcs)
# 命令右侧显示内容（命令运行状态，剩余内存，时间，cpu负载，剩余电量）
POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(status ram time load battery)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后运行 &lt;code&gt;source ~/.zshrc&lt;/code&gt; 命令，让其生效。&lt;/p&gt;

&lt;h2 id=&#34;更换字体&#34;&gt;更换字体&lt;/h2&gt;

&lt;p&gt;直接使用 &lt;code&gt;powerlevel9k&lt;/code&gt; 主题的话，因为默认字体不支持 icon，会出现一些乱码。&lt;/p&gt;

&lt;p&gt;因为 &lt;code&gt;powerlevel9k&lt;/code&gt; 中用到了大量的 icon，但是只有部分的字体支持 icon。目前对 icon 的支持得比较好的字体是 &lt;a href=&#34;https://www.nerdfonts.com/#home&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Nerd Font&lt;/a&gt;。brew 提供了 nerd 字体的安装。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;$ brew tap homebrew/cask-fonts
$ brew search nerd
==&amp;gt; Formulae
container-diff
==&amp;gt; Casks
font-3270-nerd-font
...
# 选择Nerd Font字体进行安装
$ brew cask install font-sourcecodepro-nerd-font
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装字体成功后，就可以在 iterm2 中设置了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/25/LqtHU8Z95oBdiFD.png&#34; alt=&#34;更改字体&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;插件&#34;&gt;插件&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;oh-my-zsh&lt;/code&gt; 有很多好用的插件，安装好的插件需要在 &lt;code&gt;~/.zshrc&lt;/code&gt; 中的 &lt;code&gt;plugins=(git autojump cp extract sudo z zsh-syntax-highlighting zsh-autosuggestions)&lt;/code&gt; 依次写入配置，用空格分开。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;autojump&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;记忆我们之前去过的目录，不需要多次 &lt;code&gt;cd&lt;/code&gt; ，直接 &lt;code&gt;j 目录名&lt;/code&gt; 就可以直接进入。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#安装
brew install autojump

#在 ~/.zshrc 中加入如下配置
[[ -s $(brew --prefix)/etc/profile.d/autojump.sh ]] &amp;amp;&amp;amp; . $(brew --prefix)/etc/profile.d/autojump.sh
source $ZSH/oh-my-zsh.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;zsh-autosuggestion&#34;&gt;&lt;strong&gt;zsh-autosuggestion&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;输入命令提示自动补全，然后按键盘 &lt;code&gt;→&lt;/code&gt; 即可补全&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#安装
$ git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;zsh-syntax-highlighting&#34;&gt;&lt;strong&gt;zsh-syntax-highlighting&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;命令高亮显示，错误显示红色&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;# 安装
$ git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;colorls&#34;&gt;&lt;strong&gt;colorls&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;显示文件图标&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;# 安装
sudo gem install colorls 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>关于数据库索引的一些问题</title>
      <link>https://halklein.github.io/2019/021/</link>
      <pubDate>Tue, 24 Dec 2019 21:22:50 +0800</pubDate>
      <author>dev.HalKlein@gmail.com (HalKlein)</author>
      <guid>https://halklein.github.io/2019/021/</guid>
      <description>

&lt;h2 id=&#34;一-密集索引和稀疏索引&#34;&gt;一、密集索引和稀疏索引&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;密集索引文件中的每个搜索码值都对应一个索引值&lt;/li&gt;
&lt;li&gt;稀疏索引文件只为索引码的某些值建立索引项&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/24/qtGm8r27hMxLDwV.png&#34; alt=&#34;密集索引和稀疏索引&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MySQL常见的数据库引擎：MyISAM只使用稀疏索引，InnoDB有且仅有一个密集索引&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;若一个主键被定义，该主键则作为密集索引&lt;/li&gt;
&lt;li&gt;若没有主键被定义，该表的第一个唯一非空索引则作为密集索引&lt;/li&gt;
&lt;li&gt;若不满足以上条件，innodb内部会生成一个隐藏主键（密集索引）&lt;/li&gt;
&lt;li&gt;非主键索引存储相关键位和其对应的主键值，包含两次查找&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;二-如何定位并优化慢查询sql&#34;&gt;二、如何定位并优化慢查询Sql&lt;/h2&gt;

&lt;p&gt;具体场景要具体分析，大致思路如下：
- 根据慢日志定位慢查询sql
- 使用explain等工具分析sql
- 修改sql或者尽量让sql走索引&lt;/p&gt;

&lt;h3 id=&#34;2-1-根据慢日志定位慢查询sql&#34;&gt;2.1 根据慢日志定位慢查询sql&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;# 查看数据库慢日志配置
mysql&amp;gt; show variables like &amp;quot;%quer%&amp;quot;;

# 查看慢日志数量
mysql&amp;gt; show status like &amp;quot;%slow_queries%&amp;quot;;

# 打开慢日志开关
mysql&amp;gt; set global slow_query_log = on;

# 设置慢日志记录阈值为1s，10s可以说是很慢很慢了，不具有参考价值
# 修改后可能需要重新连接数据库才能看到效果
# 另外，这样的设置在重启MySQL服务之后将会失效！如果要永久生效,需修改my.ini配置文件（Mac OS是my.cnf）
mysql&amp;gt; set global long_query_time = 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/24/NFSpx65OUvuqQhD.png&#34; alt=&#34;查看数据库慢日志配置&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-2-使用explain等工具分析sql&#34;&gt;2.2 使用explain等工具分析sql&lt;/h3&gt;

&lt;p&gt;只需在查询语句前加上 &lt;code&gt;explain&lt;/code&gt; 即可，如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;mysql&amp;gt; explain select ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-3-修改sql或者尽量让sql走索引&#34;&gt;2.3 修改sql或者尽量让sql走索引&lt;/h3&gt;

&lt;h2 id=&#34;三-联合索引的最左匹配原则的成因&#34;&gt;三、联合索引的最左匹配原则的成因&lt;/h2&gt;

&lt;h2 id=&#34;四-索引是建立得越多越好吗&#34;&gt;四、索引是建立得越多越好吗&lt;/h2&gt;

&lt;p&gt;&lt;center&gt; ·End· &lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>